import {
  CalendarIcon,
  ClockIcon,
  DEFAULT_DESKTOP_MODE_MEDIA_QUERY,
  DIGITAL_CLOCK_VIEW_HEIGHT,
  DateCalendar,
  DatePicker,
  DateRangeIcon,
  MULTI_SECTION_CLOCK_SECTION_WIDTH,
  PickerViewRoot,
  PickersArrowSwitcher,
  PickersToolbar,
  PickersToolbarButton,
  PickersToolbarText,
  SECTION_TYPE_GRANULARITY,
  TimeIcon,
  VIEW_HEIGHT,
  applyDefaultDate,
  applyDefaultViewProps,
  arrayIncludes,
  convertValueToMeridiem,
  createIsAfterIgnoreDatePart,
  extractValidationProps,
  formatMeridiem,
  getTodayDate,
  isDatePickerView,
  isInternalTimeView,
  isTimeView,
  renderDateViewCalendar,
  resolveDateFormat,
  resolveTimeFormat,
  singleItemFieldValueManager,
  singleItemValueManager,
  splitFieldInternalAndForwardedProps,
  uncapitalizeObjectKeys,
  useClearableField,
  useControlledValueWithTimezone,
  useDefaultDates,
  useDesktopPicker,
  useField,
  useLocaleText,
  useMeridiemMode,
  useMobilePicker,
  useNow,
  useUtils,
  useViews,
  validateDateTime,
  validateTime
} from "./chunk-4F7RJKJR.js";
import "./chunk-EVSIAJYM.js";
import "./chunk-RW3DMCEO.js";
import {
  require_VisibilityOff
} from "./chunk-GK7OXPDY.js";
import {
  AlertTitle_default,
  Alert_default,
  Autocomplete_default,
  Badge_default,
  Collapse_default,
  DialogTitle_default,
  LinearProgress_default,
  PaginationItem_default,
  Pagination_default,
  Skeleton_default,
  Switch_default,
  Tab_default,
  TableBody_default,
  TableCell_default,
  TableContainer_default,
  TableFooter_default,
  TableHead_default,
  TableRow_default,
  TableSortLabel_default,
  Table_default,
  Tabs_default,
  tabsClasses_default
} from "./chunk-G4ZRAVLG.js";
import {
  DialogActions_default,
  DialogContent_default,
  Dialog_default,
  useMediaQuery
} from "./chunk-63GYAK2T.js";
import {
  Tooltip_default
} from "./chunk-3EYYG4OQ.js";
import "./chunk-EUW2UBTD.js";
import {
  Radio_default
} from "./chunk-3B4ZFEHS.js";
import {
  Slider_default
} from "./chunk-6IZQA4UW.js";
import {
  TextField_default
} from "./chunk-DCNX3ZIN.js";
import {
  Select_default
} from "./chunk-4YF4MHWF.js";
import "./chunk-74PRJT3P.js";
import "./chunk-7XOAPJWS.js";
import "./chunk-7Q4NXL2H.js";
import "./chunk-33MYK2RE.js";
import {
  MenuList_default,
  Menu_default,
  Popover_default
} from "./chunk-YL42D42N.js";
import {
  Grow_default
} from "./chunk-KAJYNDTR.js";
import "./chunk-XU2ZARI2.js";
import {
  MenuItem_default
} from "./chunk-PDBP6RMF.js";
import "./chunk-W53S34FI.js";
import {
  ListItemIcon_default
} from "./chunk-IZFTQNWF.js";
import "./chunk-VOQPDXA5.js";
import "./chunk-JSTRAMYD.js";
import {
  Fade_default
} from "./chunk-HSCAHN3I.js";
import "./chunk-TJ4WWSAQ.js";
import "./chunk-5FOM2W44.js";
import {
  FormControlLabel_default
} from "./chunk-R2FCHUFE.js";
import {
  Stack_default
} from "./chunk-RSKCCP5J.js";
import "./chunk-ZM5PNLN7.js";
import "./chunk-AKKANAVW.js";
import {
  IconButton_default
} from "./chunk-BGJYY6QH.js";
import {
  InputAdornment_default
} from "./chunk-TK3HATLA.js";
import {
  FormHelperText_default
} from "./chunk-YAXY3ULI.js";
import {
  InputLabel_default
} from "./chunk-HAHC6W6N.js";
import "./chunk-PR6ZCO7G.js";
import {
  Button_default
} from "./chunk-WOXK367X.js";
import {
  Paper_default
} from "./chunk-MGAZUKUU.js";
import {
  Typography_default
} from "./chunk-Y7HB4MDA.js";
import {
  Checkbox_default
} from "./chunk-TPIJA6O2.js";
import "./chunk-HXTSBMQB.js";
import "./chunk-LQ43REXA.js";
import {
  CircularProgress_default
} from "./chunk-GVG5VQLC.js";
import {
  Chip_default
} from "./chunk-WCDHSH5O.js";
import "./chunk-2BAVCE7B.js";
import "./chunk-YZIDAYI6.js";
import {
  require_react_dom
} from "./chunk-ZRJG7NCB.js";
import {
  Divider_default
} from "./chunk-VFRQ6MHG.js";
import {
  Box_default
} from "./chunk-HUCOKYLD.js";
import "./chunk-2GIN5NST.js";
import "./chunk-FMFFUJ5P.js";
import {
  useTheme
} from "./chunk-GT4KHHEM.js";
import {
  require_ChevronLeft
} from "./chunk-T3PC6ZIP.js";
import {
  require_ChevronRight
} from "./chunk-7Q5UMC3E.js";
import {
  require_ClearAll
} from "./chunk-U3FBRS7I.js";
import {
  require_ExpandMore
} from "./chunk-XZYHK3LW.js";
import {
  require_Close
} from "./chunk-DHUBYQLG.js";
import {
  require_FilterList
} from "./chunk-UDOTU3QB.js";
import "./chunk-22HOGAFZ.js";
import {
  resolveComponentProps,
  useSlotProps
} from "./chunk-O5YMKWIU.js";
import {
  require_createSvgIcon,
  require_interopRequireDefault
} from "./chunk-WHTZUM4J.js";
import {
  init_utils as init_utils2
} from "./chunk-FVWLSSVX.js";
import "./chunk-UOZCUDR4.js";
import {
  debounce_default
} from "./chunk-CHMBNDFP.js";
import "./chunk-MAFCOARG.js";
import "./chunk-Z5QKQ5QW.js";
import "./chunk-NY7Z5Q6W.js";
import "./chunk-DBC7QASU.js";
import "./chunk-FN72KEKX.js";
import "./chunk-G4BL6UE6.js";
import "./chunk-LDJ54HAC.js";
import "./chunk-SS2LXXHR.js";
import "./chunk-XL6XNCW3.js";
import {
  styled_default,
  useThemeProps
} from "./chunk-U6GK5DAY.js";
import {
  alpha,
  darken,
  lighten
} from "./chunk-MJC5SXNE.js";
import "./chunk-HQXIBK4A.js";
import {
  _objectWithoutPropertiesLoose,
  clsx_default,
  init_clsx,
  init_objectWithoutPropertiesLoose
} from "./chunk-ZZOAA75S.js";
import {
  require_jsx_runtime
} from "./chunk-CTRIHH5C.js";
import {
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  init_composeClasses,
  init_generateUtilityClass,
  init_generateUtilityClasses,
  init_useEventCallback,
  init_useForkRef,
  init_utils,
  refType_default,
  useEnhancedEffect_default,
  useEventCallback_default,
  useForkRef,
  useId
} from "./chunk-LJBUDJCS.js";
import {
  require_prop_types
} from "./chunk-KW7I6PFH.js";
import {
  _extends,
  init_extends
} from "./chunk-A4M3BDHA.js";
import {
  require_react
} from "./chunk-2EXEP7CN.js";
import {
  __commonJS,
  __toESM
} from "./chunk-WXXH56N5.js";

// node_modules/@mui/icons-material/ArrowDownward.js
var require_ArrowDownward = __commonJS({
  "node_modules/@mui/icons-material/ArrowDownward.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8z"
    }), "ArrowDownward");
  }
});

// node_modules/@mui/icons-material/ArrowRight.js
var require_ArrowRight = __commonJS({
  "node_modules/@mui/icons-material/ArrowRight.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "m10 17 5-5-5-5z"
    }), "ArrowRight");
  }
});

// node_modules/@mui/icons-material/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/@mui/icons-material/Cancel.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2m5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12z"
    }), "Cancel");
  }
});

// node_modules/@mui/icons-material/ContentCopy.js
var require_ContentCopy = __commonJS({
  "node_modules/@mui/icons-material/ContentCopy.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"
    }), "ContentCopy");
  }
});

// node_modules/@mui/icons-material/DensityLarge.js
var require_DensityLarge = __commonJS({
  "node_modules/@mui/icons-material/DensityLarge.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 3h18v2H3zm0 16h18v2H3z"
    }), "DensityLarge");
  }
});

// node_modules/@mui/icons-material/DensityMedium.js
var require_DensityMedium = __commonJS({
  "node_modules/@mui/icons-material/DensityMedium.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 3h18v2H3zm0 16h18v2H3zm0-8h18v2H3z"
    }), "DensityMedium");
  }
});

// node_modules/@mui/icons-material/DensitySmall.js
var require_DensitySmall = __commonJS({
  "node_modules/@mui/icons-material/DensitySmall.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 2h18v2H3zm0 18h18v2H3zm0-6h18v2H3zm0-6h18v2H3z"
    }), "DensitySmall");
  }
});

// node_modules/@mui/icons-material/DragHandle.js
var require_DragHandle = __commonJS({
  "node_modules/@mui/icons-material/DragHandle.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M20 9H4v2h16zM4 15h16v-2H4z"
    }), "DragHandle");
  }
});

// node_modules/@mui/icons-material/DynamicFeed.js
var require_DynamicFeed = __commonJS({
  "node_modules/@mui/icons-material/DynamicFeed.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)([(0, _jsxRuntime.jsx)("path", {
      d: "M8 8H6v7c0 1.1.9 2 2 2h9v-2H8z"
    }, "0"), (0, _jsxRuntime.jsx)("path", {
      d: "M20 3h-8c-1.1 0-2 .9-2 2v6c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m0 8h-8V7h8zM4 12H2v7c0 1.1.9 2 2 2h9v-2H4z"
    }, "1")], "DynamicFeed");
  }
});

// node_modules/@mui/icons-material/Edit.js
var require_Edit = __commonJS({
  "node_modules/@mui/icons-material/Edit.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z"
    }), "Edit");
  }
});

// node_modules/@mui/icons-material/FilterAlt.js
var require_FilterAlt = __commonJS({
  "node_modules/@mui/icons-material/FilterAlt.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39c.51-.66.04-1.61-.79-1.61H5.04c-.83 0-1.3.95-.79 1.61"
    }), "FilterAlt");
  }
});

// node_modules/@mui/icons-material/FilterListOff.js
var require_FilterListOff = __commonJS({
  "node_modules/@mui/icons-material/FilterListOff.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M10.83 8H21V6H8.83zm5 5H18v-2h-4.17zM14 16.83V18h-4v-2h3.17l-3-3H6v-2h2.17l-3-3H3V6h.17L1.39 4.22 2.8 2.81l18.38 18.38-1.41 1.41z"
    }), "FilterListOff");
  }
});

// node_modules/@mui/icons-material/FirstPage.js
var require_FirstPage = __commonJS({
  "node_modules/@mui/icons-material/FirstPage.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M18.41 16.59 13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
    }), "FirstPage");
  }
});

// node_modules/@mui/icons-material/Fullscreen.js
var require_Fullscreen = __commonJS({
  "node_modules/@mui/icons-material/Fullscreen.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M7 14H5v5h5v-2H7zm-2-4h2V7h3V5H5zm12 7h-3v2h5v-5h-2zM14 5v2h3v3h2V5z"
    }), "Fullscreen");
  }
});

// node_modules/@mui/icons-material/FullscreenExit.js
var require_FullscreenExit = __commonJS({
  "node_modules/@mui/icons-material/FullscreenExit.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z"
    }), "FullscreenExit");
  }
});

// node_modules/@mui/icons-material/KeyboardDoubleArrowDown.js
var require_KeyboardDoubleArrowDown = __commonJS({
  "node_modules/@mui/icons-material/KeyboardDoubleArrowDown.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)([(0, _jsxRuntime.jsx)("path", {
      d: "M18 6.41 16.59 5 12 9.58 7.41 5 6 6.41l6 6z"
    }, "0"), (0, _jsxRuntime.jsx)("path", {
      d: "m18 13-1.41-1.41L12 16.17l-4.59-4.58L6 13l6 6z"
    }, "1")], "KeyboardDoubleArrowDown");
  }
});

// node_modules/@mui/icons-material/LastPage.js
var require_LastPage = __commonJS({
  "node_modules/@mui/icons-material/LastPage.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M5.59 7.41 10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
    }), "LastPage");
  }
});

// node_modules/@mui/icons-material/MoreHoriz.js
var require_MoreHoriz = __commonJS({
  "node_modules/@mui/icons-material/MoreHoriz.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
    }), "MoreHoriz");
  }
});

// node_modules/@mui/icons-material/MoreVert.js
var require_MoreVert = __commonJS({
  "node_modules/@mui/icons-material/MoreVert.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
    }), "MoreVert");
  }
});

// node_modules/@mui/icons-material/PushPin.js
var require_PushPin = __commonJS({
  "node_modules/@mui/icons-material/PushPin.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      fillRule: "evenodd",
      d: "M16 9V4h1c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1h1v5c0 1.66-1.34 3-3 3v2h5.97v7l1 1 1-1v-7H19v-2c-1.66 0-3-1.34-3-3"
    }), "PushPin");
  }
});

// node_modules/@mui/icons-material/RestartAlt.js
var require_RestartAlt = __commonJS({
  "node_modules/@mui/icons-material/RestartAlt.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M12 5V2L8 6l4 4V7c3.31 0 6 2.69 6 6 0 2.97-2.17 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93 0-4.42-3.58-8-8-8m-6 8c0-1.65.67-3.15 1.76-4.24L6.34 7.34C4.9 8.79 4 10.79 4 13c0 4.08 3.05 7.44 7 7.93v-2.02c-2.83-.48-5-2.94-5-5.91"
    }), "RestartAlt");
  }
});

// node_modules/@mui/icons-material/Save.js
var require_Save = __commonJS({
  "node_modules/@mui/icons-material/Save.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3m3-10H5V5h10z"
    }), "Save");
  }
});

// node_modules/@mui/icons-material/Search.js
var require_Search = __commonJS({
  "node_modules/@mui/icons-material/Search.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
    }), "Search");
  }
});

// node_modules/@mui/icons-material/SearchOff.js
var require_SearchOff = __commonJS({
  "node_modules/@mui/icons-material/SearchOff.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)([(0, _jsxRuntime.jsx)("path", {
      d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3 6.08 3 3.28 5.64 3.03 9h2.02C5.3 6.75 7.18 5 9.5 5 11.99 5 14 7.01 14 9.5S11.99 14 9.5 14c-.17 0-.33-.03-.5-.05v2.02c.17.02.33.03.5.03 1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19z"
    }, "0"), (0, _jsxRuntime.jsx)("path", {
      d: "M6.47 10.82 4 13.29l-2.47-2.47-.71.71L3.29 14 .82 16.47l.71.71L4 14.71l2.47 2.47.71-.71L4.71 14l2.47-2.47z"
    }, "1")], "SearchOff");
  }
});

// node_modules/@mui/icons-material/Sort.js
var require_Sort = __commonJS({
  "node_modules/@mui/icons-material/Sort.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M3 18h6v-2H3zM3 6v2h18V6zm0 7h12v-2H3z"
    }), "Sort");
  }
});

// node_modules/@mui/icons-material/SyncAlt.js
var require_SyncAlt = __commonJS({
  "node_modules/@mui/icons-material/SyncAlt.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "m18 12 4-4-4-4v3H3v2h15zM6 12l-4 4 4 4v-3h15v-2H6z"
    }), "SyncAlt");
  }
});

// node_modules/@mui/icons-material/ViewColumn.js
var require_ViewColumn = __commonJS({
  "node_modules/@mui/icons-material/ViewColumn.js"(exports) {
    "use strict";
    "use client";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
    var _jsxRuntime = require_jsx_runtime();
    var _default = exports.default = (0, _createSvgIcon.default)((0, _jsxRuntime.jsx)("path", {
      d: "M14.67 5v14H9.33V5zm1 14H21V5h-5.33zm-7.34 0V5H3v14z"
    }), "ViewColumn");
  }
});

// node_modules/@tanstack/react-table/build/lib/index.mjs
var React = __toESM(require_react(), 1);

// node_modules/@tanstack/table-core/build/lib/index.mjs
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function makeStateUpdater(key, instance) {
  return (updater) => {
    instance.setState((old) => {
      return {
        ...old,
        [key]: functionalUpdate(updater, old[key])
      };
    });
  };
}
function isFunction(d) {
  return d instanceof Function;
}
function isNumberArray(d) {
  return Array.isArray(d) && d.every((val) => typeof val === "number");
}
function flattenBy(arr, getChildren) {
  const flat = [];
  const recurse = (subArr) => {
    subArr.forEach((item) => {
      flat.push(item);
      const children = getChildren(item);
      if (children != null && children.length) {
        recurse(children);
      }
    });
  };
  recurse(arr);
  return flat;
}
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    let depTime;
    if (opts.key && opts.debug)
      depTime = Date.now();
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && opts.debug)
      resultTime = Date.now();
    result = fn(...newDeps);
    opts == null || opts.onChange == null || opts.onChange(result);
    if (opts.key && opts.debug) {
      if (opts != null && opts.debug()) {
        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
        const resultFpsPercentage = resultEndTime / 16;
        const pad = (str, num) => {
          str = String(str);
          while (str.length < num) {
            str = " " + str;
          }
          return str;
        };
        console.info(`%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);
      }
    }
    return result;
  };
}
function getMemoOptions(tableOptions, debugLevel, key, onChange) {
  return {
    debug: () => {
      var _tableOptions$debugAl;
      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];
    },
    key,
    onChange
  };
}
function createColumn(table, columnDef, depth, parent) {
  var _ref, _resolvedColumnDef$id;
  const defaultColumn = table._getDefaultColumnDef();
  const resolvedColumnDef = {
    ...defaultColumn,
    ...columnDef
  };
  const accessorKey = resolvedColumnDef.accessorKey;
  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace(".", "_") : void 0) != null ? _ref : typeof resolvedColumnDef.header === "string" ? resolvedColumnDef.header : void 0;
  let accessorFn;
  if (resolvedColumnDef.accessorFn) {
    accessorFn = resolvedColumnDef.accessorFn;
  } else if (accessorKey) {
    if (accessorKey.includes(".")) {
      accessorFn = (originalRow) => {
        let result = originalRow;
        for (const key of accessorKey.split(".")) {
          var _result;
          result = (_result = result) == null ? void 0 : _result[key];
          if (result === void 0) {
            console.warn(`"${key}" in deeply nested key "${accessorKey}" returned undefined.`);
          }
        }
        return result;
      };
    } else {
      accessorFn = (originalRow) => originalRow[resolvedColumnDef.accessorKey];
    }
  }
  if (!id) {
    if (true) {
      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);
    }
    throw new Error();
  }
  let column = {
    id: `${String(id)}`,
    accessorFn,
    parent,
    depth,
    columnDef: resolvedColumnDef,
    columns: [],
    getFlatColumns: memo(() => [true], () => {
      var _column$columns;
      return [column, ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d) => d.getFlatColumns())];
    }, getMemoOptions(table.options, "debugColumns", "column.getFlatColumns")),
    getLeafColumns: memo(() => [table._getOrderColumnsFn()], (orderColumns2) => {
      var _column$columns2;
      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {
        let leafColumns = column.columns.flatMap((column2) => column2.getLeafColumns());
        return orderColumns2(leafColumns);
      }
      return [column];
    }, getMemoOptions(table.options, "debugColumns", "column.getLeafColumns"))
  };
  for (const feature of table._features) {
    feature.createColumn == null || feature.createColumn(column, table);
  }
  return column;
}
var debug = "debugHeaders";
function createHeader(table, column, options) {
  var _options$id;
  const id = (_options$id = options.id) != null ? _options$id : column.id;
  let header = {
    id,
    column,
    index: options.index,
    isPlaceholder: !!options.isPlaceholder,
    placeholderId: options.placeholderId,
    depth: options.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const leafHeaders = [];
      const recurseHeader = (h) => {
        if (h.subHeaders && h.subHeaders.length) {
          h.subHeaders.map(recurseHeader);
        }
        leafHeaders.push(h);
      };
      recurseHeader(header);
      return leafHeaders;
    },
    getContext: () => ({
      table,
      header,
      column
    })
  };
  table._features.forEach((feature) => {
    feature.createHeader == null || feature.createHeader(header, table);
  });
  return header;
}
var Headers = {
  createTable: (table) => {
    table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      var _left$map$filter, _right$map$filter;
      const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];
      const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];
      const centerColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);
      return headerGroups;
    }, getMemoOptions(table.options, debug, "getHeaderGroups"));
    table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {
      leafColumns = leafColumns.filter((column) => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));
      return buildHeaderGroups(allColumns, leafColumns, table, "center");
    }, getMemoOptions(table.options, debug, "getCenterHeaderGroups"));
    table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {
      var _left$map$filter2;
      const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "left");
    }, getMemoOptions(table.options, debug, "getLeftHeaderGroups"));
    table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {
      var _right$map$filter2;
      const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId) => leafColumns.find((d) => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];
      return buildHeaderGroups(allColumns, orderedLeafColumns, table, "right");
    }, getMemoOptions(table.options, debug, "getRightHeaderGroups"));
    table.getFooterGroups = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getFooterGroups"));
    table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getLeftFooterGroups"));
    table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getCenterFooterGroups"));
    table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], (headerGroups) => {
      return [...headerGroups].reverse();
    }, getMemoOptions(table.options, debug, "getRightFooterGroups"));
    table.getFlatHeaders = memo(() => [table.getHeaderGroups()], (headerGroups) => {
      return headerGroups.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getFlatHeaders"));
    table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeftFlatHeaders"));
    table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getCenterFlatHeaders"));
    table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], (left) => {
      return left.map((headerGroup) => {
        return headerGroup.headers;
      }).flat();
    }, getMemoOptions(table.options, debug, "getRightFlatHeaders"));
    table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders;
        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);
      });
    }, getMemoOptions(table.options, debug, "getCenterLeafHeaders"));
    table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders2;
        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);
      });
    }, getMemoOptions(table.options, debug, "getLeftLeafHeaders"));
    table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], (flatHeaders) => {
      return flatHeaders.filter((header) => {
        var _header$subHeaders3;
        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);
      });
    }, getMemoOptions(table.options, debug, "getRightLeafHeaders"));
    table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {
      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;
      return [...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [], ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [], ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []].map((header) => {
        return header.getLeafHeaders();
      }).flat();
    }, getMemoOptions(table.options, debug, "getLeafHeaders"));
  }
};
function buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {
  var _headerGroups$0$heade, _headerGroups$;
  let maxDepth = 0;
  const findMaxDepth = function(columns, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    maxDepth = Math.max(maxDepth, depth);
    columns.filter((column) => column.getIsVisible()).forEach((column) => {
      var _column$columns;
      if ((_column$columns = column.columns) != null && _column$columns.length) {
        findMaxDepth(column.columns, depth + 1);
      }
    }, 0);
  };
  findMaxDepth(allColumns);
  let headerGroups = [];
  const createHeaderGroup = (headersToGroup, depth) => {
    const headerGroup = {
      depth,
      id: [headerFamily, `${depth}`].filter(Boolean).join("_"),
      headers: []
    };
    const pendingParentHeaders = [];
    headersToGroup.forEach((headerToGroup) => {
      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];
      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;
      let column;
      let isPlaceholder = false;
      if (isLeafHeader && headerToGroup.column.parent) {
        column = headerToGroup.column.parent;
      } else {
        column = headerToGroup.column;
        isPlaceholder = true;
      }
      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {
        latestPendingParentHeader.subHeaders.push(headerToGroup);
      } else {
        const header = createHeader(table, column, {
          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join("_"),
          isPlaceholder,
          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d) => d.column === column).length}` : void 0,
          depth,
          index: pendingParentHeaders.length
        });
        header.subHeaders.push(headerToGroup);
        pendingParentHeaders.push(header);
      }
      headerGroup.headers.push(headerToGroup);
      headerToGroup.headerGroup = headerGroup;
    });
    headerGroups.push(headerGroup);
    if (depth > 0) {
      createHeaderGroup(pendingParentHeaders, depth - 1);
    }
  };
  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(table, column, {
    depth: maxDepth,
    index
  }));
  createHeaderGroup(bottomHeaders, maxDepth - 1);
  headerGroups.reverse();
  const recurseHeadersForSpans = (headers) => {
    const filteredHeaders = headers.filter((header) => header.column.getIsVisible());
    return filteredHeaders.map((header) => {
      let colSpan = 0;
      let rowSpan = 0;
      let childRowSpans = [0];
      if (header.subHeaders && header.subHeaders.length) {
        childRowSpans = [];
        recurseHeadersForSpans(header.subHeaders).forEach((_ref) => {
          let {
            colSpan: childColSpan,
            rowSpan: childRowSpan
          } = _ref;
          colSpan += childColSpan;
          childRowSpans.push(childRowSpan);
        });
      } else {
        colSpan = 1;
      }
      const minChildRowSpan = Math.min(...childRowSpans);
      rowSpan = rowSpan + minChildRowSpan;
      header.colSpan = colSpan;
      header.rowSpan = rowSpan;
      return {
        colSpan,
        rowSpan
      };
    });
  };
  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);
  return headerGroups;
}
var defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
};
var getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: false,
  columnSizingStart: []
});
var ColumnSizing = {
  getDefaultColumnDef: () => {
    return defaultColumnSizing;
  },
  getInitialState: (state) => {
    return {
      columnSizing: {},
      columnSizingInfo: getDefaultColumnSizingInfoState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      columnResizeMode: "onEnd",
      columnResizeDirection: "ltr",
      onColumnSizingChange: makeStateUpdater("columnSizing", table),
      onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", table)
    };
  },
  createColumn: (column, table) => {
    column.getSize = () => {
      var _column$columnDef$min, _ref, _column$columnDef$max;
      const columnSize = table.getState().columnSizing[column.id];
      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);
    };
    column.getStart = memo((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(0, column.getIndex(position)).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getStart"));
    column.getAfter = memo((position) => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(column.getIndex(position) + 1).reduce((sum2, column2) => sum2 + column2.getSize(), 0), getMemoOptions(table.options, "debugColumns", "getAfter"));
    column.resetSize = () => {
      table.setColumnSizing((_ref2) => {
        let {
          [column.id]: _,
          ...rest
        } = _ref2;
        return rest;
      });
    };
    column.getCanResize = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);
    };
    column.getIsResizing = () => {
      return table.getState().columnSizingInfo.isResizingColumn === column.id;
    };
  },
  createHeader: (header, table) => {
    header.getSize = () => {
      let sum2 = 0;
      const recurse = (header2) => {
        if (header2.subHeaders.length) {
          header2.subHeaders.forEach(recurse);
        } else {
          var _header$column$getSiz;
          sum2 += (_header$column$getSiz = header2.column.getSize()) != null ? _header$column$getSiz : 0;
        }
      };
      recurse(header);
      return sum2;
    };
    header.getStart = () => {
      if (header.index > 0) {
        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];
        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();
      }
      return 0;
    };
    header.getResizeHandler = (_contextDocument) => {
      const column = table.getColumn(header.column.id);
      const canResize = column == null ? void 0 : column.getCanResize();
      return (e) => {
        if (!column || !canResize) {
          return;
        }
        e.persist == null || e.persist();
        if (isTouchStartEvent(e)) {
          if (e.touches && e.touches.length > 1) {
            return;
          }
        }
        const startSize = header.getSize();
        const columnSizingStart = header ? header.getLeafHeaders().map((d) => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];
        const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;
        const newColumnSizing = {};
        const updateOffset = (eventType, clientXPos) => {
          if (typeof clientXPos !== "number") {
            return;
          }
          table.setColumnSizingInfo((old) => {
            var _old$startOffset, _old$startSize;
            const deltaDirection = table.options.columnResizeDirection === "rtl" ? -1 : 1;
            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;
            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);
            old.columnSizingStart.forEach((_ref3) => {
              let [columnId, headerSize] = _ref3;
              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;
            });
            return {
              ...old,
              deltaOffset,
              deltaPercentage
            };
          });
          if (table.options.columnResizeMode === "onChange" || eventType === "end") {
            table.setColumnSizing((old) => ({
              ...old,
              ...newColumnSizing
            }));
          }
        };
        const onMove = (clientXPos) => updateOffset("move", clientXPos);
        const onEnd = (clientXPos) => {
          updateOffset("end", clientXPos);
          table.setColumnSizingInfo((old) => ({
            ...old,
            isResizingColumn: false,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        };
        const contextDocument = _contextDocument || typeof document !== "undefined" ? document : null;
        const mouseEvents = {
          moveHandler: (e2) => onMove(e2.clientX),
          upHandler: (e2) => {
            contextDocument == null || contextDocument.removeEventListener("mousemove", mouseEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("mouseup", mouseEvents.upHandler);
            onEnd(e2.clientX);
          }
        };
        const touchEvents = {
          moveHandler: (e2) => {
            if (e2.cancelable) {
              e2.preventDefault();
              e2.stopPropagation();
            }
            onMove(e2.touches[0].clientX);
            return false;
          },
          upHandler: (e2) => {
            var _e$touches$;
            contextDocument == null || contextDocument.removeEventListener("touchmove", touchEvents.moveHandler);
            contextDocument == null || contextDocument.removeEventListener("touchend", touchEvents.upHandler);
            if (e2.cancelable) {
              e2.preventDefault();
              e2.stopPropagation();
            }
            onEnd((_e$touches$ = e2.touches[0]) == null ? void 0 : _e$touches$.clientX);
          }
        };
        const passiveIfSupported = passiveEventSupported() ? {
          passive: false
        } : false;
        if (isTouchStartEvent(e)) {
          contextDocument == null || contextDocument.addEventListener("touchmove", touchEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("touchend", touchEvents.upHandler, passiveIfSupported);
        } else {
          contextDocument == null || contextDocument.addEventListener("mousemove", mouseEvents.moveHandler, passiveIfSupported);
          contextDocument == null || contextDocument.addEventListener("mouseup", mouseEvents.upHandler, passiveIfSupported);
        }
        table.setColumnSizingInfo((old) => ({
          ...old,
          startOffset: clientX,
          startSize,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart,
          isResizingColumn: column.id
        }));
      };
    };
  },
  createTable: (table) => {
    table.setColumnSizing = (updater) => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);
    table.setColumnSizingInfo = (updater) => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);
    table.resetColumnSizing = (defaultState) => {
      var _table$initialState$c;
      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});
    };
    table.resetHeaderSizeInfo = (defaultState) => {
      var _table$initialState$c2;
      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());
    };
    table.getTotalSize = () => {
      var _table$getHeaderGroup, _table$getHeaderGroup2;
      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getHeaderGroup : 0;
    };
    table.getLeftTotalSize = () => {
      var _table$getLeftHeaderG, _table$getLeftHeaderG2;
      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getLeftHeaderG : 0;
    };
    table.getCenterTotalSize = () => {
      var _table$getCenterHeade, _table$getCenterHeade2;
      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getCenterHeade : 0;
    };
    table.getRightTotalSize = () => {
      var _table$getRightHeader, _table$getRightHeader2;
      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum2, header) => {
        return sum2 + header.getSize();
      }, 0)) != null ? _table$getRightHeader : 0;
    };
  }
};
var passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported === "boolean")
    return passiveSupported;
  let supported = false;
  try {
    const options = {
      get passive() {
        supported = true;
        return false;
      }
    };
    const noop = () => {
    };
    window.addEventListener("test", noop, options);
    window.removeEventListener("test", noop);
  } catch (err) {
    supported = false;
  }
  passiveSupported = supported;
  return passiveSupported;
}
function isTouchStartEvent(e) {
  return e.type === "touchstart";
}
var Expanding = {
  getInitialState: (state) => {
    return {
      expanded: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onExpandedChange: makeStateUpdater("expanded", table),
      paginateExpandedRows: true
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetExpanded = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {
        if (queued)
          return;
        queued = true;
        table._queue(() => {
          table.resetExpanded();
          queued = false;
        });
      }
    };
    table.setExpanded = (updater) => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);
    table.toggleAllRowsExpanded = (expanded) => {
      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {
        table.setExpanded(true);
      } else {
        table.setExpanded({});
      }
    };
    table.resetExpanded = (defaultState) => {
      var _table$initialState$e, _table$initialState;
      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});
    };
    table.getCanSomeRowsExpand = () => {
      return table.getPrePaginationRowModel().flatRows.some((row) => row.getCanExpand());
    };
    table.getToggleAllRowsExpandedHandler = () => {
      return (e) => {
        e.persist == null || e.persist();
        table.toggleAllRowsExpanded();
      };
    };
    table.getIsSomeRowsExpanded = () => {
      const expanded = table.getState().expanded;
      return expanded === true || Object.values(expanded).some(Boolean);
    };
    table.getIsAllRowsExpanded = () => {
      const expanded = table.getState().expanded;
      if (typeof expanded === "boolean") {
        return expanded === true;
      }
      if (!Object.keys(expanded).length) {
        return false;
      }
      if (table.getRowModel().flatRows.some((row) => !row.getIsExpanded())) {
        return false;
      }
      return true;
    };
    table.getExpandedDepth = () => {
      let maxDepth = 0;
      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);
      rowIds.forEach((id) => {
        const splitId = id.split(".");
        maxDepth = Math.max(maxDepth, splitId.length);
      });
      return maxDepth;
    };
    table.getPreExpandedRowModel = () => table.getSortedRowModel();
    table.getExpandedRowModel = () => {
      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {
        table._getExpandedRowModel = table.options.getExpandedRowModel(table);
      }
      if (table.options.manualExpanding || !table._getExpandedRowModel) {
        return table.getPreExpandedRowModel();
      }
      return table._getExpandedRowModel();
    };
  },
  createRow: (row, table) => {
    row.toggleExpanded = (expanded) => {
      table.setExpanded((old) => {
        var _expanded;
        const exists = old === true ? true : !!(old != null && old[row.id]);
        let oldExpanded = {};
        if (old === true) {
          Object.keys(table.getRowModel().rowsById).forEach((rowId) => {
            oldExpanded[rowId] = true;
          });
        } else {
          oldExpanded = old;
        }
        expanded = (_expanded = expanded) != null ? _expanded : !exists;
        if (!exists && expanded) {
          return {
            ...oldExpanded,
            [row.id]: true
          };
        }
        if (exists && !expanded) {
          const {
            [row.id]: _,
            ...rest
          } = oldExpanded;
          return rest;
        }
        return old;
      });
    };
    row.getIsExpanded = () => {
      var _table$options$getIsR;
      const expanded = table.getState().expanded;
      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));
    };
    row.getCanExpand = () => {
      var _table$options$getRow, _table$options$enable, _row$subRows;
      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
    row.getIsAllParentsExpanded = () => {
      let isFullyExpanded = true;
      let currentRow = row;
      while (isFullyExpanded && currentRow.parentId) {
        currentRow = table.getRow(currentRow.parentId, true);
        isFullyExpanded = currentRow.getIsExpanded();
      }
      return isFullyExpanded;
    };
    row.getToggleExpandedHandler = () => {
      const canExpand = row.getCanExpand();
      return () => {
        if (!canExpand)
          return;
        row.toggleExpanded();
      };
    };
  }
};
var includesString = (row, columnId, filterValue) => {
  var _row$getValue;
  const search = filterValue.toLowerCase();
  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));
};
includesString.autoRemove = (val) => testFalsey(val);
var includesStringSensitive = (row, columnId, filterValue) => {
  var _row$getValue2;
  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));
};
includesStringSensitive.autoRemove = (val) => testFalsey(val);
var equalsString = (row, columnId, filterValue) => {
  var _row$getValue3;
  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());
};
equalsString.autoRemove = (val) => testFalsey(val);
var arrIncludes = (row, columnId, filterValue) => {
  var _row$getValue4;
  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);
};
arrIncludes.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesAll = (row, columnId, filterValue) => {
  return !filterValue.some((val) => {
    var _row$getValue5;
    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));
  });
};
arrIncludesAll.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var arrIncludesSome = (row, columnId, filterValue) => {
  return filterValue.some((val) => {
    var _row$getValue6;
    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);
  });
};
arrIncludesSome.autoRemove = (val) => testFalsey(val) || !(val != null && val.length);
var equals = (row, columnId, filterValue) => {
  return row.getValue(columnId) === filterValue;
};
equals.autoRemove = (val) => testFalsey(val);
var weakEquals = (row, columnId, filterValue) => {
  return row.getValue(columnId) == filterValue;
};
weakEquals.autoRemove = (val) => testFalsey(val);
var inNumberRange = (row, columnId, filterValue) => {
  let [min2, max2] = filterValue;
  const rowValue = row.getValue(columnId);
  return rowValue >= min2 && rowValue <= max2;
};
inNumberRange.resolveFilterValue = (val) => {
  let [unsafeMin, unsafeMax] = val;
  let parsedMin = typeof unsafeMin !== "number" ? parseFloat(unsafeMin) : unsafeMin;
  let parsedMax = typeof unsafeMax !== "number" ? parseFloat(unsafeMax) : unsafeMax;
  let min2 = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;
  let max2 = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;
  if (min2 > max2) {
    const temp = min2;
    min2 = max2;
    max2 = temp;
  }
  return [min2, max2];
};
inNumberRange.autoRemove = (val) => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);
var filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
function testFalsey(val) {
  return val === void 0 || val === null || val === "";
}
var Filters = {
  getDefaultColumnDef: () => {
    return {
      filterFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      columnFilters: [],
      globalFilter: void 0,
      // filtersProgress: 1,
      // facetProgress: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnFiltersChange: makeStateUpdater("columnFilters", table),
      onGlobalFilterChange: makeStateUpdater("globalFilter", table),
      filterFromLeafRows: false,
      maxLeafRowFilterDepth: 100,
      globalFilterFn: "auto",
      getColumnCanGlobalFilter: (column) => {
        var _table$getCoreRowMode;
        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();
        return typeof value === "string" || typeof value === "number";
      }
    };
  },
  createColumn: (column, table) => {
    column.getAutoFilterFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return filterFns.includesString;
      }
      if (typeof value === "number") {
        return filterFns.inNumberRange;
      }
      if (typeof value === "boolean") {
        return filterFns.equals;
      }
      if (value !== null && typeof value === "object") {
        return filterFns.equals;
      }
      if (Array.isArray(value)) {
        return filterFns.arrIncludes;
      }
      return filterFns.weakEquals;
    };
    column.getFilterFn = () => {
      var _table$options$filter, _table$options$filter2;
      return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === "auto" ? column.getAutoFilterFn() : (
        // @ts-ignore
        (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn]
      );
    };
    column.getCanFilter = () => {
      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;
      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;
    };
    column.getCanGlobalFilter = () => {
      var _column$columnDef$ena2, _table$options$enable3, _table$options$enable4, _table$options$getCol;
      return ((_column$columnDef$ena2 = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena2 : true) && ((_table$options$enable3 = table.options.enableGlobalFilter) != null ? _table$options$enable3 : true) && ((_table$options$enable4 = table.options.enableFilters) != null ? _table$options$enable4 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;
    };
    column.getIsFiltered = () => column.getFilterIndex() > -1;
    column.getFilterValue = () => {
      var _table$getState$colum;
      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d) => d.id === column.id)) == null ? void 0 : _table$getState$colum.value;
    };
    column.getFilterIndex = () => {
      var _table$getState$colum2, _table$getState$colum3;
      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d) => d.id === column.id)) != null ? _table$getState$colum2 : -1;
    };
    column.setFilterValue = (value) => {
      table.setColumnFilters((old) => {
        const filterFn = column.getFilterFn();
        const previousfilter = old == null ? void 0 : old.find((d) => d.id === column.id);
        const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : void 0);
        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {
          var _old$filter;
          return (_old$filter = old == null ? void 0 : old.filter((d) => d.id !== column.id)) != null ? _old$filter : [];
        }
        const newFilterObj = {
          id: column.id,
          value: newFilter
        };
        if (previousfilter) {
          var _old$map;
          return (_old$map = old == null ? void 0 : old.map((d) => {
            if (d.id === column.id) {
              return newFilterObj;
            }
            return d;
          })) != null ? _old$map : [];
        }
        if (old != null && old.length) {
          return [...old, newFilterObj];
        }
        return [newFilterObj];
      });
    };
    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);
    column.getFacetedRowModel = () => {
      if (!column._getFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return column._getFacetedRowModel();
    };
    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);
    column.getFacetedUniqueValues = () => {
      if (!column._getFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return column._getFacetedUniqueValues();
    };
    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);
    column.getFacetedMinMaxValues = () => {
      if (!column._getFacetedMinMaxValues) {
        return void 0;
      }
      return column._getFacetedMinMaxValues();
    };
  },
  createRow: (row, table) => {
    row.columnFilters = {};
    row.columnFiltersMeta = {};
  },
  createTable: (table) => {
    table.getGlobalAutoFilterFn = () => {
      return filterFns.includesString;
    };
    table.getGlobalFilterFn = () => {
      var _table$options$filter3, _table$options$filter4;
      const {
        globalFilterFn
      } = table.options;
      return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === "auto" ? table.getGlobalAutoFilterFn() : (
        // @ts-ignore
        (_table$options$filter3 = (_table$options$filter4 = table.options.filterFns) == null ? void 0 : _table$options$filter4[globalFilterFn]) != null ? _table$options$filter3 : filterFns[globalFilterFn]
      );
    };
    table.setColumnFilters = (updater) => {
      const leafColumns = table.getAllLeafColumns();
      const updateFn = (old) => {
        var _functionalUpdate;
        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter) => {
          const column = leafColumns.find((d) => d.id === filter.id);
          if (column) {
            const filterFn = column.getFilterFn();
            if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {
              return false;
            }
          }
          return true;
        });
      };
      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);
    };
    table.setGlobalFilter = (updater) => {
      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);
    };
    table.resetGlobalFilter = (defaultState) => {
      table.setGlobalFilter(defaultState ? void 0 : table.initialState.globalFilter);
    };
    table.resetColumnFilters = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);
    };
    table.getPreFilteredRowModel = () => table.getCoreRowModel();
    table.getFilteredRowModel = () => {
      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {
        table._getFilteredRowModel = table.options.getFilteredRowModel(table);
      }
      if (table.options.manualFiltering || !table._getFilteredRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getFilteredRowModel();
    };
    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, "__global__");
    table.getGlobalFacetedRowModel = () => {
      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {
        return table.getPreFilteredRowModel();
      }
      return table._getGlobalFacetedRowModel();
    };
    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, "__global__");
    table.getGlobalFacetedUniqueValues = () => {
      if (!table._getGlobalFacetedUniqueValues) {
        return /* @__PURE__ */ new Map();
      }
      return table._getGlobalFacetedUniqueValues();
    };
    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, "__global__");
    table.getGlobalFacetedMinMaxValues = () => {
      if (!table._getGlobalFacetedMinMaxValues) {
        return;
      }
      return table._getGlobalFacetedMinMaxValues();
    };
  }
};
function shouldAutoRemoveFilter(filterFn, value, column) {
  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === "undefined" || typeof value === "string" && !value;
}
var sum = (columnId, _leafRows, childRows) => {
  return childRows.reduce((sum2, next) => {
    const nextValue = next.getValue(columnId);
    return sum2 + (typeof nextValue === "number" ? nextValue : 0);
  }, 0);
};
var min = (columnId, _leafRows, childRows) => {
  let min2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
      min2 = value;
    }
  });
  return min2;
};
var max = (columnId, _leafRows, childRows) => {
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
      max2 = value;
    }
  });
  return max2;
};
var extent = (columnId, _leafRows, childRows) => {
  let min2;
  let max2;
  childRows.forEach((row) => {
    const value = row.getValue(columnId);
    if (value != null) {
      if (min2 === void 0) {
        if (value >= value)
          min2 = max2 = value;
      } else {
        if (min2 > value)
          min2 = value;
        if (max2 < value)
          max2 = value;
      }
    }
  });
  return [min2, max2];
};
var mean = (columnId, leafRows) => {
  let count2 = 0;
  let sum2 = 0;
  leafRows.forEach((row) => {
    let value = row.getValue(columnId);
    if (value != null && (value = +value) >= value) {
      ++count2, sum2 += value;
    }
  });
  if (count2)
    return sum2 / count2;
  return;
};
var median = (columnId, leafRows) => {
  if (!leafRows.length) {
    return;
  }
  const values = leafRows.map((row) => row.getValue(columnId));
  if (!isNumberArray(values)) {
    return;
  }
  if (values.length === 1) {
    return values[0];
  }
  const mid = Math.floor(values.length / 2);
  const nums = values.sort((a, b) => a - b);
  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;
};
var unique = (columnId, leafRows) => {
  return Array.from(new Set(leafRows.map((d) => d.getValue(columnId))).values());
};
var uniqueCount = (columnId, leafRows) => {
  return new Set(leafRows.map((d) => d.getValue(columnId))).size;
};
var count = (_columnId, leafRows) => {
  return leafRows.length;
};
var aggregationFns = {
  sum,
  min,
  max,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count
};
var Grouping = {
  getDefaultColumnDef: () => {
    return {
      aggregatedCell: (props) => {
        var _toString, _props$getValue;
        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;
      },
      aggregationFn: "auto"
    };
  },
  getInitialState: (state) => {
    return {
      grouping: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onGroupingChange: makeStateUpdater("grouping", table),
      groupedColumnMode: "reorder"
    };
  },
  createColumn: (column, table) => {
    column.toggleGrouping = () => {
      table.setGrouping((old) => {
        if (old != null && old.includes(column.id)) {
          return old.filter((d) => d !== column.id);
        }
        return [...old != null ? old : [], column.id];
      });
    };
    column.getCanGroup = () => {
      var _ref, _ref2, _ref3, _column$columnDef$ena;
      return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : table.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;
    };
    column.getIsGrouped = () => {
      var _table$getState$group;
      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);
    };
    column.getGroupedIndex = () => {
      var _table$getState$group2;
      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);
    };
    column.getToggleGroupingHandler = () => {
      const canGroup = column.getCanGroup();
      return () => {
        if (!canGroup)
          return;
        column.toggleGrouping();
      };
    };
    column.getAutoAggregationFn = () => {
      const firstRow = table.getCoreRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "number") {
        return aggregationFns.sum;
      }
      if (Object.prototype.toString.call(value) === "[object Date]") {
        return aggregationFns.extent;
      }
    };
    column.getAggregationFn = () => {
      var _table$options$aggreg, _table$options$aggreg2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === "auto" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];
    };
  },
  createTable: (table) => {
    table.setGrouping = (updater) => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);
    table.resetGrouping = (defaultState) => {
      var _table$initialState$g, _table$initialState;
      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);
    };
    table.getPreGroupedRowModel = () => table.getFilteredRowModel();
    table.getGroupedRowModel = () => {
      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {
        table._getGroupedRowModel = table.options.getGroupedRowModel(table);
      }
      if (table.options.manualGrouping || !table._getGroupedRowModel) {
        return table.getPreGroupedRowModel();
      }
      return table._getGroupedRowModel();
    };
  },
  createRow: (row, table) => {
    row.getIsGrouped = () => !!row.groupingColumnId;
    row.getGroupingValue = (columnId) => {
      if (row._groupingValuesCache.hasOwnProperty(columnId)) {
        return row._groupingValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.columnDef.getGroupingValue)) {
        return row.getValue(columnId);
      }
      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);
      return row._groupingValuesCache[columnId];
    };
    row._groupingValuesCache = {};
  },
  createCell: (cell, column, row, table) => {
    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;
    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();
    cell.getIsAggregated = () => {
      var _row$subRows;
      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);
    };
  }
};
function orderColumns(leafColumns, grouping, groupedColumnMode) {
  if (!(grouping != null && grouping.length) || !groupedColumnMode) {
    return leafColumns;
  }
  const nonGroupingColumns = leafColumns.filter((col) => !grouping.includes(col.id));
  if (groupedColumnMode === "remove") {
    return nonGroupingColumns;
  }
  const groupingColumns = grouping.map((g) => leafColumns.find((col) => col.id === g)).filter(Boolean);
  return [...groupingColumns, ...nonGroupingColumns];
}
var Ordering = {
  getInitialState: (state) => {
    return {
      columnOrder: [],
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnOrderChange: makeStateUpdater("columnOrder", table)
    };
  },
  createColumn: (column, table) => {
    column.getIndex = memo((position) => [_getVisibleLeafColumns(table, position)], (columns) => columns.findIndex((d) => d.id === column.id), getMemoOptions(table.options, "debugColumns", "getIndex"));
    column.getIsFirstColumn = (position) => {
      var _columns$;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;
    };
    column.getIsLastColumn = (position) => {
      var _columns;
      const columns = _getVisibleLeafColumns(table, position);
      return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;
    };
  },
  createTable: (table) => {
    table.setColumnOrder = (updater) => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);
    table.resetColumnOrder = (defaultState) => {
      var _table$initialState$c;
      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);
    };
    table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => (columns) => {
      let orderedColumns = [];
      if (!(columnOrder != null && columnOrder.length)) {
        orderedColumns = columns;
      } else {
        const columnOrderCopy = [...columnOrder];
        const columnsCopy = [...columns];
        while (columnsCopy.length && columnOrderCopy.length) {
          const targetColumnId = columnOrderCopy.shift();
          const foundIndex = columnsCopy.findIndex((d) => d.id === targetColumnId);
          if (foundIndex > -1) {
            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);
          }
        }
        orderedColumns = [...orderedColumns, ...columnsCopy];
      }
      return orderColumns(orderedColumns, grouping, groupedColumnMode);
    }, getMemoOptions(table.options, "debugTable", "_getOrderColumnsFn"));
  }
};
var defaultPageIndex = 0;
var defaultPageSize = 10;
var getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
});
var Pagination = {
  getInitialState: (state) => {
    return {
      ...state,
      pagination: {
        ...getDefaultPaginationState(),
        ...state == null ? void 0 : state.pagination
      }
    };
  },
  getDefaultOptions: (table) => {
    return {
      onPaginationChange: makeStateUpdater("pagination", table)
    };
  },
  createTable: (table) => {
    let registered = false;
    let queued = false;
    table._autoResetPageIndex = () => {
      var _ref, _table$options$autoRe;
      if (!registered) {
        table._queue(() => {
          registered = true;
        });
        return;
      }
      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {
        if (queued)
          return;
        queued = true;
        table._queue(() => {
          table.resetPageIndex();
          queued = false;
        });
      }
    };
    table.setPagination = (updater) => {
      const safeUpdater = (old) => {
        let newState = functionalUpdate(updater, old);
        return newState;
      };
      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);
    };
    table.resetPagination = (defaultState) => {
      var _table$initialState$p;
      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());
    };
    table.setPageIndex = (updater) => {
      table.setPagination((old) => {
        let pageIndex = functionalUpdate(updater, old.pageIndex);
        const maxPageIndex = typeof table.options.pageCount === "undefined" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;
        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));
        return {
          ...old,
          pageIndex
        };
      });
    };
    table.resetPageIndex = (defaultState) => {
      var _table$initialState$p2, _table$initialState;
      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);
    };
    table.resetPageSize = (defaultState) => {
      var _table$initialState$p3, _table$initialState2;
      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);
    };
    table.setPageSize = (updater) => {
      table.setPagination((old) => {
        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));
        const topRowIndex = old.pageSize * old.pageIndex;
        const pageIndex = Math.floor(topRowIndex / pageSize);
        return {
          ...old,
          pageIndex,
          pageSize
        };
      });
    };
    table.setPageCount = (updater) => table.setPagination((old) => {
      var _table$options$pageCo;
      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);
      if (typeof newPageCount === "number") {
        newPageCount = Math.max(-1, newPageCount);
      }
      return {
        ...old,
        pageCount: newPageCount
      };
    });
    table.getPageOptions = memo(() => [table.getPageCount()], (pageCount) => {
      let pageOptions = [];
      if (pageCount && pageCount > 0) {
        pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);
      }
      return pageOptions;
    }, getMemoOptions(table.options, "debugTable", "getPageOptions"));
    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;
    table.getCanNextPage = () => {
      const {
        pageIndex
      } = table.getState().pagination;
      const pageCount = table.getPageCount();
      if (pageCount === -1) {
        return true;
      }
      if (pageCount === 0) {
        return false;
      }
      return pageIndex < pageCount - 1;
    };
    table.previousPage = () => {
      return table.setPageIndex((old) => old - 1);
    };
    table.nextPage = () => {
      return table.setPageIndex((old) => {
        return old + 1;
      });
    };
    table.getPrePaginationRowModel = () => table.getExpandedRowModel();
    table.getPaginationRowModel = () => {
      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {
        table._getPaginationRowModel = table.options.getPaginationRowModel(table);
      }
      if (table.options.manualPagination || !table._getPaginationRowModel) {
        return table.getPrePaginationRowModel();
      }
      return table._getPaginationRowModel();
    };
    table.getPageCount = () => {
      var _table$options$pageCo2;
      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getPrePaginationRowModel().rows.length / table.getState().pagination.pageSize);
    };
  }
};
var getDefaultColumnPinningState = () => ({
  left: [],
  right: []
});
var getDefaultRowPinningState = () => ({
  top: [],
  bottom: []
});
var Pinning = {
  getInitialState: (state) => {
    return {
      columnPinning: getDefaultColumnPinningState(),
      rowPinning: getDefaultRowPinningState(),
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnPinningChange: makeStateUpdater("columnPinning", table),
      onRowPinningChange: makeStateUpdater("rowPinning", table)
    };
  },
  createColumn: (column, table) => {
    column.pin = (position) => {
      const columnIds = column.getLeafColumns().map((d) => d.id).filter(Boolean);
      table.setColumnPinning((old) => {
        var _old$left3, _old$right3;
        if (position === "right") {
          var _old$left, _old$right;
          return {
            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds]
          };
        }
        if (position === "left") {
          var _old$left2, _old$right2;
          return {
            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d) => !(columnIds != null && columnIds.includes(d))), ...columnIds],
            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
          };
        }
        return {
          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d) => !(columnIds != null && columnIds.includes(d))),
          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d) => !(columnIds != null && columnIds.includes(d)))
        };
      });
    };
    column.getCanPin = () => {
      const leafColumns = column.getLeafColumns();
      return leafColumns.some((d) => {
        var _d$columnDef$enablePi, _ref, _table$options$enable;
        return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);
      });
    };
    column.getIsPinned = () => {
      const leafColumnIds = column.getLeafColumns().map((d) => d.id);
      const {
        left,
        right
      } = table.getState().columnPinning;
      const isLeft = leafColumnIds.some((d) => left == null ? void 0 : left.includes(d));
      const isRight = leafColumnIds.some((d) => right == null ? void 0 : right.includes(d));
      return isLeft ? "left" : isRight ? "right" : false;
    };
    column.getPinnedIndex = () => {
      var _table$getState$colum, _table$getState$colum2;
      const position = column.getIsPinned();
      return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;
    };
  },
  createRow: (row, table) => {
    row.pin = (position, includeLeafRows, includeParentRows) => {
      const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref2) => {
        let {
          id
        } = _ref2;
        return id;
      }) : [];
      const parentRowIds = includeParentRows ? row.getParentRows().map((_ref3) => {
        let {
          id
        } = _ref3;
        return id;
      }) : [];
      const rowIds = /* @__PURE__ */ new Set([...parentRowIds, row.id, ...leafRowIds]);
      table.setRowPinning((old) => {
        var _old$top3, _old$bottom3;
        if (position === "bottom") {
          var _old$top, _old$bottom;
          return {
            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d) => !(rowIds != null && rowIds.has(d))),
            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d) => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)]
          };
        }
        if (position === "top") {
          var _old$top2, _old$bottom2;
          return {
            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d) => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)],
            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d) => !(rowIds != null && rowIds.has(d)))
          };
        }
        return {
          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d) => !(rowIds != null && rowIds.has(d))),
          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d) => !(rowIds != null && rowIds.has(d)))
        };
      });
    };
    row.getCanPin = () => {
      var _ref4;
      const {
        enableRowPinning,
        enablePinning
      } = table.options;
      if (typeof enableRowPinning === "function") {
        return enableRowPinning(row);
      }
      return (_ref4 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref4 : true;
    };
    row.getIsPinned = () => {
      const rowIds = [row.id];
      const {
        top,
        bottom
      } = table.getState().rowPinning;
      const isTop = rowIds.some((d) => top == null ? void 0 : top.includes(d));
      const isBottom = rowIds.some((d) => bottom == null ? void 0 : bottom.includes(d));
      return isTop ? "top" : isBottom ? "bottom" : false;
    };
    row.getPinnedIndex = () => {
      var _table$_getPinnedRows, _visiblePinnedRowIds$;
      const position = row.getIsPinned();
      if (!position)
        return -1;
      const visiblePinnedRowIds = (_table$_getPinnedRows = table._getPinnedRows(position)) == null ? void 0 : _table$_getPinnedRows.map((_ref5) => {
        let {
          id
        } = _ref5;
        return id;
      });
      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;
    };
    row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allCells.filter((d) => !leftAndRight.includes(d.column.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterVisibleCells"));
    row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, ,], (allCells, left) => {
      const cells = (left != null ? left : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
        ...d,
        position: "left"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getLeftVisibleCells"));
    row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {
      const cells = (right != null ? right : []).map((columnId) => allCells.find((cell) => cell.column.id === columnId)).filter(Boolean).map((d) => ({
        ...d,
        position: "right"
      }));
      return cells;
    }, getMemoOptions(table.options, "debugRows", "getRightVisibleCells"));
  },
  createTable: (table) => {
    table.setColumnPinning = (updater) => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);
    table.resetColumnPinning = (defaultState) => {
      var _table$initialState$c, _table$initialState;
      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());
    };
    table.getIsSomeColumnsPinned = (position) => {
      var _pinningState$positio;
      const pinningState = table.getState().columnPinning;
      if (!position) {
        var _pinningState$left, _pinningState$right;
        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));
      }
      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);
    };
    table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {
      return (left != null ? left : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getLeftLeafColumns"));
    table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {
      return (right != null ? right : []).map((columnId) => allColumns.find((column) => column.id === columnId)).filter(Boolean);
    }, getMemoOptions(table.options, "debugColumns", "getRightLeafColumns"));
    table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {
      const leftAndRight = [...left != null ? left : [], ...right != null ? right : []];
      return allColumns.filter((d) => !leftAndRight.includes(d.id));
    }, getMemoOptions(table.options, "debugColumns", "getCenterLeafColumns"));
    table.setRowPinning = (updater) => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);
    table.resetRowPinning = (defaultState) => {
      var _table$initialState$r, _table$initialState2;
      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState2 = table.initialState) == null ? void 0 : _table$initialState2.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());
    };
    table.getIsSomeRowsPinned = (position) => {
      var _pinningState$positio2;
      const pinningState = table.getState().rowPinning;
      if (!position) {
        var _pinningState$top, _pinningState$bottom;
        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));
      }
      return Boolean((_pinningState$positio2 = pinningState[position]) == null ? void 0 : _pinningState$positio2.length);
    };
    table._getPinnedRows = memo((position) => [table.getRowModel().rows, table.getState().rowPinning[position], position], (visibleRows, pinnedRowIds, position) => {
      var _table$options$keepPi;
      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => {
          const row = table.getRow(rowId, true);
          return row.getIsAllParentsExpanded() ? row : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (pinnedRowIds != null ? pinnedRowIds : []).map((rowId) => visibleRows.find((row) => row.id === rowId))
      );
      return rows.filter(Boolean).map((d) => ({
        ...d,
        position
      }));
    }, getMemoOptions(table.options, "debugRows", "_getPinnedRows"));
    table.getTopRows = () => table._getPinnedRows("top");
    table.getBottomRows = () => table._getPinnedRows("bottom");
    table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {
      const topAndBottom = /* @__PURE__ */ new Set([...top != null ? top : [], ...bottom != null ? bottom : []]);
      return allRows.filter((d) => !topAndBottom.has(d.id));
    }, getMemoOptions(table.options, "debugRows", "getCenterRows"));
  }
};
var RowSelection = {
  getInitialState: (state) => {
    return {
      rowSelection: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onRowSelectionChange: makeStateUpdater("rowSelection", table),
      enableRowSelection: true,
      enableMultiRowSelection: true,
      enableSubRowSelection: true
      // enableGroupingRowSelection: false,
      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
    };
  },
  createTable: (table) => {
    table.setRowSelection = (updater) => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);
    table.resetRowSelection = (defaultState) => {
      var _table$initialState$r;
      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});
    };
    table.toggleAllRowsSelected = (value) => {
      table.setRowSelection((old) => {
        value = typeof value !== "undefined" ? value : !table.getIsAllRowsSelected();
        const rowSelection = {
          ...old
        };
        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;
        if (value) {
          preGroupedFlatRows.forEach((row) => {
            if (!row.getCanSelect()) {
              return;
            }
            rowSelection[row.id] = true;
          });
        } else {
          preGroupedFlatRows.forEach((row) => {
            delete rowSelection[row.id];
          });
        }
        return rowSelection;
      });
    };
    table.toggleAllPageRowsSelected = (value) => table.setRowSelection((old) => {
      const resolvedValue = typeof value !== "undefined" ? value : !table.getIsAllPageRowsSelected();
      const rowSelection = {
        ...old
      };
      table.getRowModel().rows.forEach((row) => {
        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);
      });
      return rowSelection;
    });
    table.getPreSelectedRowModel = () => table.getCoreRowModel();
    table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getSelectedRowModel"));
    table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getFilteredSelectedRowModel"));
    table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {
      if (!Object.keys(rowSelection).length) {
        return {
          rows: [],
          flatRows: [],
          rowsById: {}
        };
      }
      return selectRowsFn(table, rowModel);
    }, getMemoOptions(table.options, "debugTable", "getGroupedSelectedRowModel"));
    table.getIsAllRowsSelected = () => {
      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;
      const {
        rowSelection
      } = table.getState();
      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);
      if (isAllRowsSelected) {
        if (preGroupedFlatRows.some((row) => row.getCanSelect() && !rowSelection[row.id])) {
          isAllRowsSelected = false;
        }
      }
      return isAllRowsSelected;
    };
    table.getIsAllPageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row) => row.getCanSelect());
      const {
        rowSelection
      } = table.getState();
      let isAllPageRowsSelected = !!paginationFlatRows.length;
      if (isAllPageRowsSelected && paginationFlatRows.some((row) => !rowSelection[row.id])) {
        isAllPageRowsSelected = false;
      }
      return isAllPageRowsSelected;
    };
    table.getIsSomeRowsSelected = () => {
      var _table$getState$rowSe;
      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;
      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;
    };
    table.getIsSomePageRowsSelected = () => {
      const paginationFlatRows = table.getPaginationRowModel().flatRows;
      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row) => row.getCanSelect()).some((d) => d.getIsSelected() || d.getIsSomeSelected());
    };
    table.getToggleAllRowsSelectedHandler = () => {
      return (e) => {
        table.toggleAllRowsSelected(e.target.checked);
      };
    };
    table.getToggleAllPageRowsSelectedHandler = () => {
      return (e) => {
        table.toggleAllPageRowsSelected(e.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row.toggleSelected = (value, opts) => {
      const isSelected = row.getIsSelected();
      table.setRowSelection((old) => {
        var _opts$selectChildren;
        value = typeof value !== "undefined" ? value : !isSelected;
        if (row.getCanSelect() && isSelected === value) {
          return old;
        }
        const selectedRowIds = {
          ...old
        };
        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);
        return selectedRowIds;
      });
    };
    row.getIsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isRowSelected(row, rowSelection);
    };
    row.getIsSomeSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "some";
    };
    row.getIsAllSubRowsSelected = () => {
      const {
        rowSelection
      } = table.getState();
      return isSubRowSelected(row, rowSelection) === "all";
    };
    row.getCanSelect = () => {
      var _table$options$enable;
      if (typeof table.options.enableRowSelection === "function") {
        return table.options.enableRowSelection(row);
      }
      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;
    };
    row.getCanSelectSubRows = () => {
      var _table$options$enable2;
      if (typeof table.options.enableSubRowSelection === "function") {
        return table.options.enableSubRowSelection(row);
      }
      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;
    };
    row.getCanMultiSelect = () => {
      var _table$options$enable3;
      if (typeof table.options.enableMultiRowSelection === "function") {
        return table.options.enableMultiRowSelection(row);
      }
      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;
    };
    row.getToggleSelectedHandler = () => {
      const canSelect = row.getCanSelect();
      return (e) => {
        var _target;
        if (!canSelect)
          return;
        row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
var mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table) => {
  var _row$subRows;
  const row = table.getRow(id, true);
  if (value) {
    if (!row.getCanMultiSelect()) {
      Object.keys(selectedRowIds).forEach((key) => delete selectedRowIds[key]);
    }
    if (row.getCanSelect()) {
      selectedRowIds[id] = true;
    }
  } else {
    delete selectedRowIds[id];
  }
  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {
    row.subRows.forEach((row2) => mutateRowIsSelected(selectedRowIds, row2.id, value, includeChildren, table));
  }
};
function selectRowsFn(table, rowModel) {
  const rowSelection = table.getState().rowSelection;
  const newSelectedFlatRows = [];
  const newSelectedRowsById = {};
  const recurseRows = function(rows, depth) {
    return rows.map((row) => {
      var _row$subRows2;
      const isSelected = isRowSelected(row, rowSelection);
      if (isSelected) {
        newSelectedFlatRows.push(row);
        newSelectedRowsById[row.id] = row;
      }
      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {
        row = {
          ...row,
          subRows: recurseRows(row.subRows)
        };
      }
      if (isSelected) {
        return row;
      }
    }).filter(Boolean);
  };
  return {
    rows: recurseRows(rowModel.rows),
    flatRows: newSelectedFlatRows,
    rowsById: newSelectedRowsById
  };
}
function isRowSelected(row, selection) {
  var _selection$row$id;
  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;
}
function isSubRowSelected(row, selection, table) {
  var _row$subRows3;
  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length))
    return false;
  let allChildrenSelected = true;
  let someSelected = false;
  row.subRows.forEach((subRow) => {
    if (someSelected && !allChildrenSelected) {
      return;
    }
    if (subRow.getCanSelect()) {
      if (isRowSelected(subRow, selection)) {
        someSelected = true;
      } else {
        allChildrenSelected = false;
      }
    }
    if (subRow.subRows && subRow.subRows.length) {
      const subRowChildrenSelected = isSubRowSelected(subRow, selection);
      if (subRowChildrenSelected === "all") {
        someSelected = true;
      } else if (subRowChildrenSelected === "some") {
        someSelected = true;
        allChildrenSelected = false;
      } else {
        allChildrenSelected = false;
      }
    }
  });
  return allChildrenSelected ? "all" : someSelected ? "some" : false;
}
var reSplitAlphaNumeric = /([0-9]+)/gm;
var alphanumeric = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var alphanumericCaseSensitive = (rowA, rowB, columnId) => {
  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var text = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());
};
var textCaseSensitive = (rowA, rowB, columnId) => {
  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));
};
var datetime = (rowA, rowB, columnId) => {
  const a = rowA.getValue(columnId);
  const b = rowB.getValue(columnId);
  return a > b ? 1 : a < b ? -1 : 0;
};
var basic = (rowA, rowB, columnId) => {
  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));
};
function compareBasic(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function toString(a) {
  if (typeof a === "number") {
    if (isNaN(a) || a === Infinity || a === -Infinity) {
      return "";
    }
    return String(a);
  }
  if (typeof a === "string") {
    return a;
  }
  return "";
}
function compareAlphanumeric(aStr, bStr) {
  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);
  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);
  while (a.length && b.length) {
    const aa = a.shift();
    const bb = b.shift();
    const an = parseInt(aa, 10);
    const bn = parseInt(bb, 10);
    const combo = [an, bn].sort();
    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }
      if (bb > aa) {
        return -1;
      }
      continue;
    }
    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    }
    if (an > bn) {
      return 1;
    }
    if (bn > an) {
      return -1;
    }
  }
  return a.length - b.length;
}
var sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
};
var Sorting = {
  getInitialState: (state) => {
    return {
      sorting: [],
      ...state
    };
  },
  getDefaultColumnDef: () => {
    return {
      sortingFn: "auto",
      sortUndefined: 1
    };
  },
  getDefaultOptions: (table) => {
    return {
      onSortingChange: makeStateUpdater("sorting", table),
      isMultiSortEvent: (e) => {
        return e.shiftKey;
      }
    };
  },
  createColumn: (column, table) => {
    column.getAutoSortingFn = () => {
      const firstRows = table.getFilteredRowModel().flatRows.slice(10);
      let isString = false;
      for (const row of firstRows) {
        const value = row == null ? void 0 : row.getValue(column.id);
        if (Object.prototype.toString.call(value) === "[object Date]") {
          return sortingFns.datetime;
        }
        if (typeof value === "string") {
          isString = true;
          if (value.split(reSplitAlphaNumeric).length > 1) {
            return sortingFns.alphanumeric;
          }
        }
      }
      if (isString) {
        return sortingFns.text;
      }
      return sortingFns.basic;
    };
    column.getAutoSortDir = () => {
      const firstRow = table.getFilteredRowModel().flatRows[0];
      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);
      if (typeof value === "string") {
        return "asc";
      }
      return "desc";
    };
    column.getSortingFn = () => {
      var _table$options$sortin, _table$options$sortin2;
      if (!column) {
        throw new Error();
      }
      return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === "auto" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];
    };
    column.toggleSorting = (desc, multi) => {
      const nextSortingOrder = column.getNextSortingOrder();
      const hasManualValue = typeof desc !== "undefined" && desc !== null;
      table.setSorting((old) => {
        const existingSorting = old == null ? void 0 : old.find((d) => d.id === column.id);
        const existingIndex = old == null ? void 0 : old.findIndex((d) => d.id === column.id);
        let newSorting = [];
        let sortAction;
        let nextDesc = hasManualValue ? desc : nextSortingOrder === "desc";
        if (old != null && old.length && column.getCanMultiSort() && multi) {
          if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "add";
          }
        } else {
          if (old != null && old.length && existingIndex !== old.length - 1) {
            sortAction = "replace";
          } else if (existingSorting) {
            sortAction = "toggle";
          } else {
            sortAction = "replace";
          }
        }
        if (sortAction === "toggle") {
          if (!hasManualValue) {
            if (!nextSortingOrder) {
              sortAction = "remove";
            }
          }
        }
        if (sortAction === "add") {
          var _table$options$maxMul;
          newSorting = [...old, {
            id: column.id,
            desc: nextDesc
          }];
          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));
        } else if (sortAction === "toggle") {
          newSorting = old.map((d) => {
            if (d.id === column.id) {
              return {
                ...d,
                desc: nextDesc
              };
            }
            return d;
          });
        } else if (sortAction === "remove") {
          newSorting = old.filter((d) => d.id !== column.id);
        } else {
          newSorting = [{
            id: column.id,
            desc: nextDesc
          }];
        }
        return newSorting;
      });
    };
    column.getFirstSortDir = () => {
      var _ref, _column$columnDef$sor;
      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === "desc";
      return sortDescFirst ? "desc" : "asc";
    };
    column.getNextSortingOrder = (multi) => {
      var _table$options$enable, _table$options$enable2;
      const firstSortDirection = column.getFirstSortDir();
      const isSorted = column.getIsSorted();
      if (!isSorted) {
        return firstSortDirection;
      }
      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general
      (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true)) {
        return false;
      }
      return isSorted === "desc" ? "asc" : "desc";
    };
    column.getCanSort = () => {
      var _column$columnDef$ena, _table$options$enable3;
      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;
    };
    column.getCanMultiSort = () => {
      var _ref2, _column$columnDef$ena2;
      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;
    };
    column.getIsSorted = () => {
      var _table$getState$sorti;
      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d) => d.id === column.id);
      return !columnSort ? false : columnSort.desc ? "desc" : "asc";
    };
    column.getSortIndex = () => {
      var _table$getState$sorti2, _table$getState$sorti3;
      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d) => d.id === column.id)) != null ? _table$getState$sorti2 : -1;
    };
    column.clearSorting = () => {
      table.setSorting((old) => old != null && old.length ? old.filter((d) => d.id !== column.id) : []);
    };
    column.getToggleSortingHandler = () => {
      const canSort = column.getCanSort();
      return (e) => {
        if (!canSort)
          return;
        e.persist == null || e.persist();
        column.toggleSorting == null || column.toggleSorting(void 0, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);
      };
    };
  },
  createTable: (table) => {
    table.setSorting = (updater) => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);
    table.resetSorting = (defaultState) => {
      var _table$initialState$s, _table$initialState;
      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);
    };
    table.getPreSortedRowModel = () => table.getGroupedRowModel();
    table.getSortedRowModel = () => {
      if (!table._getSortedRowModel && table.options.getSortedRowModel) {
        table._getSortedRowModel = table.options.getSortedRowModel(table);
      }
      if (table.options.manualSorting || !table._getSortedRowModel) {
        return table.getPreSortedRowModel();
      }
      return table._getSortedRowModel();
    };
  }
};
var Visibility = {
  getInitialState: (state) => {
    return {
      columnVisibility: {},
      ...state
    };
  },
  getDefaultOptions: (table) => {
    return {
      onColumnVisibilityChange: makeStateUpdater("columnVisibility", table)
    };
  },
  createColumn: (column, table) => {
    column.toggleVisibility = (value) => {
      if (column.getCanHide()) {
        table.setColumnVisibility((old) => ({
          ...old,
          [column.id]: value != null ? value : !column.getIsVisible()
        }));
      }
    };
    column.getIsVisible = () => {
      var _table$getState$colum, _table$getState$colum2;
      return (_table$getState$colum = (_table$getState$colum2 = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum2[column.id]) != null ? _table$getState$colum : true;
    };
    column.getCanHide = () => {
      var _column$columnDef$ena, _table$options$enable;
      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);
    };
    column.getToggleVisibilityHandler = () => {
      return (e) => {
        column.toggleVisibility == null || column.toggleVisibility(e.target.checked);
      };
    };
  },
  createRow: (row, table) => {
    row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], (cells) => {
      return cells.filter((cell) => cell.column.getIsVisible());
    }, getMemoOptions(table.options, "debugRows", "_getAllVisibleCells"));
    row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], getMemoOptions(table.options, "debugRows", "getVisibleCells"));
  },
  createTable: (table) => {
    const makeVisibleColumnsMethod = (key, getColumns) => {
      return memo(() => [getColumns(), getColumns().filter((d) => d.getIsVisible()).map((d) => d.id).join("_")], (columns) => {
        return columns.filter((d) => d.getIsVisible == null ? void 0 : d.getIsVisible());
      }, getMemoOptions(table.options, "debugColumns", key));
    };
    table.getVisibleFlatColumns = makeVisibleColumnsMethod("getVisibleFlatColumns", () => table.getAllFlatColumns());
    table.getVisibleLeafColumns = makeVisibleColumnsMethod("getVisibleLeafColumns", () => table.getAllLeafColumns());
    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod("getLeftVisibleLeafColumns", () => table.getLeftLeafColumns());
    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod("getRightVisibleLeafColumns", () => table.getRightLeafColumns());
    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod("getCenterVisibleLeafColumns", () => table.getCenterLeafColumns());
    table.setColumnVisibility = (updater) => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);
    table.resetColumnVisibility = (defaultState) => {
      var _table$initialState$c;
      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});
    };
    table.toggleAllColumnsVisible = (value) => {
      var _value;
      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();
      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({
        ...obj,
        [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value
      }), {}));
    };
    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some((column) => !(column.getIsVisible != null && column.getIsVisible()));
    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some((column) => column.getIsVisible == null ? void 0 : column.getIsVisible());
    table.getToggleAllColumnsVisibilityHandler = () => {
      return (e) => {
        var _target;
        table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);
      };
    };
  }
};
function _getVisibleLeafColumns(table, position) {
  return !position ? table.getVisibleLeafColumns() : position === "center" ? table.getCenterVisibleLeafColumns() : position === "left" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();
}
var features = [Headers, Visibility, Ordering, Pinning, Filters, Sorting, Grouping, Expanding, Pagination, RowSelection, ColumnSizing];
function createTable(options) {
  var _options$initialState;
  if (options.debugAll || options.debugTable) {
    console.info("Creating Table Instance...");
  }
  let table = {
    _features: features
  };
  const defaultOptions = table._features.reduce((obj, feature) => {
    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));
  }, {});
  const mergeOptions = (options2) => {
    if (table.options.mergeOptions) {
      return table.options.mergeOptions(defaultOptions, options2);
    }
    return {
      ...defaultOptions,
      ...options2
    };
  };
  const coreInitialState = {};
  let initialState = {
    ...coreInitialState,
    ...(_options$initialState = options.initialState) != null ? _options$initialState : {}
  };
  table._features.forEach((feature) => {
    var _feature$getInitialSt;
    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;
  });
  const queued = [];
  let queuedTimeout = false;
  const coreInstance = {
    _features: features,
    options: {
      ...defaultOptions,
      ...options
    },
    initialState,
    _queue: (cb) => {
      queued.push(cb);
      if (!queuedTimeout) {
        queuedTimeout = true;
        Promise.resolve().then(() => {
          while (queued.length) {
            queued.shift()();
          }
          queuedTimeout = false;
        }).catch((error) => setTimeout(() => {
          throw error;
        }));
      }
    },
    reset: () => {
      table.setState(table.initialState);
    },
    setOptions: (updater) => {
      const newOptions = functionalUpdate(updater, table.options);
      table.options = mergeOptions(newOptions);
    },
    getState: () => {
      return table.options.state;
    },
    setState: (updater) => {
      table.options.onStateChange == null || table.options.onStateChange(updater);
    },
    _getRowId: (row, index, parent) => {
      var _table$options$getRow;
      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index].join(".") : index}`;
    },
    getCoreRowModel: () => {
      if (!table._getCoreRowModel) {
        table._getCoreRowModel = table.options.getCoreRowModel(table);
      }
      return table._getCoreRowModel();
    },
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => {
      return table.getPaginationRowModel();
    },
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (id, searchAll) => {
      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];
      if (!row) {
        row = table.getCoreRowModel().rowsById[id];
        if (!row) {
          if (true) {
            throw new Error(`getRow could not find row with ID: ${id}`);
          }
          throw new Error();
        }
      }
      return row;
    },
    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], (defaultColumn) => {
      var _defaultColumn;
      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};
      return {
        header: (props) => {
          const resolvedColumnDef = props.header.column.columnDef;
          if (resolvedColumnDef.accessorKey) {
            return resolvedColumnDef.accessorKey;
          }
          if (resolvedColumnDef.accessorFn) {
            return resolvedColumnDef.id;
          }
          return null;
        },
        // footer: props => props.header.column.id,
        cell: (props) => {
          var _props$renderValue$to, _props$renderValue;
          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;
        },
        ...table._features.reduce((obj, feature) => {
          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());
        }, {}),
        ...defaultColumn
      };
    }, getMemoOptions(options, "debugColumns", "_getDefaultColumnDef")),
    _getColumnDefs: () => table.options.columns,
    getAllColumns: memo(() => [table._getColumnDefs()], (columnDefs) => {
      const recurseColumns = function(columnDefs2, parent, depth) {
        if (depth === void 0) {
          depth = 0;
        }
        return columnDefs2.map((columnDef) => {
          const column = createColumn(table, columnDef, depth, parent);
          const groupingColumnDef = columnDef;
          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];
          return column;
        });
      };
      return recurseColumns(columnDefs);
    }, getMemoOptions(options, "debugColumns", "getAllColumns")),
    getAllFlatColumns: memo(() => [table.getAllColumns()], (allColumns) => {
      return allColumns.flatMap((column) => {
        return column.getFlatColumns();
      });
    }, getMemoOptions(options, "debugColumns", "getAllFlatColumns")),
    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], (flatColumns) => {
      return flatColumns.reduce((acc, column) => {
        acc[column.id] = column;
        return acc;
      }, {});
    }, getMemoOptions(options, "debugColumns", "getAllFlatColumnsById")),
    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns2) => {
      let leafColumns = allColumns.flatMap((column) => column.getLeafColumns());
      return orderColumns2(leafColumns);
    }, getMemoOptions(options, "debugColumns", "getAllLeafColumns")),
    getColumn: (columnId) => {
      const column = table._getAllFlatColumnsById()[columnId];
      if (!column) {
        console.error(`[Table] Column with id '${columnId}' does not exist.`);
      }
      return column;
    }
  };
  Object.assign(table, coreInstance);
  for (let index = 0; index < table._features.length; index++) {
    const feature = table._features[index];
    feature == null || feature.createTable == null || feature.createTable(table);
  }
  return table;
}
function createCell(table, row, column, columnId) {
  const getRenderValue = () => {
    var _cell$getValue;
    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;
  };
  const cell = {
    id: `${row.id}_${column.id}`,
    row,
    column,
    getValue: () => row.getValue(columnId),
    renderValue: getRenderValue,
    getContext: memo(() => [table, column, row, cell], (table2, column2, row2, cell2) => ({
      table: table2,
      column: column2,
      row: row2,
      cell: cell2,
      getValue: cell2.getValue,
      renderValue: cell2.renderValue
    }), getMemoOptions(table.options, "debugCells", "cell.getContext"))
  };
  table._features.forEach((feature) => {
    feature.createCell == null || feature.createCell(cell, column, row, table);
  }, {});
  return cell;
}
var createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {
  let row = {
    id,
    index: rowIndex,
    original,
    depth,
    parentId,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (columnId) => {
      if (row._valuesCache.hasOwnProperty(columnId)) {
        return row._valuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);
      return row._valuesCache[columnId];
    },
    getUniqueValues: (columnId) => {
      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {
        return row._uniqueValuesCache[columnId];
      }
      const column = table.getColumn(columnId);
      if (!(column != null && column.accessorFn)) {
        return void 0;
      }
      if (!column.columnDef.getUniqueValues) {
        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];
        return row._uniqueValuesCache[columnId];
      }
      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);
      return row._uniqueValuesCache[columnId];
    },
    renderValue: (columnId) => {
      var _row$getValue;
      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;
    },
    subRows: subRows != null ? subRows : [],
    getLeafRows: () => flattenBy(row.subRows, (d) => d.subRows),
    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : void 0,
    getParentRows: () => {
      let parentRows = [];
      let currentRow = row;
      while (true) {
        const parentRow = currentRow.getParentRow();
        if (!parentRow)
          break;
        parentRows.push(parentRow);
        currentRow = parentRow;
      }
      return parentRows.reverse();
    },
    getAllCells: memo(() => [table.getAllLeafColumns()], (leafColumns) => {
      return leafColumns.map((column) => {
        return createCell(table, row, column, column.id);
      });
    }, getMemoOptions(table.options, "debugRows", "getAllCells")),
    _getAllCellsByColumnId: memo(() => [row.getAllCells()], (allCells) => {
      return allCells.reduce((acc, cell) => {
        acc[cell.column.id] = cell;
        return acc;
      }, {});
    }, getMemoOptions(table.options, "debugRows", "getAllCellsByColumnId"))
  };
  for (let i = 0; i < table._features.length; i++) {
    const feature = table._features[i];
    feature == null || feature.createRow == null || feature.createRow(row, table);
  }
  return row;
};
function getCoreRowModel() {
  return (table) => memo(() => [table.options.data], (data) => {
    const rowModel = {
      rows: [],
      flatRows: [],
      rowsById: {}
    };
    const accessRows = function(originalRows, depth, parentRow) {
      if (depth === void 0) {
        depth = 0;
      }
      const rows = [];
      for (let i = 0; i < originalRows.length; i++) {
        const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, void 0, parentRow == null ? void 0 : parentRow.id);
        rowModel.flatRows.push(row);
        rowModel.rowsById[row.id] = row;
        rows.push(row);
        if (table.options.getSubRows) {
          var _row$originalSubRows;
          row.originalSubRows = table.options.getSubRows(originalRows[i], i);
          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {
            row.subRows = accessRows(row.originalSubRows, depth + 1, row);
          }
        }
      }
      return rows;
    };
    rowModel.rows = accessRows(data);
    return rowModel;
  }, getMemoOptions(table.options, "debugTable", "getRowModel", () => table._autoResetPageIndex()));
}
function filterRows(rows, filterRowImpl, table) {
  if (table.options.filterFromLeafRows) {
    return filterRowModelFromLeafs(rows, filterRowImpl, table);
  }
  return filterRowModelFromRoot(rows, filterRowImpl, table);
}
function filterRowModelFromLeafs(rowsToFilter, filterRow, table) {
  var _table$options$maxLea;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i = 0; i < rowsToFilter2.length; i++) {
      var _row$subRows;
      let row = rowsToFilter2[i];
      const newRow = createRow(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
      newRow.columnFilters = row.columnFilters;
      if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {
        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
        row = newRow;
        if (filterRow(row) && !newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
          continue;
        }
        if (filterRow(row) || newRow.subRows.length) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
          continue;
        }
      } else {
        row = newRow;
        if (filterRow(row)) {
          rows.push(row);
          newFilteredRowsById[row.id] = row;
          newFilteredFlatRows.push(row);
        }
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function filterRowModelFromRoot(rowsToFilter, filterRow, table) {
  var _table$options$maxLea2;
  const newFilteredFlatRows = [];
  const newFilteredRowsById = {};
  const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;
  const recurseFilterRows = function(rowsToFilter2, depth) {
    if (depth === void 0) {
      depth = 0;
    }
    const rows = [];
    for (let i = 0; i < rowsToFilter2.length; i++) {
      let row = rowsToFilter2[i];
      const pass = filterRow(row);
      if (pass) {
        var _row$subRows2;
        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {
          const newRow = createRow(table, row.id, row.original, row.index, row.depth, void 0, row.parentId);
          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);
          row = newRow;
        }
        rows.push(row);
        newFilteredFlatRows.push(row);
        newFilteredRowsById[row.id] = row;
      }
    }
    return rows;
  };
  return {
    rows: recurseFilterRows(rowsToFilter),
    flatRows: newFilteredFlatRows,
    rowsById: newFilteredRowsById
  };
}
function getFilteredRowModel() {
  return (table) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {
    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {
      for (let i = 0; i < rowModel.flatRows.length; i++) {
        rowModel.flatRows[i].columnFilters = {};
        rowModel.flatRows[i].columnFiltersMeta = {};
      }
      return rowModel;
    }
    const resolvedColumnFilters = [];
    const resolvedGlobalFilters = [];
    (columnFilters != null ? columnFilters : []).forEach((d) => {
      var _filterFn$resolveFilt;
      const column = table.getColumn(d.id);
      if (!column) {
        return;
      }
      const filterFn = column.getFilterFn();
      if (!filterFn) {
        if (true) {
          console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);
        }
        return;
      }
      resolvedColumnFilters.push({
        id: d.id,
        filterFn,
        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value
      });
    });
    const filterableIds = columnFilters.map((d) => d.id);
    const globalFilterFn = table.getGlobalFilterFn();
    const globallyFilterableColumns = table.getAllLeafColumns().filter((column) => column.getCanGlobalFilter());
    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {
      filterableIds.push("__global__");
      globallyFilterableColumns.forEach((column) => {
        var _globalFilterFn$resol;
        resolvedGlobalFilters.push({
          id: column.id,
          filterFn: globalFilterFn,
          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter
        });
      });
    }
    let currentColumnFilter;
    let currentGlobalFilter;
    for (let j = 0; j < rowModel.flatRows.length; j++) {
      const row = rowModel.flatRows[j];
      row.columnFilters = {};
      if (resolvedColumnFilters.length) {
        for (let i = 0; i < resolvedColumnFilters.length; i++) {
          currentColumnFilter = resolvedColumnFilters[i];
          const id = currentColumnFilter.id;
          row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id] = filterMeta;
          });
        }
      }
      if (resolvedGlobalFilters.length) {
        for (let i = 0; i < resolvedGlobalFilters.length; i++) {
          currentGlobalFilter = resolvedGlobalFilters[i];
          const id = currentGlobalFilter.id;
          if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta) => {
            row.columnFiltersMeta[id] = filterMeta;
          })) {
            row.columnFilters.__global__ = true;
            break;
          }
        }
        if (row.columnFilters.__global__ !== true) {
          row.columnFilters.__global__ = false;
        }
      }
    }
    const filterRowsImpl = (row) => {
      for (let i = 0; i < filterableIds.length; i++) {
        if (row.columnFilters[filterableIds[i]] === false) {
          return false;
        }
      }
      return true;
    };
    return filterRows(rowModel.rows, filterRowsImpl, table);
  }, getMemoOptions(table.options, "debugTable", "getFilteredRowModel", () => table._autoResetPageIndex()));
}
function getFacetedRowModel() {
  return (table, columnId) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter, table.getFilteredRowModel()], (preRowModel, columnFilters, globalFilter) => {
    if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {
      return preRowModel;
    }
    const filterableIds = [...columnFilters.map((d) => d.id).filter((d) => d !== columnId), globalFilter ? "__global__" : void 0].filter(Boolean);
    const filterRowsImpl = (row) => {
      for (let i = 0; i < filterableIds.length; i++) {
        if (row.columnFilters[filterableIds[i]] === false) {
          return false;
        }
      }
      return true;
    };
    return filterRows(preRowModel.rows, filterRowsImpl, table);
  }, getMemoOptions(table.options, "debugTable", "getFacetedRowModel"));
}
function getFacetedUniqueValues() {
  return (table, columnId) => memo(() => {
    var _table$getColumn;
    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];
  }, (facetedRowModel) => {
    if (!facetedRowModel)
      return /* @__PURE__ */ new Map();
    let facetedUniqueValues = /* @__PURE__ */ new Map();
    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {
      const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);
      for (let j = 0; j < values.length; j++) {
        const value = values[j];
        if (facetedUniqueValues.has(value)) {
          var _facetedUniqueValues$;
          facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);
        } else {
          facetedUniqueValues.set(value, 1);
        }
      }
    }
    return facetedUniqueValues;
  }, getMemoOptions(table.options, "debugTable", `getFacetedUniqueValues_${columnId}`));
}
function getFacetedMinMaxValues() {
  return (table, columnId) => memo(() => {
    var _table$getColumn;
    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];
  }, (facetedRowModel) => {
    var _facetedRowModel$flat;
    if (!facetedRowModel)
      return void 0;
    const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getUniqueValues(columnId);
    if (typeof firstValue === "undefined") {
      return void 0;
    }
    let facetedMinMaxValues = [firstValue, firstValue];
    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {
      const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);
      for (let j = 0; j < values.length; j++) {
        const value = values[j];
        if (value < facetedMinMaxValues[0]) {
          facetedMinMaxValues[0] = value;
        } else if (value > facetedMinMaxValues[1]) {
          facetedMinMaxValues[1] = value;
        }
      }
    }
    return facetedMinMaxValues;
  }, getMemoOptions(table.options, "debugTable", "getFacetedMinMaxValues"));
}
function getSortedRowModel() {
  return (table) => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {
    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {
      return rowModel;
    }
    const sortingState = table.getState().sorting;
    const sortedFlatRows = [];
    const availableSorting = sortingState.filter((sort) => {
      var _table$getColumn;
      return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();
    });
    const columnInfoById = {};
    availableSorting.forEach((sortEntry) => {
      const column = table.getColumn(sortEntry.id);
      if (!column)
        return;
      columnInfoById[sortEntry.id] = {
        sortUndefined: column.columnDef.sortUndefined,
        invertSorting: column.columnDef.invertSorting,
        sortingFn: column.getSortingFn()
      };
    });
    const sortData = (rows) => {
      const sortedData = rows.map((row) => ({
        ...row
      }));
      sortedData.sort((rowA, rowB) => {
        for (let i = 0; i < availableSorting.length; i += 1) {
          var _sortEntry$desc;
          const sortEntry = availableSorting[i];
          const columnInfo = columnInfoById[sortEntry.id];
          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;
          let sortInt = 0;
          if (columnInfo.sortUndefined) {
            const aValue = rowA.getValue(sortEntry.id);
            const bValue = rowB.getValue(sortEntry.id);
            const aUndefined = aValue === void 0;
            const bUndefined = bValue === void 0;
            if (aUndefined || bUndefined) {
              sortInt = aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;
            }
          }
          if (sortInt === 0) {
            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);
          }
          if (sortInt !== 0) {
            if (isDesc) {
              sortInt *= -1;
            }
            if (columnInfo.invertSorting) {
              sortInt *= -1;
            }
            return sortInt;
          }
        }
        return rowA.index - rowB.index;
      });
      sortedData.forEach((row) => {
        var _row$subRows;
        sortedFlatRows.push(row);
        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {
          row.subRows = sortData(row.subRows);
        }
      });
      return sortedData;
    };
    return {
      rows: sortData(rowModel.rows),
      flatRows: sortedFlatRows,
      rowsById: rowModel.rowsById
    };
  }, getMemoOptions(table.options, "debugTable", "getSortedRowModel", () => table._autoResetPageIndex()));
}
function getGroupedRowModel() {
  return (table) => memo(() => [table.getState().grouping, table.getPreGroupedRowModel()], (grouping, rowModel) => {
    if (!rowModel.rows.length || !grouping.length) {
      return rowModel;
    }
    const existingGrouping = grouping.filter((columnId) => table.getColumn(columnId));
    const groupedFlatRows = [];
    const groupedRowsById = {};
    const groupUpRecursively = function(rows, depth, parentId) {
      if (depth === void 0) {
        depth = 0;
      }
      if (depth >= existingGrouping.length) {
        return rows.map((row) => {
          row.depth = depth;
          groupedFlatRows.push(row);
          groupedRowsById[row.id] = row;
          if (row.subRows) {
            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);
          }
          return row;
        });
      }
      const columnId = existingGrouping[depth];
      const rowGroupsMap = groupBy(rows, columnId);
      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {
        let [groupingValue, groupedRows2] = _ref;
        let id = `${columnId}:${groupingValue}`;
        id = parentId ? `${parentId}>${id}` : id;
        const subRows = groupUpRecursively(groupedRows2, depth + 1, id);
        const leafRows = depth ? flattenBy(groupedRows2, (row2) => row2.subRows) : groupedRows2;
        const row = createRow(table, id, leafRows[0].original, index, depth, void 0, parentId);
        Object.assign(row, {
          groupingColumnId: columnId,
          groupingValue,
          subRows,
          leafRows,
          getValue: (columnId2) => {
            if (existingGrouping.includes(columnId2)) {
              if (row._valuesCache.hasOwnProperty(columnId2)) {
                return row._valuesCache[columnId2];
              }
              if (groupedRows2[0]) {
                var _groupedRows$0$getVal;
                row._valuesCache[columnId2] = (_groupedRows$0$getVal = groupedRows2[0].getValue(columnId2)) != null ? _groupedRows$0$getVal : void 0;
              }
              return row._valuesCache[columnId2];
            }
            if (row._groupingValuesCache.hasOwnProperty(columnId2)) {
              return row._groupingValuesCache[columnId2];
            }
            const column = table.getColumn(columnId2);
            const aggregateFn = column == null ? void 0 : column.getAggregationFn();
            if (aggregateFn) {
              row._groupingValuesCache[columnId2] = aggregateFn(columnId2, leafRows, groupedRows2);
              return row._groupingValuesCache[columnId2];
            }
          }
        });
        subRows.forEach((subRow) => {
          groupedFlatRows.push(subRow);
          groupedRowsById[subRow.id] = subRow;
        });
        return row;
      });
      return aggregatedGroupedRows;
    };
    const groupedRows = groupUpRecursively(rowModel.rows, 0);
    groupedRows.forEach((subRow) => {
      groupedFlatRows.push(subRow);
      groupedRowsById[subRow.id] = subRow;
    });
    return {
      rows: groupedRows,
      flatRows: groupedFlatRows,
      rowsById: groupedRowsById
    };
  }, getMemoOptions(table.options, "debugTable", "getGroupedRowModel", () => {
    table._queue(() => {
      table._autoResetExpanded();
      table._autoResetPageIndex();
    });
  }));
}
function groupBy(rows, columnId) {
  const groupMap = /* @__PURE__ */ new Map();
  return rows.reduce((map, row) => {
    const resKey = `${row.getGroupingValue(columnId)}`;
    const previous = map.get(resKey);
    if (!previous) {
      map.set(resKey, [row]);
    } else {
      previous.push(row);
    }
    return map;
  }, groupMap);
}
function getExpandedRowModel() {
  return (table) => memo(() => [table.getState().expanded, table.getPreExpandedRowModel(), table.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {
    if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {
      return rowModel;
    }
    if (!paginateExpandedRows) {
      return rowModel;
    }
    return expandRows(rowModel);
  }, getMemoOptions(table.options, "debugTable", "getExpandedRowModel"));
}
function expandRows(rowModel) {
  const expandedRows = [];
  const handleRow = (row) => {
    var _row$subRows;
    expandedRows.push(row);
    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {
      row.subRows.forEach(handleRow);
    }
  };
  rowModel.rows.forEach(handleRow);
  return {
    rows: expandedRows,
    flatRows: rowModel.flatRows,
    rowsById: rowModel.rowsById
  };
}
function getPaginationRowModel(opts) {
  return (table) => memo(() => [table.getState().pagination, table.getPrePaginationRowModel(), table.options.paginateExpandedRows ? void 0 : table.getState().expanded], (pagination, rowModel) => {
    if (!rowModel.rows.length) {
      return rowModel;
    }
    const {
      pageSize,
      pageIndex
    } = pagination;
    let {
      rows,
      flatRows,
      rowsById
    } = rowModel;
    const pageStart = pageSize * pageIndex;
    const pageEnd = pageStart + pageSize;
    rows = rows.slice(pageStart, pageEnd);
    let paginatedRowModel;
    if (!table.options.paginateExpandedRows) {
      paginatedRowModel = expandRows({
        rows,
        flatRows,
        rowsById
      });
    } else {
      paginatedRowModel = {
        rows,
        flatRows,
        rowsById
      };
    }
    paginatedRowModel.flatRows = [];
    const handleRow = (row) => {
      paginatedRowModel.flatRows.push(row);
      if (row.subRows.length) {
        row.subRows.forEach(handleRow);
      }
    };
    paginatedRowModel.rows.forEach(handleRow);
    return paginatedRowModel;
  }, getMemoOptions(table.options, "debugTable", "getPaginationRowModel"));
}

// node_modules/@tanstack/react-table/build/lib/index.mjs
function flexRender(Comp, props) {
  return !Comp ? null : isReactComponent(Comp) ? React.createElement(Comp, props) : Comp;
}
function isReactComponent(component) {
  return isClassComponent(component) || typeof component === "function" || isExoticComponent(component);
}
function isClassComponent(component) {
  return typeof component === "function" && (() => {
    const proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  })();
}
function isExoticComponent(component) {
  return typeof component === "object" && typeof component.$$typeof === "symbol" && ["react.memo", "react.forward_ref"].includes(component.$$typeof.description);
}
function useReactTable(options) {
  const resolvedOptions = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...options
  };
  const [tableRef] = React.useState(() => ({
    current: createTable(resolvedOptions)
  }));
  const [state, setState] = React.useState(() => tableRef.current.initialState);
  tableRef.current.setOptions((prev) => ({
    ...prev,
    ...options,
    state: {
      ...state,
      ...options.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (updater) => {
      setState(updater);
      options.onStateChange == null || options.onStateChange(updater);
    }
  }));
  return tableRef.current;
}

// node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs
var characterMap = {
  Ã€: "A",
  Ã: "A",
  Ã‚: "A",
  Ãƒ: "A",
  Ã„: "A",
  Ã…: "A",
  áº¤: "A",
  áº®: "A",
  áº²: "A",
  áº´: "A",
  áº¶: "A",
  Ã†: "AE",
  áº¦: "A",
  áº°: "A",
  È‚: "A",
  Ã‡: "C",
  á¸ˆ: "C",
  Ãˆ: "E",
  Ã‰: "E",
  ÃŠ: "E",
  Ã‹: "E",
  áº¾: "E",
  á¸–: "E",
  á»€: "E",
  á¸”: "E",
  á¸œ: "E",
  È†: "E",
  ÃŒ: "I",
  Ã: "I",
  ÃŽ: "I",
  Ã: "I",
  á¸®: "I",
  ÈŠ: "I",
  Ã: "D",
  Ã‘: "N",
  Ã’: "O",
  Ã“: "O",
  Ã”: "O",
  Ã•: "O",
  Ã–: "O",
  Ã˜: "O",
  á»: "O",
  á¹Œ: "O",
  á¹’: "O",
  ÈŽ: "O",
  Ã™: "U",
  Ãš: "U",
  Ã›: "U",
  Ãœ: "U",
  Ã: "Y",
  Ã : "a",
  Ã¡: "a",
  Ã¢: "a",
  Ã£: "a",
  Ã¤: "a",
  Ã¥: "a",
  áº¥: "a",
  áº¯: "a",
  áº³: "a",
  áºµ: "a",
  áº·: "a",
  Ã¦: "ae",
  áº§: "a",
  áº±: "a",
  Èƒ: "a",
  Ã§: "c",
  á¸‰: "c",
  Ã¨: "e",
  Ã©: "e",
  Ãª: "e",
  Ã«: "e",
  áº¿: "e",
  á¸—: "e",
  á»: "e",
  á¸•: "e",
  á¸: "e",
  È‡: "e",
  Ã¬: "i",
  Ã­: "i",
  Ã®: "i",
  Ã¯: "i",
  á¸¯: "i",
  È‹: "i",
  Ã°: "d",
  Ã±: "n",
  Ã²: "o",
  Ã³: "o",
  Ã´: "o",
  Ãµ: "o",
  Ã¶: "o",
  Ã¸: "o",
  á»‘: "o",
  á¹: "o",
  á¹“: "o",
  È: "o",
  Ã¹: "u",
  Ãº: "u",
  Ã»: "u",
  Ã¼: "u",
  Ã½: "y",
  Ã¿: "y",
  Ä€: "A",
  Ä: "a",
  Ä‚: "A",
  Äƒ: "a",
  Ä„: "A",
  Ä…: "a",
  Ä†: "C",
  Ä‡: "c",
  Äˆ: "C",
  Ä‰: "c",
  ÄŠ: "C",
  Ä‹: "c",
  ÄŒ: "C",
  Ä: "c",
  CÌ†: "C",
  cÌ†: "c",
  ÄŽ: "D",
  Ä: "d",
  Ä: "D",
  Ä‘: "d",
  Ä’: "E",
  Ä“: "e",
  Ä”: "E",
  Ä•: "e",
  Ä–: "E",
  Ä—: "e",
  Ä˜: "E",
  Ä™: "e",
  Äš: "E",
  Ä›: "e",
  Äœ: "G",
  Ç´: "G",
  Ä: "g",
  Çµ: "g",
  Äž: "G",
  ÄŸ: "g",
  Ä : "G",
  Ä¡: "g",
  Ä¢: "G",
  Ä£: "g",
  Ä¤: "H",
  Ä¥: "h",
  Ä¦: "H",
  Ä§: "h",
  á¸ª: "H",
  á¸«: "h",
  Ä¨: "I",
  Ä©: "i",
  Äª: "I",
  Ä«: "i",
  Ä¬: "I",
  Ä­: "i",
  Ä®: "I",
  Ä¯: "i",
  Ä°: "I",
  Ä±: "i",
  Ä²: "IJ",
  Ä³: "ij",
  Ä´: "J",
  Äµ: "j",
  Ä¶: "K",
  Ä·: "k",
  á¸°: "K",
  á¸±: "k",
  KÌ†: "K",
  kÌ†: "k",
  Ä¹: "L",
  Äº: "l",
  Ä»: "L",
  Ä¼: "l",
  Ä½: "L",
  Ä¾: "l",
  Ä¿: "L",
  Å€: "l",
  Å: "l",
  Å‚: "l",
  á¸¾: "M",
  á¸¿: "m",
  MÌ†: "M",
  mÌ†: "m",
  Åƒ: "N",
  Å„: "n",
  Å…: "N",
  Å†: "n",
  Å‡: "N",
  Åˆ: "n",
  Å‰: "n",
  NÌ†: "N",
  nÌ†: "n",
  ÅŒ: "O",
  Å: "o",
  ÅŽ: "O",
  Å: "o",
  Å: "O",
  Å‘: "o",
  Å’: "OE",
  Å“: "oe",
  PÌ†: "P",
  pÌ†: "p",
  Å”: "R",
  Å•: "r",
  Å–: "R",
  Å—: "r",
  Å˜: "R",
  Å™: "r",
  RÌ†: "R",
  rÌ†: "r",
  È’: "R",
  È“: "r",
  Åš: "S",
  Å›: "s",
  Åœ: "S",
  Å: "s",
  Åž: "S",
  È˜: "S",
  È™: "s",
  ÅŸ: "s",
  Å : "S",
  Å¡: "s",
  Å¢: "T",
  Å£: "t",
  È›: "t",
  Èš: "T",
  Å¤: "T",
  Å¥: "t",
  Å¦: "T",
  Å§: "t",
  TÌ†: "T",
  tÌ†: "t",
  Å¨: "U",
  Å©: "u",
  Åª: "U",
  Å«: "u",
  Å¬: "U",
  Å­: "u",
  Å®: "U",
  Å¯: "u",
  Å°: "U",
  Å±: "u",
  Å²: "U",
  Å³: "u",
  È–: "U",
  È—: "u",
  VÌ†: "V",
  vÌ†: "v",
  Å´: "W",
  Åµ: "w",
  áº‚: "W",
  áºƒ: "w",
  XÌ†: "X",
  xÌ†: "x",
  Å¶: "Y",
  Å·: "y",
  Å¸: "Y",
  YÌ†: "Y",
  yÌ†: "y",
  Å¹: "Z",
  Åº: "z",
  Å»: "Z",
  Å¼: "z",
  Å½: "Z",
  Å¾: "z",
  Å¿: "s",
  Æ’: "f",
  Æ : "O",
  Æ¡: "o",
  Æ¯: "U",
  Æ°: "u",
  Ç: "A",
  ÇŽ: "a",
  Ç: "I",
  Ç: "i",
  Ç‘: "O",
  Ç’: "o",
  Ç“: "U",
  Ç”: "u",
  Ç•: "U",
  Ç–: "u",
  Ç—: "U",
  Ç˜: "u",
  Ç™: "U",
  Çš: "u",
  Ç›: "U",
  Çœ: "u",
  á»¨: "U",
  á»©: "u",
  á¹¸: "U",
  á¹¹: "u",
  Çº: "A",
  Ç»: "a",
  Ç¼: "AE",
  Ç½: "ae",
  Ç¾: "O",
  Ç¿: "o",
  Ãž: "TH",
  Ã¾: "th",
  á¹”: "P",
  á¹•: "p",
  á¹¤: "S",
  á¹¥: "s",
  XÌ: "X",
  xÌ: "x",
  Ðƒ: "Ð“",
  Ñ“: "Ð³",
  ÐŒ: "Ðš",
  Ñœ: "Ðº",
  AÌ‹: "A",
  aÌ‹: "a",
  EÌ‹: "E",
  eÌ‹: "e",
  IÌ‹: "I",
  iÌ‹: "i",
  Ç¸: "N",
  Ç¹: "n",
  á»’: "O",
  á»“: "o",
  á¹: "O",
  á¹‘: "o",
  á»ª: "U",
  á»«: "u",
  áº€: "W",
  áº: "w",
  á»²: "Y",
  á»³: "y",
  È€: "A",
  È: "a",
  È„: "E",
  È…: "e",
  Èˆ: "I",
  È‰: "i",
  ÈŒ: "O",
  È: "o",
  È: "R",
  È‘: "r",
  È”: "U",
  È•: "u",
  BÌŒ: "B",
  bÌŒ: "b",
  ÄŒÌ£: "C",
  ÄÌ£: "c",
  ÃŠÌŒ: "E",
  ÃªÌŒ: "e",
  FÌŒ: "F",
  fÌŒ: "f",
  Ç¦: "G",
  Ç§: "g",
  Èž: "H",
  ÈŸ: "h",
  JÌŒ: "J",
  Ç°: "j",
  Ç¨: "K",
  Ç©: "k",
  MÌŒ: "M",
  mÌŒ: "m",
  PÌŒ: "P",
  pÌŒ: "p",
  QÌŒ: "Q",
  qÌŒ: "q",
  Å˜Ì©: "R",
  Å™Ì©: "r",
  á¹¦: "S",
  á¹§: "s",
  VÌŒ: "V",
  vÌŒ: "v",
  WÌŒ: "W",
  wÌŒ: "w",
  XÌŒ: "X",
  xÌŒ: "x",
  YÌŒ: "Y",
  yÌŒ: "y",
  AÌ§: "A",
  aÌ§: "a",
  BÌ§: "B",
  bÌ§: "b",
  á¸: "D",
  á¸‘: "d",
  È¨: "E",
  È©: "e",
  ÆÌ§: "E",
  É›Ì§: "e",
  á¸¨: "H",
  á¸©: "h",
  IÌ§: "I",
  iÌ§: "i",
  Æ—Ì§: "I",
  É¨Ì§: "i",
  MÌ§: "M",
  mÌ§: "m",
  OÌ§: "O",
  oÌ§: "o",
  QÌ§: "Q",
  qÌ§: "q",
  UÌ§: "U",
  uÌ§: "u",
  XÌ§: "X",
  xÌ§: "x",
  ZÌ§: "Z",
  zÌ§: "z"
};
var chars = Object.keys(characterMap).join("|");
var allAccents = new RegExp(chars, "g");
function removeAccents(str) {
  return str.replace(allAccents, (match) => {
    return characterMap[match];
  });
}
var rankings = {
  CASE_SENSITIVE_EQUAL: 7,
  EQUAL: 6,
  STARTS_WITH: 5,
  WORD_STARTS_WITH: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0
};
function rankItem(item, value, options) {
  var _options$threshold;
  options = options || {};
  options.threshold = (_options$threshold = options.threshold) != null ? _options$threshold : rankings.MATCHES;
  if (!options.accessors) {
    const rank = getMatchRanking(item, value, options);
    return {
      // ends up being duplicate of 'item' in matches but consistent
      rankedValue: item,
      rank,
      accessorIndex: -1,
      accessorThreshold: options.threshold,
      passed: rank >= options.threshold
    };
  }
  const valuesToRank = getAllValuesToRank(item, options.accessors);
  const rankingInfo = {
    rankedValue: item,
    rank: rankings.NO_MATCH,
    accessorIndex: -1,
    accessorThreshold: options.threshold,
    passed: false
  };
  for (let i = 0; i < valuesToRank.length; i++) {
    const rankValue = valuesToRank[i];
    let newRank = getMatchRanking(rankValue.itemValue, value, options);
    const {
      minRanking,
      maxRanking,
      threshold = options.threshold
    } = rankValue.attributes;
    if (newRank < minRanking && newRank >= rankings.MATCHES) {
      newRank = minRanking;
    } else if (newRank > maxRanking) {
      newRank = maxRanking;
    }
    newRank = Math.min(newRank, maxRanking);
    if (newRank >= threshold && newRank > rankingInfo.rank) {
      rankingInfo.rank = newRank;
      rankingInfo.passed = true;
      rankingInfo.accessorIndex = i;
      rankingInfo.accessorThreshold = threshold;
      rankingInfo.rankedValue = rankValue.itemValue;
    }
  }
  return rankingInfo;
}
function getMatchRanking(testString, stringToRank, options) {
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);
  if (stringToRank.length > testString.length) {
    return rankings.NO_MATCH;
  }
  if (testString === stringToRank) {
    return rankings.CASE_SENSITIVE_EQUAL;
  }
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();
  if (testString === stringToRank) {
    return rankings.EQUAL;
  }
  if (testString.startsWith(stringToRank)) {
    return rankings.STARTS_WITH;
  }
  if (testString.includes(` ${stringToRank}`)) {
    return rankings.WORD_STARTS_WITH;
  }
  if (testString.includes(stringToRank)) {
    return rankings.CONTAINS;
  } else if (stringToRank.length === 1) {
    return rankings.NO_MATCH;
  }
  if (getAcronym(testString).includes(stringToRank)) {
    return rankings.ACRONYM;
  }
  return getClosenessRanking(testString, stringToRank);
}
function getAcronym(string) {
  let acronym = "";
  const wordsInString = string.split(" ");
  wordsInString.forEach((wordInString) => {
    const splitByHyphenWords = wordInString.split("-");
    splitByHyphenWords.forEach((splitByHyphenWord) => {
      acronym += splitByHyphenWord.substr(0, 1);
    });
  });
  return acronym;
}
function getClosenessRanking(testString, stringToRank) {
  let matchingInOrderCharCount = 0;
  let charNumber = 0;
  function findMatchingCharacter(matchChar, string, index) {
    for (let j = index, J = string.length; j < J; j++) {
      const stringChar = string[j];
      if (stringChar === matchChar) {
        matchingInOrderCharCount += 1;
        return j + 1;
      }
    }
    return -1;
  }
  function getRanking(spread2) {
    const spreadPercentage = 1 / spread2;
    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
    const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;
    return ranking;
  }
  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);
  if (firstIndex < 0) {
    return rankings.NO_MATCH;
  }
  charNumber = firstIndex;
  for (let i = 1, I = stringToRank.length; i < I; i++) {
    const matchChar = stringToRank[i];
    charNumber = findMatchingCharacter(matchChar, testString, charNumber);
    const found = charNumber > -1;
    if (!found) {
      return rankings.NO_MATCH;
    }
  }
  const spread = charNumber - firstIndex;
  return getRanking(spread);
}
function compareItems(a, b) {
  return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1;
}
function prepareValueForComparison(value, _ref) {
  let {
    keepDiacritics
  } = _ref;
  value = `${value}`;
  if (!keepDiacritics) {
    value = removeAccents(value);
  }
  return value;
}
function getItemValues(item, accessor) {
  let accessorFn = accessor;
  if (typeof accessor === "object") {
    accessorFn = accessor.accessor;
  }
  const value = accessorFn(item);
  if (value == null) {
    return [];
  }
  if (Array.isArray(value)) {
    return value;
  }
  return [String(value)];
}
function getAllValuesToRank(item, accessors) {
  const allValues = [];
  for (let j = 0, J = accessors.length; j < J; j++) {
    const accessor = accessors[j];
    const attributes = getAccessorAttributes(accessor);
    const itemValues = getItemValues(item, accessor);
    for (let i = 0, I = itemValues.length; i < I; i++) {
      allValues.push({
        itemValue: itemValues[i],
        attributes
      });
    }
  }
  return allValues;
}
var defaultKeyAttributes = {
  maxRanking: Infinity,
  minRanking: -Infinity
};
function getAccessorAttributes(accessor) {
  if (typeof accessor === "function") {
    return defaultKeyAttributes;
  }
  return {
    ...defaultKeyAttributes,
    ...accessor
  };
}

// node_modules/material-react-table/dist/index.esm.js
var import_react = __toESM(require_react());
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var import_ArrowDownward = __toESM(require_ArrowDownward());
var import_ArrowRight = __toESM(require_ArrowRight());
var import_Cancel = __toESM(require_Cancel());
var import_ChevronLeft = __toESM(require_ChevronLeft());
var import_ChevronRight = __toESM(require_ChevronRight());
var import_ClearAll = __toESM(require_ClearAll());
var import_Close = __toESM(require_Close());
var import_ContentCopy = __toESM(require_ContentCopy());
var import_DensityLarge = __toESM(require_DensityLarge());
var import_DensityMedium = __toESM(require_DensityMedium());
var import_DensitySmall = __toESM(require_DensitySmall());
var import_DragHandle = __toESM(require_DragHandle());
var import_DynamicFeed = __toESM(require_DynamicFeed());
var import_Edit = __toESM(require_Edit());
var import_ExpandMore = __toESM(require_ExpandMore());
var import_FilterAlt = __toESM(require_FilterAlt());
var import_FilterList = __toESM(require_FilterList());
var import_FilterListOff = __toESM(require_FilterListOff());
var import_FirstPage = __toESM(require_FirstPage());
var import_Fullscreen = __toESM(require_Fullscreen());
var import_FullscreenExit = __toESM(require_FullscreenExit());
var import_KeyboardDoubleArrowDown = __toESM(require_KeyboardDoubleArrowDown());
var import_LastPage = __toESM(require_LastPage());
var import_MoreHoriz = __toESM(require_MoreHoriz());
var import_MoreVert = __toESM(require_MoreVert());
var import_PushPin = __toESM(require_PushPin());
var import_RestartAlt = __toESM(require_RestartAlt());
var import_Save = __toESM(require_Save());
var import_Search = __toESM(require_Search());
var import_SearchOff = __toESM(require_SearchOff());
var import_Sort = __toESM(require_Sort());
var import_SyncAlt = __toESM(require_SyncAlt());
var import_ViewColumn = __toESM(require_ViewColumn());
var import_VisibilityOff = __toESM(require_VisibilityOff());

// node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}

// node_modules/@tanstack/react-virtual/build/lib/index.mjs
var React2 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);

// node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}

// node_modules/@tanstack/virtual-core/build/lib/utils.mjs
function memo2(getDeps, fn, opts) {
  var _opts$initialDeps;
  var deps = (_opts$initialDeps = opts.initialDeps) != null ? _opts$initialDeps : [];
  var result;
  return function() {
    var depTime;
    if (opts.key && opts.debug != null && opts.debug())
      depTime = Date.now();
    var newDeps = getDeps();
    var depsChanged = newDeps.length !== deps.length || newDeps.some(function(dep, index) {
      return deps[index] !== dep;
    });
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    var resultTime;
    if (opts.key && opts.debug != null && opts.debug())
      resultTime = Date.now();
    result = fn.apply(void 0, newDeps);
    if (opts.key && opts.debug != null && opts.debug()) {
      var depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      var resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      var resultFpsPercentage = resultEndTime / 16;
      var pad = function pad2(str, num) {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info("%câ± " + pad(resultEndTime, 5) + " /" + pad(depEndTime, 5) + " ms", "\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(" + Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120)) + "deg 100% 31%);", opts == null ? void 0 : opts.key);
    }
    opts == null || opts.onChange == null || opts.onChange(result);
    return result;
  };
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error("Unexpected undefined" + (msg ? ": " + msg : ""));
  } else {
    return value;
  }
}
var approxEqual = function approxEqual2(a, b) {
  return Math.abs(a - b) < 1;
};

// node_modules/@tanstack/virtual-core/build/lib/index.mjs
var defaultKeyExtractor = function defaultKeyExtractor2(index) {
  return index;
};
var defaultRangeExtractor = function defaultRangeExtractor2(range) {
  var start = Math.max(range.startIndex - range.overscan, 0);
  var end = Math.min(range.endIndex + range.overscan, range.count - 1);
  var arr = [];
  for (var _i = start; _i <= end; _i++) {
    arr.push(_i);
  }
  return arr;
};
var observeElementRect = function observeElementRect2(instance, cb) {
  var element = instance.scrollElement;
  if (!element) {
    return;
  }
  var handler = function handler2(rect) {
    var width = rect.width, height = rect.height;
    cb({
      width: Math.round(width),
      height: Math.round(height)
    });
  };
  handler(element.getBoundingClientRect());
  var observer = new ResizeObserver(function(entries) {
    var entry = entries[0];
    if (entry != null && entry.borderBoxSize) {
      var box = entry.borderBoxSize[0];
      if (box) {
        handler({
          width: box.inlineSize,
          height: box.blockSize
        });
        return;
      }
    }
    handler(element.getBoundingClientRect());
  });
  observer.observe(element, {
    box: "border-box"
  });
  return function() {
    observer.unobserve(element);
  };
};
var observeElementOffset = function observeElementOffset2(instance, cb) {
  var element = instance.scrollElement;
  if (!element) {
    return;
  }
  var handler = function handler2() {
    cb(element[instance.options.horizontal ? "scrollLeft" : "scrollTop"]);
  };
  handler();
  element.addEventListener("scroll", handler, {
    passive: true
  });
  return function() {
    element.removeEventListener("scroll", handler);
  };
};
var measureElement = function measureElement2(element, entry, instance) {
  if (entry != null && entry.borderBoxSize) {
    var box = entry.borderBoxSize[0];
    if (box) {
      var size = Math.round(box[instance.options.horizontal ? "inlineSize" : "blockSize"]);
      return size;
    }
  }
  return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? "width" : "height"]);
};
var elementScroll = function elementScroll2(offset, _ref2, instance) {
  var _instance$scrollEleme3, _instance$scrollEleme4;
  var _ref2$adjustments = _ref2.adjustments, adjustments = _ref2$adjustments === void 0 ? 0 : _ref2$adjustments, behavior = _ref2.behavior;
  var toOffset = offset + adjustments;
  (_instance$scrollEleme3 = instance.scrollElement) == null || _instance$scrollEleme3.scrollTo == null || _instance$scrollEleme3.scrollTo((_instance$scrollEleme4 = {}, _instance$scrollEleme4[instance.options.horizontal ? "left" : "top"] = toOffset, _instance$scrollEleme4.behavior = behavior, _instance$scrollEleme4));
};
var Virtualizer = function Virtualizer2(_opts) {
  var _this = this;
  this.unsubs = [];
  this.scrollElement = null;
  this.isScrolling = false;
  this.isScrollingTimeoutId = null;
  this.scrollToIndexTimeoutId = null;
  this.measurementsCache = [];
  this.itemSizeCache = /* @__PURE__ */ new Map();
  this.pendingMeasuredCacheIndexes = [];
  this.scrollDirection = null;
  this.scrollAdjustments = 0;
  this.measureElementCache = /* @__PURE__ */ new Map();
  this.observer = /* @__PURE__ */ function() {
    var _ro = null;
    var get = function get2() {
      if (_ro) {
        return _ro;
      } else if (typeof ResizeObserver !== "undefined") {
        return _ro = new ResizeObserver(function(entries) {
          entries.forEach(function(entry) {
            _this._measureElement(entry.target, entry);
          });
        });
      } else {
        return null;
      }
    };
    return {
      disconnect: function disconnect() {
        var _get;
        return (_get = get()) == null ? void 0 : _get.disconnect();
      },
      observe: function observe(target) {
        var _get2;
        return (_get2 = get()) == null ? void 0 : _get2.observe(target, {
          box: "border-box"
        });
      },
      unobserve: function unobserve(target) {
        var _get3;
        return (_get3 = get()) == null ? void 0 : _get3.unobserve(target);
      }
    };
  }();
  this.range = null;
  this.setOptions = function(opts) {
    Object.entries(opts).forEach(function(_ref3) {
      var key = _ref3[0], value = _ref3[1];
      if (typeof value === "undefined")
        delete opts[key];
    });
    _this.options = _extends3({
      debug: false,
      initialOffset: 0,
      overscan: 1,
      paddingStart: 0,
      paddingEnd: 0,
      scrollPaddingStart: 0,
      scrollPaddingEnd: 0,
      horizontal: false,
      getItemKey: defaultKeyExtractor,
      rangeExtractor: defaultRangeExtractor,
      onChange: function onChange() {
      },
      measureElement,
      initialRect: {
        width: 0,
        height: 0
      },
      scrollMargin: 0,
      scrollingDelay: 150,
      indexAttribute: "data-index",
      initialMeasurementsCache: [],
      lanes: 1
    }, opts);
  };
  this.notify = function(sync) {
    _this.options.onChange == null || _this.options.onChange(_this, sync);
  };
  this.maybeNotify = memo2(function() {
    _this.calculateRange();
    return [_this.isScrolling, _this.range ? _this.range.startIndex : null, _this.range ? _this.range.endIndex : null];
  }, function(isScrolling) {
    _this.notify(isScrolling);
  }, {
    key: "maybeNotify",
    debug: function debug2() {
      return _this.options.debug;
    },
    initialDeps: [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]
  });
  this.cleanup = function() {
    _this.unsubs.filter(Boolean).forEach(function(d) {
      return d();
    });
    _this.unsubs = [];
    _this.scrollElement = null;
  };
  this._didMount = function() {
    _this.measureElementCache.forEach(_this.observer.observe);
    return function() {
      _this.observer.disconnect();
      _this.cleanup();
    };
  };
  this._willUpdate = function() {
    var scrollElement = _this.options.getScrollElement();
    if (_this.scrollElement !== scrollElement) {
      _this.cleanup();
      _this.scrollElement = scrollElement;
      _this._scrollToOffset(_this.scrollOffset, {
        adjustments: void 0,
        behavior: void 0
      });
      _this.unsubs.push(_this.options.observeElementRect(_this, function(rect) {
        _this.scrollRect = rect;
        _this.maybeNotify();
      }));
      _this.unsubs.push(_this.options.observeElementOffset(_this, function(offset) {
        _this.scrollAdjustments = 0;
        if (_this.scrollOffset === offset) {
          return;
        }
        if (_this.isScrollingTimeoutId !== null) {
          clearTimeout(_this.isScrollingTimeoutId);
          _this.isScrollingTimeoutId = null;
        }
        _this.isScrolling = true;
        _this.scrollDirection = _this.scrollOffset < offset ? "forward" : "backward";
        _this.scrollOffset = offset;
        _this.maybeNotify();
        _this.isScrollingTimeoutId = setTimeout(function() {
          _this.isScrollingTimeoutId = null;
          _this.isScrolling = false;
          _this.scrollDirection = null;
          _this.maybeNotify();
        }, _this.options.scrollingDelay);
      }));
    }
  };
  this.getSize = function() {
    return _this.scrollRect[_this.options.horizontal ? "width" : "height"];
  };
  this.memoOptions = memo2(function() {
    return [_this.options.count, _this.options.paddingStart, _this.options.scrollMargin, _this.options.getItemKey];
  }, function(count2, paddingStart, scrollMargin, getItemKey) {
    _this.pendingMeasuredCacheIndexes = [];
    return {
      count: count2,
      paddingStart,
      scrollMargin,
      getItemKey
    };
  }, {
    key: false
  });
  this.getFurthestMeasurement = function(measurements, index) {
    var furthestMeasurementsFound = /* @__PURE__ */ new Map();
    var furthestMeasurements = /* @__PURE__ */ new Map();
    for (var m = index - 1; m >= 0; m--) {
      var measurement = measurements[m];
      if (furthestMeasurementsFound.has(measurement.lane)) {
        continue;
      }
      var previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);
      if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
        furthestMeasurements.set(measurement.lane, measurement);
      } else if (measurement.end < previousFurthestMeasurement.end) {
        furthestMeasurementsFound.set(measurement.lane, true);
      }
      if (furthestMeasurementsFound.size === _this.options.lanes) {
        break;
      }
    }
    return furthestMeasurements.size === _this.options.lanes ? Array.from(furthestMeasurements.values()).sort(function(a, b) {
      return a.end - b.end;
    })[0] : void 0;
  };
  this.getMeasurements = memo2(function() {
    return [_this.memoOptions(), _this.itemSizeCache];
  }, function(_ref4, itemSizeCache) {
    var count2 = _ref4.count, paddingStart = _ref4.paddingStart, scrollMargin = _ref4.scrollMargin, getItemKey = _ref4.getItemKey;
    var min2 = _this.pendingMeasuredCacheIndexes.length > 0 ? Math.min.apply(Math, _this.pendingMeasuredCacheIndexes) : 0;
    _this.pendingMeasuredCacheIndexes = [];
    var measurements = _this.measurementsCache.slice(0, min2);
    for (var _i2 = min2; _i2 < count2; _i2++) {
      var key = getItemKey(_i2);
      var furthestMeasurement = _this.options.lanes === 1 ? measurements[_i2 - 1] : _this.getFurthestMeasurement(measurements, _i2);
      var start = furthestMeasurement ? furthestMeasurement.end : paddingStart + scrollMargin;
      var measuredSize = itemSizeCache.get(key);
      var size = typeof measuredSize === "number" ? measuredSize : _this.options.estimateSize(_i2);
      var end = start + size;
      var lane = furthestMeasurement ? furthestMeasurement.lane : _i2 % _this.options.lanes;
      measurements[_i2] = {
        index: _i2,
        start,
        size,
        end,
        key,
        lane
      };
    }
    _this.measurementsCache = measurements;
    return measurements;
  }, {
    key: "getMeasurements",
    debug: function debug2() {
      return _this.options.debug;
    }
  });
  this.calculateRange = memo2(function() {
    return [_this.getMeasurements(), _this.getSize(), _this.scrollOffset];
  }, function(measurements, outerSize, scrollOffset) {
    return _this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
      measurements,
      outerSize,
      scrollOffset
    }) : null;
  }, {
    key: "calculateRange",
    debug: function debug2() {
      return _this.options.debug;
    }
  });
  this.getIndexes = memo2(function() {
    return [_this.options.rangeExtractor, _this.calculateRange(), _this.options.overscan, _this.options.count];
  }, function(rangeExtractor, range, overscan, count2) {
    return range === null ? [] : rangeExtractor(_extends3({}, range, {
      overscan,
      count: count2
    }));
  }, {
    key: "getIndexes",
    debug: function debug2() {
      return _this.options.debug;
    }
  });
  this.indexFromElement = function(node) {
    var attributeName = _this.options.indexAttribute;
    var indexStr = node.getAttribute(attributeName);
    if (!indexStr) {
      console.warn("Missing attribute name '" + attributeName + "={index}' on measured element.");
      return -1;
    }
    return parseInt(indexStr, 10);
  };
  this._measureElement = function(node, entry) {
    var item = _this.measurementsCache[_this.indexFromElement(node)];
    if (!item || !node.isConnected) {
      _this.measureElementCache.forEach(function(cached, key) {
        if (cached === node) {
          _this.observer.unobserve(node);
          _this.measureElementCache["delete"](key);
        }
      });
      return;
    }
    var prevNode = _this.measureElementCache.get(item.key);
    if (prevNode !== node) {
      if (prevNode) {
        _this.observer.unobserve(prevNode);
      }
      _this.observer.observe(node);
      _this.measureElementCache.set(item.key, node);
    }
    var measuredItemSize = _this.options.measureElement(node, entry, _this);
    _this.resizeItem(item, measuredItemSize);
  };
  this.resizeItem = function(item, size) {
    var _this$itemSizeCache$g;
    var itemSize = (_this$itemSizeCache$g = _this.itemSizeCache.get(item.key)) != null ? _this$itemSizeCache$g : item.size;
    var delta = size - itemSize;
    if (delta !== 0) {
      if (item.start < _this.scrollOffset) {
        if (_this.options.debug) {
          console.info("correction", delta);
        }
        _this._scrollToOffset(_this.scrollOffset, {
          adjustments: _this.scrollAdjustments += delta,
          behavior: void 0
        });
      }
      _this.pendingMeasuredCacheIndexes.push(item.index);
      _this.itemSizeCache = new Map(_this.itemSizeCache.set(item.key, size));
      _this.notify(false);
    }
  };
  this.measureElement = function(node) {
    if (!node) {
      return;
    }
    _this._measureElement(node, void 0);
  };
  this.getVirtualItems = memo2(function() {
    return [_this.getIndexes(), _this.getMeasurements()];
  }, function(indexes, measurements) {
    var virtualItems = [];
    for (var k = 0, len = indexes.length; k < len; k++) {
      var _i3 = indexes[k];
      var measurement = measurements[_i3];
      virtualItems.push(measurement);
    }
    return virtualItems;
  }, {
    key: "getIndexes",
    debug: function debug2() {
      return _this.options.debug;
    }
  });
  this.getVirtualItemForOffset = function(offset) {
    var measurements = _this.getMeasurements();
    return notUndefined(measurements[findNearestBinarySearch(0, measurements.length - 1, function(index) {
      return notUndefined(measurements[index]).start;
    }, offset)]);
  };
  this.getOffsetForAlignment = function(toOffset, align) {
    var size = _this.getSize();
    if (align === "auto") {
      if (toOffset <= _this.scrollOffset) {
        align = "start";
      } else if (toOffset >= _this.scrollOffset + size) {
        align = "end";
      } else {
        align = "start";
      }
    }
    if (align === "start") {
      toOffset = toOffset;
    } else if (align === "end") {
      toOffset = toOffset - size;
    } else if (align === "center") {
      toOffset = toOffset - size / 2;
    }
    var scrollSizeProp = _this.options.horizontal ? "scrollWidth" : "scrollHeight";
    var scrollSize = _this.scrollElement ? "document" in _this.scrollElement ? _this.scrollElement.document.documentElement[scrollSizeProp] : _this.scrollElement[scrollSizeProp] : 0;
    var maxOffset = scrollSize - _this.getSize();
    return Math.max(Math.min(maxOffset, toOffset), 0);
  };
  this.getOffsetForIndex = function(index, align) {
    if (align === void 0) {
      align = "auto";
    }
    index = Math.max(0, Math.min(index, _this.options.count - 1));
    var measurement = notUndefined(_this.getMeasurements()[index]);
    if (align === "auto") {
      if (measurement.end >= _this.scrollOffset + _this.getSize() - _this.options.scrollPaddingEnd) {
        align = "end";
      } else if (measurement.start <= _this.scrollOffset + _this.options.scrollPaddingStart) {
        align = "start";
      } else {
        return [_this.scrollOffset, align];
      }
    }
    var toOffset = align === "end" ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;
    return [_this.getOffsetForAlignment(toOffset, align), align];
  };
  this.isDynamicMode = function() {
    return _this.measureElementCache.size > 0;
  };
  this.cancelScrollToIndex = function() {
    if (_this.scrollToIndexTimeoutId !== null) {
      clearTimeout(_this.scrollToIndexTimeoutId);
      _this.scrollToIndexTimeoutId = null;
    }
  };
  this.scrollToOffset = function(toOffset, _temp) {
    var _ref5 = _temp === void 0 ? {} : _temp, _ref5$align = _ref5.align, align = _ref5$align === void 0 ? "start" : _ref5$align, behavior = _ref5.behavior;
    _this.cancelScrollToIndex();
    if (behavior === "smooth" && _this.isDynamicMode()) {
      console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
    }
    _this._scrollToOffset(_this.getOffsetForAlignment(toOffset, align), {
      adjustments: void 0,
      behavior
    });
  };
  this.scrollToIndex = function(index, _temp2) {
    var _ref6 = _temp2 === void 0 ? {} : _temp2, _ref6$align = _ref6.align, initialAlign = _ref6$align === void 0 ? "auto" : _ref6$align, behavior = _ref6.behavior;
    index = Math.max(0, Math.min(index, _this.options.count - 1));
    _this.cancelScrollToIndex();
    if (behavior === "smooth" && _this.isDynamicMode()) {
      console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
    }
    var _this$getOffsetForInd = _this.getOffsetForIndex(index, initialAlign), toOffset = _this$getOffsetForInd[0], align = _this$getOffsetForInd[1];
    _this._scrollToOffset(toOffset, {
      adjustments: void 0,
      behavior
    });
    if (behavior !== "smooth" && _this.isDynamicMode()) {
      _this.scrollToIndexTimeoutId = setTimeout(function() {
        _this.scrollToIndexTimeoutId = null;
        var elementInDOM = _this.measureElementCache.has(_this.options.getItemKey(index));
        if (elementInDOM) {
          var _this$getOffsetForInd2 = _this.getOffsetForIndex(index, align), _toOffset = _this$getOffsetForInd2[0];
          if (!approxEqual(_toOffset, _this.scrollOffset)) {
            _this.scrollToIndex(index, {
              align,
              behavior
            });
          }
        } else {
          _this.scrollToIndex(index, {
            align,
            behavior
          });
        }
      });
    }
  };
  this.scrollBy = function(delta, _temp3) {
    var _ref7 = _temp3 === void 0 ? {} : _temp3, behavior = _ref7.behavior;
    _this.cancelScrollToIndex();
    if (behavior === "smooth" && _this.isDynamicMode()) {
      console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");
    }
    _this._scrollToOffset(_this.scrollOffset + delta, {
      adjustments: void 0,
      behavior
    });
  };
  this.getTotalSize = function() {
    var _this$getMeasurements;
    return (((_this$getMeasurements = _this.getMeasurements()[_this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || _this.options.paddingStart) - _this.options.scrollMargin + _this.options.paddingEnd;
  };
  this._scrollToOffset = function(offset, _ref8) {
    var adjustments = _ref8.adjustments, behavior = _ref8.behavior;
    _this.options.scrollToFn(offset, {
      behavior,
      adjustments
    }, _this);
  };
  this.measure = function() {
    _this.itemSizeCache = /* @__PURE__ */ new Map();
    _this.notify(false);
  };
  this.setOptions(_opts);
  this.scrollRect = this.options.initialRect;
  this.scrollOffset = this.options.initialOffset;
  this.measurementsCache = this.options.initialMeasurementsCache;
  this.measurementsCache.forEach(function(item) {
    _this.itemSizeCache.set(item.key, item.size);
  });
  this.maybeNotify();
};
var findNearestBinarySearch = function findNearestBinarySearch2(low, high, getCurrentValue, value) {
  while (low <= high) {
    var middle = (low + high) / 2 | 0;
    var currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange(_ref9) {
  var measurements = _ref9.measurements, outerSize = _ref9.outerSize, scrollOffset = _ref9.scrollOffset;
  var count2 = measurements.length - 1;
  var getOffset = function getOffset2(index) {
    return measurements[index].start;
  };
  var startIndex = findNearestBinarySearch(0, count2, getOffset, scrollOffset);
  var endIndex = startIndex;
  while (endIndex < count2 && measurements[endIndex].end < scrollOffset + outerSize) {
    endIndex++;
  }
  return {
    startIndex,
    endIndex
  };
}

// node_modules/@tanstack/react-virtual/build/lib/index.mjs
var useIsomorphicLayoutEffect = typeof document !== "undefined" ? React2.useLayoutEffect : React2.useEffect;
function useVirtualizerBase(options) {
  var rerender = React2.useReducer(function() {
    return {};
  }, {})[1];
  var resolvedOptions = _extends2({}, options, {
    onChange: function onChange(instance2, sync) {
      if (sync) {
        (0, import_react_dom.flushSync)(rerender);
      } else {
        rerender();
      }
      options.onChange == null || options.onChange(instance2, sync);
    }
  });
  var _React$useState = React2.useState(function() {
    return new Virtualizer(resolvedOptions);
  }), instance = _React$useState[0];
  instance.setOptions(resolvedOptions);
  React2.useEffect(function() {
    return instance._didMount();
  }, []);
  useIsomorphicLayoutEffect(function() {
    return instance._willUpdate();
  });
  return instance;
}
function useVirtualizer(options) {
  return useVirtualizerBase(_extends2({
    observeElementRect,
    observeElementOffset,
    scrollToFn: elementScroll
  }, options));
}

// node_modules/highlight-words/dist/highlight-words.mjs
var IDX = 36;
var HEX = "";
while (IDX--) {
  HEX += IDX.toString(36);
}
function uid(len = 11) {
  let str = "";
  let num = len;
  while (num--) {
    str += HEX[Math.random() * 36 | 0];
  }
  return str;
}
var escapeRegexp = (term) => term.replace(/[|\\{}()[\]^$+*?.-]/g, (char) => `\\${char}`);
var termsToRegExpString = (terms) => terms.replace(/\s{2,}/g, " ").split(" ").join("|");
var regexpQuery = ({
  terms,
  matchExactly = false
}) => {
  if (typeof terms !== "string") {
    throw new TypeError("Expected a string");
  }
  const escapedTerms = escapeRegexp(terms.trim());
  return `(${matchExactly ? escapedTerms : termsToRegExpString(escapedTerms)})`;
};
var buildRegexp = ({
  terms,
  matchExactly = false
}) => {
  try {
    const fromString = /^([/~@;%#'])(.*?)\1([gimsuy]*)$/.exec(terms);
    if (fromString) {
      return new RegExp(fromString[2], fromString[3]);
    }
    return new RegExp(regexpQuery({ terms, matchExactly }), "ig");
  } catch (e) {
    throw new TypeError("Expected terms to be either a string or a RegExp!");
  }
};
var hasProp = (prop) => (obj) => obj !== null && typeof obj === "object" && prop in obj;
var hasMatch = hasProp("match");
var chunkExists = (chunk) => typeof chunk !== "undefined";
function clip({
  curr,
  next,
  prev,
  clipBy = 3
}) {
  const words = curr.text.split(" ");
  const len = words.length;
  if (curr.match || clipBy >= len) {
    return curr.text;
  }
  const ellipsis = "...";
  if (chunkExists(next) && chunkExists(prev) && hasMatch(prev) && hasMatch(next)) {
    if (len > clipBy * 2) {
      return [
        ...words.slice(0, clipBy),
        ellipsis,
        ...words.slice(-clipBy)
      ].join(" ");
    }
    return curr.text;
  }
  if (chunkExists(next) && hasMatch(next)) {
    return [ellipsis, ...words.slice(-clipBy)].join(" ");
  }
  if (chunkExists(prev) && hasMatch(prev)) {
    return [...words.slice(0, clipBy), ellipsis].join(" ");
  }
  return curr.text;
}
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var hasLength = (str) => str.length > 0;
var highlightWords = ({
  text: text2,
  query,
  clipBy,
  matchExactly = false
}) => {
  const safeQuery = typeof query === "string" ? query.trim() : query;
  if (safeQuery === "") {
    return [
      {
        key: uid(),
        text: text2,
        match: false
      }
    ];
  }
  const searchRegexp = buildRegexp({ terms: query, matchExactly });
  return text2.split(searchRegexp).filter(hasLength).map((str) => ({
    // Compose the object for a match
    key: uid(),
    text: str,
    match: matchExactly ? str.toLowerCase() === safeQuery.toLowerCase() : searchRegexp.test(str)
  })).map((chunk, index, chunks) => __spreadValues(__spreadValues({}, chunk), typeof clipBy === "number" && {
    // We only overwrite the text if there is a clip
    text: clip(__spreadProps(__spreadValues(__spreadValues({
      curr: chunk
    }, index < chunks.length - 1 && { next: chunks[index + 1] }), index > 0 && { prev: chunks[index - 1] }), {
      // If this wasn't the first chunk, set the previous chunk
      clipBy
    }))
  }));
};

// node_modules/material-react-table/dist/index.esm.js
init_utils2();

// node_modules/@mui/x-date-pickers/DateTimePicker/DateTimePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React20 = __toESM(require_react());
var import_prop_types9 = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-date-pickers/DesktopDateTimePicker/DesktopDateTimePicker.js
init_extends();
var React18 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-date-pickers/DateTimeField/DateTimeField.js
init_extends();
init_objectWithoutPropertiesLoose();
var React3 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-date-pickers/DateTimeField/useDateTimeField.js
init_extends();
var useDefaultizedDateTimeField = (props) => {
  var _props$ampm, _props$disablePast, _props$disableFuture, _props$format, _props$minDateTime, _props$maxDateTime, _props$minDateTime2, _props$maxDateTime2;
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const ampm = (_props$ampm = props.ampm) != null ? _props$ampm : utils.is12HourCycleInCurrentLocale();
  const defaultFormat = ampm ? utils.formats.keyboardDateTime12h : utils.formats.keyboardDateTime24h;
  return _extends({}, props, {
    disablePast: (_props$disablePast = props.disablePast) != null ? _props$disablePast : false,
    disableFuture: (_props$disableFuture = props.disableFuture) != null ? _props$disableFuture : false,
    format: (_props$format = props.format) != null ? _props$format : defaultFormat,
    disableIgnoringDatePartForTimeValidation: Boolean(props.minDateTime || props.maxDateTime),
    minDate: applyDefaultDate(utils, (_props$minDateTime = props.minDateTime) != null ? _props$minDateTime : props.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, (_props$maxDateTime = props.maxDateTime) != null ? _props$maxDateTime : props.maxDate, defaultDates.maxDate),
    minTime: (_props$minDateTime2 = props.minDateTime) != null ? _props$minDateTime2 : props.minTime,
    maxTime: (_props$maxDateTime2 = props.maxDateTime) != null ? _props$maxDateTime2 : props.maxTime
  });
};
var useDateTimeField = ({
  props: inProps,
  inputRef
}) => {
  const props = useDefaultizedDateTimeField(inProps);
  const {
    forwardedProps,
    internalProps
  } = splitFieldInternalAndForwardedProps(props, "date-time");
  return useField({
    inputRef,
    forwardedProps,
    internalProps,
    valueManager: singleItemValueManager,
    fieldValueManager: singleItemFieldValueManager,
    validator: validateDateTime,
    valueType: "date-time"
  });
};

// node_modules/@mui/x-date-pickers/DateTimeField/DateTimeField.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var _excluded = ["components", "componentsProps", "slots", "slotProps", "InputProps", "inputProps"];
var _excluded2 = ["inputRef"];
var _excluded3 = ["ref", "onPaste", "onKeyDown", "inputMode", "readOnly", "clearable", "onClear"];
var DateTimeField = React3.forwardRef(function DateTimeField2(inProps, ref) {
  var _ref, _slots$textField, _slotProps$textField;
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiDateTimeField"
  });
  const {
    components,
    componentsProps,
    slots,
    slotProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded);
  const ownerState = themeProps;
  const TextField = (_ref = (_slots$textField = slots == null ? void 0 : slots.textField) != null ? _slots$textField : components == null ? void 0 : components.TextField) != null ? _ref : TextField_default;
  const _useSlotProps = useSlotProps({
    elementType: TextField,
    externalSlotProps: (_slotProps$textField = slotProps == null ? void 0 : slotProps.textField) != null ? _slotProps$textField : componentsProps == null ? void 0 : componentsProps.textField,
    externalForwardedProps: other,
    ownerState
  }), {
    inputRef: externalInputRef
  } = _useSlotProps, textFieldProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2);
  textFieldProps.inputProps = _extends({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends({}, InputProps, textFieldProps.InputProps);
  const _useDateTimeField = useDateTimeField({
    props: textFieldProps,
    inputRef: externalInputRef
  }), {
    ref: inputRef,
    onPaste,
    onKeyDown,
    inputMode,
    readOnly,
    clearable,
    onClear
  } = _useDateTimeField, fieldProps = _objectWithoutPropertiesLoose(_useDateTimeField, _excluded3);
  const {
    InputProps: ProcessedInputProps,
    fieldProps: processedFieldProps
  } = useClearableField({
    onClear,
    clearable,
    fieldProps,
    InputProps: fieldProps.InputProps,
    slots,
    slotProps,
    components,
    componentsProps
  });
  return (0, import_jsx_runtime.jsx)(TextField, _extends({
    ref
  }, processedFieldProps, {
    InputProps: _extends({}, ProcessedInputProps, {
      readOnly
    }),
    inputProps: _extends({}, fieldProps.inputProps, {
      inputMode,
      onPaste,
      onKeyDown,
      ref: inputRef
    })
  }));
});
true ? DateTimeField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: import_prop_types.default.bool,
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: import_prop_types.default.bool,
  className: import_prop_types.default.string,
  /**
   * If `true`, a clear button will be shown in the field allowing value clearing.
   * @default false
   */
  clearable: import_prop_types.default.bool,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: import_prop_types.default.oneOf(["error", "info", "primary", "secondary", "success", "warning"]),
  component: import_prop_types.default.elementType,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types.default.object,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types.default.any,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types.default.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: import_prop_types.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: import_prop_types.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types.default.oneOf(["dense", "spacious"]),
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: import_prop_types.default.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: import_prop_types.default.bool,
  /**
   * The helper text content.
   */
  helperText: import_prop_types.default.node,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: import_prop_types.default.bool,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: import_prop_types.default.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: import_prop_types.default.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: import_prop_types.default.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: import_prop_types.default.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types.default.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: import_prop_types.default.oneOf(["dense", "none", "normal"]),
  /**
   * Maximal selectable date.
   */
  maxDate: import_prop_types.default.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: import_prop_types.default.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types.default.any,
  /**
   * Minimal selectable date.
   */
  minDate: import_prop_types.default.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: import_prop_types.default.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types.default.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types.default.number,
  /**
   * Name attribute of the `input` element.
   */
  name: import_prop_types.default.string,
  onBlur: import_prop_types.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types.default.func,
  /**
   * Callback fired when the clear button is clicked.
   */
  onClear: import_prop_types.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types.default.func,
  onFocus: import_prop_types.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types.default.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: import_prop_types.default.bool,
  /**
   * The date used to generate a part of the new value that is not present in the format when both `value` and `defaultValue` are empty.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: import_prop_types.default.any,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: import_prop_types.default.bool,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types.default.number, import_prop_types.default.shape({
    endIndex: import_prop_types.default.number.isRequired,
    startIndex: import_prop_types.default.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: import_prop_types.default.func,
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (e.g. when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: import_prop_types.default.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: import_prop_types.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types.default.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: import_prop_types.default.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning nÂ°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning nÂ°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning nÂ°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default `false`
   */
  shouldRespectLeadingZeros: import_prop_types.default.bool,
  /**
   * The size of the component.
   */
  size: import_prop_types.default.oneOf(["medium", "small"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types.default.object,
  style: import_prop_types.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types.default.string,
  /**
   * The ref object used to imperatively interact with the field.
   */
  unstableFieldRef: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types.default.any,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: import_prop_types.default.oneOf(["filled", "outlined", "standard"])
} : void 0;

// node_modules/@mui/x-date-pickers/DateTimePicker/shared.js
init_extends();
var React6 = __toESM(require_react());

// node_modules/@mui/x-date-pickers/DateTimePicker/DateTimePickerTabs.js
var React4 = __toESM(require_react());
init_clsx();
var import_prop_types2 = __toESM(require_prop_types());
init_composeClasses();

// node_modules/@mui/x-date-pickers/DateTimePicker/dateTimePickerTabsClasses.js
init_utils();
function getDateTimePickerTabsUtilityClass(slot) {
  return generateUtilityClass("MuiDateTimePickerTabs", slot);
}
var dateTimePickerTabsClasses = generateUtilityClasses("MuiDateTimePickerTabs", ["root"]);

// node_modules/@mui/x-date-pickers/DateTimePicker/DateTimePickerTabs.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var viewToTab = (view) => {
  if (isDatePickerView(view)) {
    return "date";
  }
  return "time";
};
var tabToView = (tab) => {
  if (tab === "date") {
    return "day";
  }
  return "hours";
};
var useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getDateTimePickerTabsUtilityClass, classes);
};
var DateTimePickerTabsRoot = styled_default(Tabs_default, {
  name: "MuiDateTimePickerTabs",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  boxShadow: `0 -1px 0 0 inset ${(theme.vars || theme).palette.divider}`,
  "&:last-child": {
    boxShadow: `0 1px 0 0 inset ${(theme.vars || theme).palette.divider}`,
    [`& .${tabsClasses_default.indicator}`]: {
      bottom: "auto",
      top: 0
    }
  }
}));
var DateTimePickerTabs = function DateTimePickerTabs2(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateTimePickerTabs"
  });
  const {
    dateIcon = (0, import_jsx_runtime2.jsx)(DateRangeIcon, {}),
    onViewChange,
    timeIcon = (0, import_jsx_runtime2.jsx)(TimeIcon, {}),
    view,
    hidden = typeof window === "undefined" || window.innerHeight < 667,
    className
  } = props;
  const localeText = useLocaleText();
  const classes = useUtilityClasses(props);
  const handleChange = (event, value) => {
    onViewChange(tabToView(value));
  };
  if (hidden) {
    return null;
  }
  return (0, import_jsx_runtime3.jsxs)(DateTimePickerTabsRoot, {
    ownerState: props,
    variant: "fullWidth",
    value: viewToTab(view),
    onChange: handleChange,
    className: clsx_default(className, classes.root),
    children: [(0, import_jsx_runtime2.jsx)(Tab_default, {
      value: "date",
      "aria-label": localeText.dateTableLabel,
      icon: (0, import_jsx_runtime2.jsx)(React4.Fragment, {
        children: dateIcon
      })
    }), (0, import_jsx_runtime2.jsx)(Tab_default, {
      value: "time",
      "aria-label": localeText.timeTableLabel,
      icon: (0, import_jsx_runtime2.jsx)(React4.Fragment, {
        children: timeIcon
      })
    })]
  });
};
true ? DateTimePickerTabs.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types2.default.object,
  className: import_prop_types2.default.string,
  /**
   * Date tab icon.
   * @default DateRange
   */
  dateIcon: import_prop_types2.default.node,
  /**
   * Toggles visibility of the tabs allowing view switching.
   * @default `window.innerHeight < 667` for `DesktopDateTimePicker` and `MobileDateTimePicker`, `displayStaticWrapperAs === 'desktop'` for `StaticDateTimePicker`
   */
  hidden: import_prop_types2.default.bool,
  /**
   * Callback called when a tab is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: import_prop_types2.default.func.isRequired,
  /**
   * Time tab icon.
   * @default Time
   */
  timeIcon: import_prop_types2.default.node,
  /**
   * Currently visible picker view.
   */
  view: import_prop_types2.default.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]).isRequired
} : void 0;

// node_modules/@mui/x-date-pickers/DateTimePicker/DateTimePickerToolbar.js
init_objectWithoutPropertiesLoose();
init_extends();
var React5 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-date-pickers/DateTimePicker/dateTimePickerToolbarClasses.js
init_utils();
function getDateTimePickerToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiDateTimePickerToolbar", slot);
}
var dateTimePickerToolbarClasses = generateUtilityClasses("MuiDateTimePickerToolbar", ["root", "dateContainer", "timeContainer", "timeDigitsContainer", "separator", "timeLabelReverse", "ampmSelection", "ampmLandscape", "ampmLabel"]);

// node_modules/@mui/x-date-pickers/DateTimePicker/DateTimePickerToolbar.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var _excluded4 = ["ampm", "ampmInClock", "value", "onChange", "view", "isLandscape", "onViewChange", "toolbarFormat", "toolbarPlaceholder", "views", "disabled", "readOnly", "toolbarVariant"];
var useUtilityClasses2 = (ownerState) => {
  const {
    classes,
    theme,
    isLandscape
  } = ownerState;
  const slots = {
    root: ["root"],
    dateContainer: ["dateContainer"],
    timeContainer: ["timeContainer", theme.direction === "rtl" && "timeLabelReverse"],
    timeDigitsContainer: ["timeDigitsContainer", theme.direction === "rtl" && "timeLabelReverse"],
    separator: ["separator"],
    ampmSelection: ["ampmSelection", isLandscape && "ampmLandscape"],
    ampmLabel: ["ampmLabel"]
  };
  return composeClasses(slots, getDateTimePickerToolbarUtilityClass, classes);
};
var DateTimePickerToolbarRoot = styled_default(PickersToolbar, {
  name: "MuiDateTimePickerToolbar",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme,
  ownerState
}) => ({
  paddingLeft: ownerState.toolbarVariant === "desktop" && !ownerState.isLandscape ? 24 : 16,
  paddingRight: ownerState.toolbarVariant === "desktop" && !ownerState.isLandscape ? 0 : 16,
  borderBottom: ownerState.toolbarVariant === "desktop" ? `1px solid ${(theme.vars || theme).palette.divider}` : void 0,
  borderRight: ownerState.toolbarVariant === "desktop" && ownerState.isLandscape ? `1px solid ${(theme.vars || theme).palette.divider}` : void 0,
  justifyContent: "space-around",
  position: "relative"
}));
DateTimePickerToolbarRoot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  as: import_prop_types3.default.elementType,
  classes: import_prop_types3.default.object,
  className: import_prop_types3.default.string,
  isLandscape: import_prop_types3.default.bool.isRequired,
  isMobileKeyboardViewOpen: import_prop_types3.default.bool,
  landscapeDirection: import_prop_types3.default.oneOf(["column", "row"]),
  ownerState: import_prop_types3.default.object.isRequired,
  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object]),
  toggleMobileKeyboardView: import_prop_types3.default.func,
  toolbarTitle: import_prop_types3.default.node,
  viewType: import_prop_types3.default.oneOf(["date", "time"])
};
var DateTimePickerToolbarDateContainer = styled_default("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "DateContainer",
  overridesResolver: (props, styles) => styles.dateContainer
})({
  display: "flex",
  flexDirection: "column",
  alignItems: "flex-start"
});
var DateTimePickerToolbarTimeContainer = styled_default("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "TimeContainer",
  overridesResolver: (props, styles) => styles.timeContainer
})(({
  theme,
  ownerState
}) => {
  const direction = ownerState.isLandscape && ownerState.toolbarVariant !== "desktop" ? "column" : "row";
  return _extends({
    display: "flex",
    flexDirection: direction
  }, ownerState.toolbarVariant === "desktop" && _extends({}, !ownerState.isLandscape && {
    gap: 9,
    marginRight: 4,
    alignSelf: "flex-end"
  }), theme.direction === "rtl" && {
    flexDirection: `${direction}-reverse`
  });
});
var DateTimePickerToolbarTimeDigitsContainer = styled_default("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "TimeDigitsContainer",
  overridesResolver: (props, styles) => styles.timeDigitsContainer
})(({
  theme,
  ownerState
}) => _extends({
  display: "flex"
}, ownerState.toolbarVariant === "desktop" && {
  gap: 1.5
}, theme.direction === "rtl" && {
  flexDirection: "row-reverse"
}));
DateTimePickerToolbarTimeContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  as: import_prop_types3.default.elementType,
  ownerState: import_prop_types3.default.object.isRequired,
  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object])
};
var DateTimePickerToolbarSeparator = styled_default(PickersToolbarText, {
  name: "MuiDateTimePickerToolbar",
  slot: "Separator",
  overridesResolver: (props, styles) => styles.separator
})(({
  ownerState
}) => ({
  margin: ownerState.toolbarVariant === "desktop" ? 0 : "0 4px 0 2px",
  cursor: "default"
}));
var DateTimePickerToolbarAmPmSelection = styled_default("div", {
  name: "MuiDateTimePickerToolbar",
  slot: "AmPmSelection",
  overridesResolver: (props, styles) => [{
    [`.${dateTimePickerToolbarClasses.ampmLabel}`]: styles.ampmLabel
  }, {
    [`&.${dateTimePickerToolbarClasses.ampmLandscape}`]: styles.ampmLandscape
  }, styles.ampmSelection]
})(({
  ownerState
}) => _extends({
  display: "flex",
  flexDirection: "column",
  marginRight: "auto",
  marginLeft: 12
}, ownerState.isLandscape && {
  margin: "4px 0 auto",
  flexDirection: "row",
  justifyContent: "space-around",
  width: "100%"
}, {
  [`& .${dateTimePickerToolbarClasses.ampmLabel}`]: {
    fontSize: 17
  }
}));
function DateTimePickerToolbar(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateTimePickerToolbar"
  });
  const {
    ampm,
    ampmInClock,
    value,
    onChange,
    view,
    isLandscape,
    onViewChange,
    toolbarFormat,
    toolbarPlaceholder = "â€“â€“",
    views,
    disabled,
    readOnly,
    toolbarVariant = "mobile"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
  const ownerState = props;
  const utils = useUtils();
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(value, ampm, onChange);
  const showAmPmControl = Boolean(ampm && !ampmInClock);
  const isDesktop = toolbarVariant === "desktop";
  const localeText = useLocaleText();
  const theme = useTheme();
  const classes = useUtilityClasses2(_extends({}, ownerState, {
    theme
  }));
  const formatHours = (time) => ampm ? utils.format(time, "hours12h") : utils.format(time, "hours24h");
  const dateText = React5.useMemo(() => {
    if (!value) {
      return toolbarPlaceholder;
    }
    if (toolbarFormat) {
      return utils.formatByString(value, toolbarFormat);
    }
    return utils.format(value, "shortDate");
  }, [value, toolbarFormat, toolbarPlaceholder, utils]);
  return (0, import_jsx_runtime5.jsxs)(DateTimePickerToolbarRoot, _extends({
    toolbarTitle: localeText.dateTimePickerToolbarTitle,
    isLandscape,
    className: classes.root
  }, other, {
    ownerState,
    children: [(0, import_jsx_runtime5.jsxs)(DateTimePickerToolbarDateContainer, {
      className: classes.dateContainer,
      ownerState,
      children: [views.includes("year") && (0, import_jsx_runtime4.jsx)(PickersToolbarButton, {
        tabIndex: -1,
        variant: "subtitle1",
        onClick: () => onViewChange("year"),
        selected: view === "year",
        value: value ? utils.format(value, "year") : "â€“"
      }), views.includes("day") && (0, import_jsx_runtime4.jsx)(PickersToolbarButton, {
        tabIndex: -1,
        variant: isDesktop ? "h5" : "h4",
        onClick: () => onViewChange("day"),
        selected: view === "day",
        value: dateText
      })]
    }), (0, import_jsx_runtime5.jsxs)(DateTimePickerToolbarTimeContainer, {
      className: classes.timeContainer,
      ownerState,
      children: [(0, import_jsx_runtime5.jsxs)(DateTimePickerToolbarTimeDigitsContainer, {
        className: classes.timeDigitsContainer,
        ownerState,
        children: [views.includes("hours") && (0, import_jsx_runtime4.jsx)(PickersToolbarButton, {
          variant: isDesktop ? "h5" : "h3",
          width: isDesktop && !isLandscape ? MULTI_SECTION_CLOCK_SECTION_WIDTH : void 0,
          onClick: () => onViewChange("hours"),
          selected: view === "hours",
          value: value ? formatHours(value) : "--"
        }), views.includes("minutes") && (0, import_jsx_runtime5.jsxs)(React5.Fragment, {
          children: [(0, import_jsx_runtime4.jsx)(DateTimePickerToolbarSeparator, {
            variant: isDesktop ? "h5" : "h3",
            value: ":",
            className: classes.separator,
            ownerState
          }), (0, import_jsx_runtime4.jsx)(PickersToolbarButton, {
            variant: isDesktop ? "h5" : "h3",
            width: isDesktop && !isLandscape ? MULTI_SECTION_CLOCK_SECTION_WIDTH : void 0,
            onClick: () => onViewChange("minutes"),
            selected: view === "minutes",
            value: value ? utils.format(value, "minutes") : "--"
          })]
        }), views.includes("seconds") && (0, import_jsx_runtime5.jsxs)(React5.Fragment, {
          children: [(0, import_jsx_runtime4.jsx)(DateTimePickerToolbarSeparator, {
            variant: isDesktop ? "h5" : "h3",
            value: ":",
            className: classes.separator,
            ownerState
          }), (0, import_jsx_runtime4.jsx)(PickersToolbarButton, {
            variant: isDesktop ? "h5" : "h3",
            width: isDesktop && !isLandscape ? MULTI_SECTION_CLOCK_SECTION_WIDTH : void 0,
            onClick: () => onViewChange("seconds"),
            selected: view === "seconds",
            value: value ? utils.format(value, "seconds") : "--"
          })]
        })]
      }), showAmPmControl && !isDesktop && (0, import_jsx_runtime5.jsxs)(DateTimePickerToolbarAmPmSelection, {
        className: classes.ampmSelection,
        ownerState,
        children: [(0, import_jsx_runtime4.jsx)(PickersToolbarButton, {
          variant: "subtitle2",
          selected: meridiemMode === "am",
          typographyClassName: classes.ampmLabel,
          value: formatMeridiem(utils, "am"),
          onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
          disabled
        }), (0, import_jsx_runtime4.jsx)(PickersToolbarButton, {
          variant: "subtitle2",
          selected: meridiemMode === "pm",
          typographyClassName: classes.ampmLabel,
          value: formatMeridiem(utils, "pm"),
          onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
          disabled
        })]
      }), ampm && isDesktop && (0, import_jsx_runtime4.jsx)(PickersToolbarButton, {
        variant: "h5",
        onClick: () => onViewChange("meridiem"),
        selected: view === "meridiem",
        value: value && meridiemMode ? formatMeridiem(utils, meridiemMode) : "--",
        width: MULTI_SECTION_CLOCK_SECTION_WIDTH
      })]
    })]
  }));
}
true ? DateTimePickerToolbar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  ampm: import_prop_types3.default.bool,
  ampmInClock: import_prop_types3.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types3.default.object,
  /**
   * className applied to the root component.
   */
  className: import_prop_types3.default.string,
  disabled: import_prop_types3.default.bool,
  /**
   * If `true`, show the toolbar even in desktop mode.
   * @default `true` for Desktop, `false` for Mobile.
   */
  hidden: import_prop_types3.default.bool,
  isLandscape: import_prop_types3.default.bool.isRequired,
  onChange: import_prop_types3.default.func.isRequired,
  /**
   * Callback called when a toolbar is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: import_prop_types3.default.func.isRequired,
  readOnly: import_prop_types3.default.bool,
  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object]),
  titleId: import_prop_types3.default.string,
  /**
   * Toolbar date format.
   */
  toolbarFormat: import_prop_types3.default.string,
  /**
   * Toolbar value placeholderâ€”it is displayed when the value is empty.
   * @default "â€“â€“"
   */
  toolbarPlaceholder: import_prop_types3.default.node,
  toolbarVariant: import_prop_types3.default.oneOf(["desktop", "mobile"]),
  value: import_prop_types3.default.any,
  /**
   * Currently visible picker view.
   */
  view: import_prop_types3.default.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]).isRequired,
  views: import_prop_types3.default.arrayOf(import_prop_types3.default.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]).isRequired).isRequired
} : void 0;

// node_modules/@mui/x-date-pickers/DateTimePicker/shared.js
function useDateTimePickerDefaultizedProps(props, name) {
  var _themeProps$ampm, _themeProps$slots, _themeProps$slotProps, _themeProps$orientati, _themeProps$disableIg, _themeProps$disableFu, _themeProps$disablePa, _themeProps$minDateTi, _themeProps$maxDateTi, _themeProps$minDateTi2, _themeProps$maxDateTi2;
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const themeProps = useThemeProps({
    props,
    name
  });
  const ampm = (_themeProps$ampm = themeProps.ampm) != null ? _themeProps$ampm : utils.is12HourCycleInCurrentLocale();
  const localeText = React6.useMemo(() => {
    var _themeProps$localeTex;
    if (((_themeProps$localeTex = themeProps.localeText) == null ? void 0 : _themeProps$localeTex.toolbarTitle) == null) {
      return themeProps.localeText;
    }
    return _extends({}, themeProps.localeText, {
      dateTimePickerToolbarTitle: themeProps.localeText.toolbarTitle
    });
  }, [themeProps.localeText]);
  const slots = (_themeProps$slots = themeProps.slots) != null ? _themeProps$slots : uncapitalizeObjectKeys(themeProps.components);
  const slotProps = (_themeProps$slotProps = themeProps.slotProps) != null ? _themeProps$slotProps : themeProps.componentsProps;
  return _extends({}, themeProps, applyDefaultViewProps({
    views: themeProps.views,
    openTo: themeProps.openTo,
    defaultViews: ["year", "day", "hours", "minutes"],
    defaultOpenTo: "day"
  }), {
    ampm,
    localeText,
    orientation: (_themeProps$orientati = themeProps.orientation) != null ? _themeProps$orientati : "portrait",
    // TODO: Remove from public API
    disableIgnoringDatePartForTimeValidation: (_themeProps$disableIg = themeProps.disableIgnoringDatePartForTimeValidation) != null ? _themeProps$disableIg : Boolean(themeProps.minDateTime || themeProps.maxDateTime || // allow time clock to correctly check time validity: https://github.com/mui/mui-x/issues/8520
    themeProps.disablePast || themeProps.disableFuture),
    disableFuture: (_themeProps$disableFu = themeProps.disableFuture) != null ? _themeProps$disableFu : false,
    disablePast: (_themeProps$disablePa = themeProps.disablePast) != null ? _themeProps$disablePa : false,
    minDate: applyDefaultDate(utils, (_themeProps$minDateTi = themeProps.minDateTime) != null ? _themeProps$minDateTi : themeProps.minDate, defaultDates.minDate),
    maxDate: applyDefaultDate(utils, (_themeProps$maxDateTi = themeProps.maxDateTime) != null ? _themeProps$maxDateTi : themeProps.maxDate, defaultDates.maxDate),
    minTime: (_themeProps$minDateTi2 = themeProps.minDateTime) != null ? _themeProps$minDateTi2 : themeProps.minTime,
    maxTime: (_themeProps$maxDateTi2 = themeProps.maxDateTime) != null ? _themeProps$maxDateTi2 : themeProps.maxTime,
    slots: _extends({
      toolbar: DateTimePickerToolbar,
      tabs: DateTimePickerTabs
    }, slots),
    slotProps: _extends({}, slotProps, {
      toolbar: _extends({
        ampm
      }, slotProps == null ? void 0 : slotProps.toolbar)
    })
  });
}

// node_modules/@mui/x-date-pickers/dateTimeViewRenderers/dateTimeViewRenderers.js
init_extends();
var React17 = __toESM(require_react());

// node_modules/@mui/x-date-pickers/MultiSectionDigitalClock/MultiSectionDigitalClock.js
init_extends();
init_objectWithoutPropertiesLoose();
var React9 = __toESM(require_react());
init_clsx();
var import_prop_types4 = __toESM(require_prop_types());
init_useEventCallback();
init_composeClasses();

// node_modules/@mui/x-date-pickers/MultiSectionDigitalClock/multiSectionDigitalClockClasses.js
init_generateUtilityClass();
init_generateUtilityClasses();
function getMultiSectionDigitalClockUtilityClass(slot) {
  return generateUtilityClass("MuiMultiSectionDigitalClock", slot);
}
var multiSectionDigitalClockClasses = generateUtilityClasses("MuiMultiSectionDigitalClock", ["root"]);

// node_modules/@mui/x-date-pickers/MultiSectionDigitalClock/MultiSectionDigitalClockSection.js
init_extends();
init_objectWithoutPropertiesLoose();
var React7 = __toESM(require_react());
init_clsx();
init_composeClasses();
init_useForkRef();

// node_modules/@mui/x-date-pickers/MultiSectionDigitalClock/multiSectionDigitalClockSectionClasses.js
init_generateUtilityClass();
init_generateUtilityClasses();
function getMultiSectionDigitalClockSectionUtilityClass(slot) {
  return generateUtilityClass("MuiMultiSectionDigitalClockSection", slot);
}
var multiSectionDigitalClockSectionClasses = generateUtilityClasses("MuiMultiSectionDigitalClockSection", ["root", "item"]);

// node_modules/@mui/x-date-pickers/MultiSectionDigitalClock/MultiSectionDigitalClockSection.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var _excluded5 = ["autoFocus", "onChange", "className", "disabled", "readOnly", "items", "active", "slots", "slotProps", "skipDisabled"];
var useUtilityClasses3 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    item: ["item"]
  };
  return composeClasses(slots, getMultiSectionDigitalClockSectionUtilityClass, classes);
};
var MultiSectionDigitalClockSectionRoot = styled_default(MenuList_default, {
  name: "MuiMultiSectionDigitalClockSection",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme,
  ownerState
}) => ({
  maxHeight: DIGITAL_CLOCK_VIEW_HEIGHT,
  width: 56,
  padding: 0,
  overflow: "hidden",
  "@media (prefers-reduced-motion: no-preference)": {
    scrollBehavior: ownerState.alreadyRendered ? "smooth" : "auto"
  },
  "@media (pointer: fine)": {
    "&:hover": {
      overflowY: "auto"
    }
  },
  "@media (pointer: none), (pointer: coarse)": {
    overflowY: "auto"
  },
  "&:not(:first-of-type)": {
    borderLeft: `1px solid ${(theme.vars || theme).palette.divider}`
  },
  "&:after": {
    display: "block",
    content: '""',
    // subtracting the height of one item, extra margin and borders to make sure the max height is correct
    height: "calc(100% - 40px - 6px)"
  }
}));
var MultiSectionDigitalClockSectionItem = styled_default(MenuItem_default, {
  name: "MuiMultiSectionDigitalClockSection",
  slot: "Item",
  overridesResolver: (_, styles) => styles.item
})(({
  theme
}) => ({
  padding: 8,
  margin: "2px 4px",
  width: MULTI_SECTION_CLOCK_SECTION_WIDTH,
  justifyContent: "center",
  "&:first-of-type": {
    marginTop: 4
  },
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
  },
  "&.Mui-selected": {
    backgroundColor: (theme.vars || theme).palette.primary.main,
    color: (theme.vars || theme).palette.primary.contrastText,
    "&:focus-visible, &:hover": {
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  },
  "&.Mui-focusVisible": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity)
  }
}));
var MultiSectionDigitalClockSection = React7.forwardRef(function MultiSectionDigitalClockSection2(inProps, ref) {
  var _slots$digitalClockSe;
  const containerRef = React7.useRef(null);
  const handleRef = useForkRef(ref, containerRef);
  const previousActive = React7.useRef(null);
  const props = useThemeProps({
    props: inProps,
    name: "MuiMultiSectionDigitalClockSection"
  });
  const {
    autoFocus,
    onChange,
    className,
    disabled,
    readOnly,
    items,
    active,
    slots,
    slotProps,
    skipDisabled
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const ownerState = React7.useMemo(() => _extends({}, props, {
    alreadyRendered: !!containerRef.current
  }), [props]);
  const classes = useUtilityClasses3(ownerState);
  const DigitalClockSectionItem = (_slots$digitalClockSe = slots == null ? void 0 : slots.digitalClockSectionItem) != null ? _slots$digitalClockSe : MultiSectionDigitalClockSectionItem;
  React7.useEffect(() => {
    if (containerRef.current === null) {
      return;
    }
    const activeItem = containerRef.current.querySelector('[role="option"][aria-selected="true"]');
    if (active && autoFocus && activeItem) {
      activeItem.focus();
    }
    if (!activeItem || previousActive.current === activeItem) {
      return;
    }
    previousActive.current = activeItem;
    const offsetTop = activeItem.offsetTop;
    containerRef.current.scrollTop = offsetTop - 4;
  });
  return (0, import_jsx_runtime6.jsx)(MultiSectionDigitalClockSectionRoot, _extends({
    ref: handleRef,
    className: clsx_default(classes.root, className),
    ownerState,
    autoFocusItem: autoFocus && active,
    role: "listbox"
  }, other, {
    children: items.map((option) => {
      var _option$isDisabled, _option$isDisabled2;
      if (skipDisabled && (_option$isDisabled = option.isDisabled) != null && _option$isDisabled.call(option, option.value)) {
        return null;
      }
      const isSelected = option.isSelected(option.value);
      return (0, import_jsx_runtime6.jsx)(DigitalClockSectionItem, _extends({
        onClick: () => !readOnly && onChange(option.value),
        selected: isSelected,
        disabled: disabled || ((_option$isDisabled2 = option.isDisabled) == null ? void 0 : _option$isDisabled2.call(option, option.value)),
        disableRipple: readOnly,
        role: "option",
        "aria-disabled": readOnly,
        "aria-label": option.ariaLabel,
        "aria-selected": isSelected,
        className: classes.item
      }, slotProps == null ? void 0 : slotProps.digitalClockSectionItem, {
        children: option.label
      }), option.label);
    })
  }));
});

// node_modules/@mui/x-date-pickers/MultiSectionDigitalClock/MultiSectionDigitalClock.utils.js
var getHourSectionOptions = ({
  now,
  value,
  utils,
  ampm,
  isDisabled,
  resolveAriaLabel,
  timeStep
}) => {
  const currentHours = value ? utils.getHours(value) : null;
  const result = [];
  const isSelected = (hour) => {
    if (currentHours === null) {
      return false;
    }
    if (ampm) {
      if (hour === 12) {
        return currentHours === 12 || currentHours === 0;
      }
      return currentHours === hour || currentHours - 12 === hour;
    }
    return currentHours === hour;
  };
  const endHour = ampm ? 11 : 23;
  for (let hour = 0; hour <= endHour; hour += timeStep) {
    let label = utils.format(utils.setHours(now, hour), ampm ? "hours12h" : "hours24h");
    const ariaLabel = resolveAriaLabel(parseInt(label, 10).toString());
    label = utils.formatNumber(label);
    result.push({
      value: hour,
      label,
      isSelected,
      isDisabled,
      ariaLabel
    });
  }
  return result;
};
var getTimeSectionOptions = ({
  value,
  utils,
  isDisabled,
  timeStep,
  resolveLabel,
  resolveAriaLabel,
  hasValue = true
}) => {
  const isSelected = (timeValue) => {
    if (value === null) {
      return false;
    }
    return hasValue && value === timeValue;
  };
  return [...Array.from({
    length: Math.ceil(60 / timeStep)
  }, (_, index) => {
    const timeValue = timeStep * index;
    return {
      value: timeValue,
      label: utils.formatNumber(resolveLabel(timeValue)),
      isDisabled,
      isSelected,
      ariaLabel: resolveAriaLabel(timeValue.toString())
    };
  })];
};

// node_modules/@mui/x-date-pickers/internals/hooks/useClockReferenceDate.js
var React8 = __toESM(require_react());
var useClockReferenceDate = ({
  value,
  referenceDate: referenceDateProp,
  utils,
  props,
  timezone
}) => {
  const referenceDate = React8.useMemo(
    () => singleItemValueManager.getInitialReferenceValue({
      value,
      utils,
      props,
      referenceDate: referenceDateProp,
      granularity: SECTION_TYPE_GRANULARITY.day,
      timezone,
      getTodayDate: () => getTodayDate(utils, timezone, "date")
    }),
    // We only want to compute the reference date on mount.
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  return value != null ? value : referenceDate;
};

// node_modules/@mui/x-date-pickers/MultiSectionDigitalClock/MultiSectionDigitalClock.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var _excluded6 = ["ampm", "timeSteps", "autoFocus", "components", "componentsProps", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableClock", "shouldDisableTime", "onChange", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "skipDisabled", "timezone"];
var useUtilityClasses4 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getMultiSectionDigitalClockUtilityClass, classes);
};
var MultiSectionDigitalClockRoot = styled_default(PickerViewRoot, {
  name: "MuiMultiSectionDigitalClock",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  display: "flex",
  flexDirection: "row",
  width: "100%",
  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
}));
var MultiSectionDigitalClock = React9.forwardRef(function MultiSectionDigitalClock2(inProps, ref) {
  const utils = useUtils();
  const props = useThemeProps({
    props: inProps,
    name: "MuiMultiSectionDigitalClock"
  });
  const {
    ampm = utils.is12HourCycleInCurrentLocale(),
    timeSteps: inTimeSteps,
    autoFocus,
    components,
    componentsProps,
    slots,
    slotProps,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableIgnoringDatePartForTimeValidation = false,
    maxTime,
    minTime,
    disableFuture,
    disablePast,
    minutesStep = 1,
    shouldDisableClock,
    shouldDisableTime,
    onChange,
    view: inView,
    views: inViews = ["hours", "minutes"],
    openTo,
    onViewChange,
    focusedView: inFocusedView,
    onFocusedViewChange,
    className,
    disabled,
    readOnly,
    skipDisabled = false,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
  const {
    value,
    handleValueChange: handleRawValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "MultiSectionDigitalClock",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const localeText = useLocaleText();
  const now = useNow(timezone);
  const timeSteps = React9.useMemo(() => _extends({
    hours: 1,
    minutes: 5,
    seconds: 5
  }, inTimeSteps), [inTimeSteps]);
  const valueOrReferenceDate = useClockReferenceDate({
    value,
    referenceDate: referenceDateProp,
    utils,
    props,
    timezone
  });
  const handleValueChange = useEventCallback_default((newValue, selectionState, selectedView) => handleRawValueChange(newValue, selectionState, selectedView));
  const views = React9.useMemo(() => {
    if (!ampm || !inViews.includes("hours")) {
      return inViews;
    }
    return inViews.includes("meridiem") ? inViews : [...inViews, "meridiem"];
  }, [ampm, inViews]);
  const {
    view,
    setValueAndGoToNextView,
    focusedView
  } = useViews({
    view: inView,
    views,
    openTo,
    onViewChange,
    onChange: handleValueChange,
    focusedView: inFocusedView,
    onFocusedViewChange
  });
  const handleMeridiemValueChange = useEventCallback_default((newValue) => {
    setValueAndGoToNextView(newValue, "finish", "meridiem");
  });
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(valueOrReferenceDate, ampm, handleMeridiemValueChange, "finish");
  const isTimeDisabled = React9.useCallback((rawValue, viewType) => {
    const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils);
    const shouldCheckPastEnd = viewType === "hours" || viewType === "minutes" && views.includes("seconds");
    const containsValidTime = ({
      start,
      end
    }) => {
      if (minTime && isAfter(minTime, end)) {
        return false;
      }
      if (maxTime && isAfter(start, maxTime)) {
        return false;
      }
      if (disableFuture && isAfter(start, now)) {
        return false;
      }
      if (disablePast && isAfter(now, shouldCheckPastEnd ? end : start)) {
        return false;
      }
      return true;
    };
    const isValidValue = (timeValue, step = 1) => {
      if (timeValue % step !== 0) {
        return false;
      }
      if (shouldDisableClock != null && shouldDisableClock(timeValue, viewType)) {
        return false;
      }
      if (shouldDisableTime) {
        switch (viewType) {
          case "hours":
            return !shouldDisableTime(utils.setHours(valueOrReferenceDate, timeValue), "hours");
          case "minutes":
            return !shouldDisableTime(utils.setMinutes(valueOrReferenceDate, timeValue), "minutes");
          case "seconds":
            return !shouldDisableTime(utils.setSeconds(valueOrReferenceDate, timeValue), "seconds");
          default:
            return false;
        }
      }
      return true;
    };
    switch (viewType) {
      case "hours": {
        const valueWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
        const dateWithNewHours = utils.setHours(valueOrReferenceDate, valueWithMeridiem);
        const start = utils.setSeconds(utils.setMinutes(dateWithNewHours, 0), 0);
        const end = utils.setSeconds(utils.setMinutes(dateWithNewHours, 59), 59);
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(valueWithMeridiem);
      }
      case "minutes": {
        const dateWithNewMinutes = utils.setMinutes(valueOrReferenceDate, rawValue);
        const start = utils.setSeconds(dateWithNewMinutes, 0);
        const end = utils.setSeconds(dateWithNewMinutes, 59);
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(rawValue, minutesStep);
      }
      case "seconds": {
        const dateWithNewSeconds = utils.setSeconds(valueOrReferenceDate, rawValue);
        const start = dateWithNewSeconds;
        const end = dateWithNewSeconds;
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(rawValue);
      }
      default:
        throw new Error("not supported");
    }
  }, [ampm, valueOrReferenceDate, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableClock, shouldDisableTime, utils, disableFuture, disablePast, now, views]);
  const buildViewProps = React9.useCallback((viewToBuild) => {
    switch (viewToBuild) {
      case "hours": {
        return {
          onChange: (hours) => {
            const valueWithMeridiem = convertValueToMeridiem(hours, meridiemMode, ampm);
            setValueAndGoToNextView(utils.setHours(valueOrReferenceDate, valueWithMeridiem), "finish", "hours");
          },
          items: getHourSectionOptions({
            now,
            value,
            ampm,
            utils,
            isDisabled: (hours) => disabled || isTimeDisabled(hours, "hours"),
            timeStep: timeSteps.hours,
            resolveAriaLabel: localeText.hoursClockNumberText
          })
        };
      }
      case "minutes": {
        return {
          onChange: (minutes) => {
            setValueAndGoToNextView(utils.setMinutes(valueOrReferenceDate, minutes), "finish", "minutes");
          },
          items: getTimeSectionOptions({
            value: utils.getMinutes(valueOrReferenceDate),
            utils,
            isDisabled: (minutes) => disabled || isTimeDisabled(minutes, "minutes"),
            resolveLabel: (minutes) => utils.format(utils.setMinutes(now, minutes), "minutes"),
            timeStep: timeSteps.minutes,
            hasValue: !!value,
            resolveAriaLabel: localeText.minutesClockNumberText
          })
        };
      }
      case "seconds": {
        return {
          onChange: (seconds) => {
            setValueAndGoToNextView(utils.setSeconds(valueOrReferenceDate, seconds), "finish", "seconds");
          },
          items: getTimeSectionOptions({
            value: utils.getSeconds(valueOrReferenceDate),
            utils,
            isDisabled: (seconds) => disabled || isTimeDisabled(seconds, "seconds"),
            resolveLabel: (seconds) => utils.format(utils.setSeconds(now, seconds), "seconds"),
            timeStep: timeSteps.seconds,
            hasValue: !!value,
            resolveAriaLabel: localeText.secondsClockNumberText
          })
        };
      }
      case "meridiem": {
        const amLabel = formatMeridiem(utils, "am");
        const pmLabel = formatMeridiem(utils, "pm");
        return {
          onChange: handleMeridiemChange,
          items: [{
            value: "am",
            label: amLabel,
            isSelected: () => !!value && meridiemMode === "am",
            ariaLabel: amLabel
          }, {
            value: "pm",
            label: pmLabel,
            isSelected: () => !!value && meridiemMode === "pm",
            ariaLabel: pmLabel
          }]
        };
      }
      default:
        throw new Error(`Unknown view: ${viewToBuild} found.`);
    }
  }, [now, value, ampm, utils, timeSteps.hours, timeSteps.minutes, timeSteps.seconds, localeText.hoursClockNumberText, localeText.minutesClockNumberText, localeText.secondsClockNumberText, meridiemMode, setValueAndGoToNextView, valueOrReferenceDate, disabled, isTimeDisabled, handleMeridiemChange]);
  const viewTimeOptions = React9.useMemo(() => {
    return views.reduce((result, currentView) => {
      return _extends({}, result, {
        [currentView]: buildViewProps(currentView)
      });
    }, {});
  }, [views, buildViewProps]);
  const ownerState = props;
  const classes = useUtilityClasses4(ownerState);
  return (0, import_jsx_runtime7.jsx)(MultiSectionDigitalClockRoot, _extends({
    ref,
    className: clsx_default(classes.root, className),
    ownerState,
    role: "group"
  }, other, {
    children: Object.entries(viewTimeOptions).map(([timeView, viewOptions]) => (0, import_jsx_runtime7.jsx)(MultiSectionDigitalClockSection, {
      items: viewOptions.items,
      onChange: viewOptions.onChange,
      active: view === timeView,
      autoFocus: autoFocus != null ? autoFocus : focusedView === timeView,
      disabled,
      readOnly,
      slots: slots != null ? slots : components,
      slotProps: slotProps != null ? slotProps : componentsProps,
      skipDisabled,
      "aria-label": localeText.selectViewText(timeView)
    }, timeView))
  }));
});
true ? MultiSectionDigitalClock.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: import_prop_types4.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types4.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types4.default.object,
  className: import_prop_types4.default.string,
  /**
   * Overrideable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types4.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types4.default.object,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types4.default.any,
  /**
   * If `true`, the picker views and text field are disabled.
   * @default false
   */
  disabled: import_prop_types4.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types4.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types4.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types4.default.bool,
  /**
   * Controlled focused view.
   */
  focusedView: import_prop_types4.default.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types4.default.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types4.default.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types4.default.number,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TView The view type. Will be one of date or time views.
   * @param {TValue} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
   * @param {TView | undefined} selectedView Indicates the view in which the selection has been made.
   */
  onChange: import_prop_types4.default.func,
  /**
   * Callback fired on focused view change.
   * @template TView
   * @param {TView} view The new view to focus or not.
   * @param {boolean} hasFocus `true` if the view should be focused.
   */
  onFocusedViewChange: import_prop_types4.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types4.default.func,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types4.default.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * If `true`, the picker views and text field are read-only.
   * @default false
   */
  readOnly: import_prop_types4.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid time using the validation props, except callbacks such as `shouldDisableTime`.
   */
  referenceDate: import_prop_types4.default.any,
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: import_prop_types4.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types4.default.func,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: import_prop_types4.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types4.default.object,
  /**
   * Overrideable component slots.
   * @default {}
   */
  slots: import_prop_types4.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types4.default.oneOfType([import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object, import_prop_types4.default.bool])), import_prop_types4.default.func, import_prop_types4.default.object]),
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: import_prop_types4.default.shape({
    hours: import_prop_types4.default.number,
    minutes: import_prop_types4.default.number,
    seconds: import_prop_types4.default.number
  }),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types4.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types4.default.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types4.default.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * Available views.
   * @default ['hours', 'minutes']
   */
  views: import_prop_types4.default.arrayOf(import_prop_types4.default.oneOf(["hours", "meridiem", "minutes", "seconds"]).isRequired)
} : void 0;

// node_modules/@mui/x-date-pickers/internals/components/DateTimeViewWrapper/DateTimeViewWrapper.js
var DateTimeViewWrapper = styled_default("div")({
  display: "flex",
  margin: "0 auto"
});

// node_modules/@mui/x-date-pickers/timeViewRenderers/timeViewRenderers.js
var React16 = __toESM(require_react());

// node_modules/@mui/x-date-pickers/TimeClock/TimeClock.js
init_extends();
init_objectWithoutPropertiesLoose();
var React14 = __toESM(require_react());
init_clsx();
var import_prop_types5 = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-date-pickers/TimeClock/timeClockClasses.js
init_utils();
function getTimeClockUtilityClass(slot) {
  return generateUtilityClass("MuiTimeClock", slot);
}
var timeClockClasses = generateUtilityClasses("MuiTimeClock", ["root", "arrowSwitcher"]);

// node_modules/@mui/x-date-pickers/TimeClock/Clock.js
init_extends();
var React11 = __toESM(require_react());
init_clsx();
init_utils();

// node_modules/@mui/x-date-pickers/TimeClock/ClockPointer.js
init_objectWithoutPropertiesLoose();
init_extends();
var React10 = __toESM(require_react());
init_clsx();
init_utils();

// node_modules/@mui/x-date-pickers/TimeClock/shared.js
var CLOCK_WIDTH = 220;
var CLOCK_HOUR_WIDTH = 36;
var clockCenter = {
  x: CLOCK_WIDTH / 2,
  y: CLOCK_WIDTH / 2
};
var baseClockPoint = {
  x: clockCenter.x,
  y: 0
};
var cx = baseClockPoint.x - clockCenter.x;
var cy = baseClockPoint.y - clockCenter.y;
var rad2deg = (rad) => rad * (180 / Math.PI);
var getAngleValue = (step, offsetX, offsetY) => {
  const x = offsetX - clockCenter.x;
  const y = offsetY - clockCenter.y;
  const atan = Math.atan2(cx, cy) - Math.atan2(x, y);
  let deg = rad2deg(atan);
  deg = Math.round(deg / step) * step;
  deg %= 360;
  const value = Math.floor(deg / step) || 0;
  const delta = x ** 2 + y ** 2;
  const distance = Math.sqrt(delta);
  return {
    value,
    distance
  };
};
var getMinutes = (offsetX, offsetY, step = 1) => {
  const angleStep = step * 6;
  let {
    value
  } = getAngleValue(angleStep, offsetX, offsetY);
  value = value * step % 60;
  return value;
};
var getHours = (offsetX, offsetY, ampm) => {
  const {
    value,
    distance
  } = getAngleValue(30, offsetX, offsetY);
  let hour = value || 12;
  if (!ampm) {
    if (distance < CLOCK_WIDTH / 2 - CLOCK_HOUR_WIDTH) {
      hour += 12;
      hour %= 24;
    }
  } else {
    hour %= 12;
  }
  return hour;
};

// node_modules/@mui/x-date-pickers/TimeClock/clockPointerClasses.js
init_utils();
function getClockPointerUtilityClass(slot) {
  return generateUtilityClass("MuiClockPointer", slot);
}
var clockPointerClasses = generateUtilityClasses("MuiClockPointer", ["root", "thumb"]);

// node_modules/@mui/x-date-pickers/TimeClock/ClockPointer.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var _excluded7 = ["className", "hasSelected", "isInner", "type", "viewValue"];
var useUtilityClasses5 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    thumb: ["thumb"]
  };
  return composeClasses(slots, getClockPointerUtilityClass, classes);
};
var ClockPointerRoot = styled_default("div", {
  name: "MuiClockPointer",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme,
  ownerState
}) => _extends({
  width: 2,
  backgroundColor: (theme.vars || theme).palette.primary.main,
  position: "absolute",
  left: "calc(50% - 1px)",
  bottom: "50%",
  transformOrigin: "center bottom 0px"
}, ownerState.shouldAnimate && {
  transition: theme.transitions.create(["transform", "height"])
}));
var ClockPointerThumb = styled_default("div", {
  name: "MuiClockPointer",
  slot: "Thumb",
  overridesResolver: (_, styles) => styles.thumb
})(({
  theme,
  ownerState
}) => _extends({
  width: 4,
  height: 4,
  backgroundColor: (theme.vars || theme).palette.primary.contrastText,
  borderRadius: "50%",
  position: "absolute",
  top: -21,
  left: `calc(50% - ${CLOCK_HOUR_WIDTH / 2}px)`,
  border: `${(CLOCK_HOUR_WIDTH - 4) / 2}px solid ${(theme.vars || theme).palette.primary.main}`,
  boxSizing: "content-box"
}, ownerState.hasSelected && {
  backgroundColor: (theme.vars || theme).palette.primary.main
}));
function ClockPointer(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiClockPointer"
  });
  const {
    className,
    isInner,
    type,
    viewValue
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded7);
  const previousType = React10.useRef(type);
  React10.useEffect(() => {
    previousType.current = type;
  }, [type]);
  const ownerState = _extends({}, props, {
    shouldAnimate: previousType.current !== type
  });
  const classes = useUtilityClasses5(ownerState);
  const getAngleStyle = () => {
    const max2 = type === "hours" ? 12 : 60;
    let angle = 360 / max2 * viewValue;
    if (type === "hours" && viewValue > 12) {
      angle -= 360;
    }
    return {
      height: Math.round((isInner ? 0.26 : 0.4) * CLOCK_WIDTH),
      transform: `rotateZ(${angle}deg)`
    };
  };
  return (0, import_jsx_runtime8.jsx)(ClockPointerRoot, _extends({
    style: getAngleStyle(),
    className: clsx_default(className, classes.root),
    ownerState
  }, other, {
    children: (0, import_jsx_runtime8.jsx)(ClockPointerThumb, {
      ownerState,
      className: classes.thumb
    })
  }));
}

// node_modules/@mui/x-date-pickers/TimeClock/clockClasses.js
init_utils();
function getClockUtilityClass(slot) {
  return generateUtilityClass("MuiClock", slot);
}
var clockClasses = generateUtilityClasses("MuiClock", ["root", "clock", "wrapper", "squareMask", "pin", "amButton", "pmButton", "meridiemText"]);

// node_modules/@mui/x-date-pickers/TimeClock/Clock.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var useUtilityClasses6 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    clock: ["clock"],
    wrapper: ["wrapper"],
    squareMask: ["squareMask"],
    pin: ["pin"],
    amButton: ["amButton"],
    pmButton: ["pmButton"],
    meridiemText: ["meridiemText"]
  };
  return composeClasses(slots, getClockUtilityClass, classes);
};
var ClockRoot = styled_default("div", {
  name: "MuiClock",
  slot: "Root",
  overridesResolver: (_, styles) => styles.root
})(({
  theme
}) => ({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  margin: theme.spacing(2)
}));
var ClockClock = styled_default("div", {
  name: "MuiClock",
  slot: "Clock",
  overridesResolver: (_, styles) => styles.clock
})({
  backgroundColor: "rgba(0,0,0,.07)",
  borderRadius: "50%",
  height: 220,
  width: 220,
  flexShrink: 0,
  position: "relative",
  pointerEvents: "none"
});
var ClockWrapper = styled_default("div", {
  name: "MuiClock",
  slot: "Wrapper",
  overridesResolver: (_, styles) => styles.wrapper
})({
  "&:focus": {
    outline: "none"
  }
});
var ClockSquareMask = styled_default("div", {
  name: "MuiClock",
  slot: "SquareMask",
  overridesResolver: (_, styles) => styles.squareMask
})(({
  ownerState
}) => _extends({
  width: "100%",
  height: "100%",
  position: "absolute",
  pointerEvents: "auto",
  outline: 0,
  // Disable scroll capabilities.
  touchAction: "none",
  userSelect: "none"
}, ownerState.disabled ? {} : {
  "@media (pointer: fine)": {
    cursor: "pointer",
    borderRadius: "50%"
  },
  "&:active": {
    cursor: "move"
  }
}));
var ClockPin = styled_default("div", {
  name: "MuiClock",
  slot: "Pin",
  overridesResolver: (_, styles) => styles.pin
})(({
  theme
}) => ({
  width: 6,
  height: 6,
  borderRadius: "50%",
  backgroundColor: (theme.vars || theme).palette.primary.main,
  position: "absolute",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)"
}));
var ClockAmButton = styled_default(IconButton_default, {
  name: "MuiClock",
  slot: "AmButton",
  overridesResolver: (_, styles) => styles.amButton
})(({
  theme,
  ownerState
}) => _extends({
  zIndex: 1,
  position: "absolute",
  bottom: 8,
  left: 8,
  paddingLeft: 4,
  paddingRight: 4,
  width: CLOCK_HOUR_WIDTH
}, ownerState.meridiemMode === "am" && {
  backgroundColor: (theme.vars || theme).palette.primary.main,
  color: (theme.vars || theme).palette.primary.contrastText,
  "&:hover": {
    backgroundColor: (theme.vars || theme).palette.primary.light
  }
}));
var ClockPmButton = styled_default(IconButton_default, {
  name: "MuiClock",
  slot: "PmButton",
  overridesResolver: (_, styles) => styles.pmButton
})(({
  theme,
  ownerState
}) => _extends({
  zIndex: 1,
  position: "absolute",
  bottom: 8,
  right: 8,
  paddingLeft: 4,
  paddingRight: 4,
  width: CLOCK_HOUR_WIDTH
}, ownerState.meridiemMode === "pm" && {
  backgroundColor: (theme.vars || theme).palette.primary.main,
  color: (theme.vars || theme).palette.primary.contrastText,
  "&:hover": {
    backgroundColor: (theme.vars || theme).palette.primary.light
  }
}));
var ClockMeridiemText = styled_default(Typography_default, {
  name: "MuiClock",
  slot: "meridiemText",
  overridesResolver: (_, styles) => styles.meridiemText
})({
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
});
function Clock(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiClock"
  });
  const {
    ampm,
    ampmInClock,
    autoFocus,
    children,
    value,
    handleMeridiemChange,
    isTimeDisabled,
    meridiemMode,
    minutesStep = 1,
    onChange,
    selectedId,
    type,
    viewValue,
    disabled,
    readOnly,
    className
  } = props;
  const ownerState = props;
  const utils = useUtils();
  const localeText = useLocaleText();
  const isMoving = React11.useRef(false);
  const classes = useUtilityClasses6(ownerState);
  const isSelectedTimeDisabled = isTimeDisabled(viewValue, type);
  const isPointerInner = !ampm && type === "hours" && (viewValue < 1 || viewValue > 12);
  const handleValueChange = (newValue, isFinish) => {
    if (disabled || readOnly) {
      return;
    }
    if (isTimeDisabled(newValue, type)) {
      return;
    }
    onChange(newValue, isFinish);
  };
  const setTime = (event, isFinish) => {
    let {
      offsetX,
      offsetY
    } = event;
    if (offsetX === void 0) {
      const rect = event.target.getBoundingClientRect();
      offsetX = event.changedTouches[0].clientX - rect.left;
      offsetY = event.changedTouches[0].clientY - rect.top;
    }
    const newSelectedValue = type === "seconds" || type === "minutes" ? getMinutes(offsetX, offsetY, minutesStep) : getHours(offsetX, offsetY, Boolean(ampm));
    handleValueChange(newSelectedValue, isFinish);
  };
  const handleTouchMove = (event) => {
    isMoving.current = true;
    setTime(event, "shallow");
  };
  const handleTouchEnd = (event) => {
    if (isMoving.current) {
      setTime(event, "finish");
      isMoving.current = false;
    }
  };
  const handleMouseMove = (event) => {
    if (event.buttons > 0) {
      setTime(event.nativeEvent, "shallow");
    }
  };
  const handleMouseUp = (event) => {
    if (isMoving.current) {
      isMoving.current = false;
    }
    setTime(event.nativeEvent, "finish");
  };
  const hasSelected = React11.useMemo(() => {
    if (type === "hours") {
      return true;
    }
    return viewValue % 5 === 0;
  }, [type, viewValue]);
  const keyboardControlStep = type === "minutes" ? minutesStep : 1;
  const listboxRef = React11.useRef(null);
  useEnhancedEffect_default(() => {
    if (autoFocus) {
      listboxRef.current.focus();
    }
  }, [autoFocus]);
  const handleKeyDown = (event) => {
    if (isMoving.current) {
      return;
    }
    switch (event.key) {
      case "Home":
        handleValueChange(0, "partial");
        event.preventDefault();
        break;
      case "End":
        handleValueChange(type === "minutes" ? 59 : 23, "partial");
        event.preventDefault();
        break;
      case "ArrowUp":
        handleValueChange(viewValue + keyboardControlStep, "partial");
        event.preventDefault();
        break;
      case "ArrowDown":
        handleValueChange(viewValue - keyboardControlStep, "partial");
        event.preventDefault();
        break;
      default:
    }
  };
  return (0, import_jsx_runtime10.jsxs)(ClockRoot, {
    className: clsx_default(className, classes.root),
    children: [(0, import_jsx_runtime10.jsxs)(ClockClock, {
      className: classes.clock,
      children: [(0, import_jsx_runtime9.jsx)(ClockSquareMask, {
        onTouchMove: handleTouchMove,
        onTouchEnd: handleTouchEnd,
        onMouseUp: handleMouseUp,
        onMouseMove: handleMouseMove,
        ownerState: {
          disabled
        },
        className: classes.squareMask
      }), !isSelectedTimeDisabled && (0, import_jsx_runtime10.jsxs)(React11.Fragment, {
        children: [(0, import_jsx_runtime9.jsx)(ClockPin, {
          className: classes.pin
        }), value != null && (0, import_jsx_runtime9.jsx)(ClockPointer, {
          type,
          viewValue,
          isInner: isPointerInner,
          hasSelected
        })]
      }), (0, import_jsx_runtime9.jsx)(ClockWrapper, {
        "aria-activedescendant": selectedId,
        "aria-label": localeText.clockLabelText(type, value, utils),
        ref: listboxRef,
        role: "listbox",
        onKeyDown: handleKeyDown,
        tabIndex: 0,
        className: classes.wrapper,
        children
      })]
    }), ampm && ampmInClock && (0, import_jsx_runtime10.jsxs)(React11.Fragment, {
      children: [(0, import_jsx_runtime9.jsx)(ClockAmButton, {
        onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
        disabled: disabled || meridiemMode === null,
        ownerState,
        className: classes.amButton,
        title: formatMeridiem(utils, "am"),
        children: (0, import_jsx_runtime9.jsx)(ClockMeridiemText, {
          variant: "caption",
          className: classes.meridiemText,
          children: formatMeridiem(utils, "am")
        })
      }), (0, import_jsx_runtime9.jsx)(ClockPmButton, {
        disabled: disabled || meridiemMode === null,
        onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
        ownerState,
        className: classes.pmButton,
        title: formatMeridiem(utils, "pm"),
        children: (0, import_jsx_runtime9.jsx)(ClockMeridiemText, {
          variant: "caption",
          className: classes.meridiemText,
          children: formatMeridiem(utils, "pm")
        })
      })]
    })]
  });
}

// node_modules/@mui/x-date-pickers/TimeClock/ClockNumbers.js
var React13 = __toESM(require_react());

// node_modules/@mui/x-date-pickers/TimeClock/ClockNumber.js
init_objectWithoutPropertiesLoose();
init_extends();
var React12 = __toESM(require_react());
init_clsx();
init_utils();

// node_modules/@mui/x-date-pickers/TimeClock/clockNumberClasses.js
init_utils();
function getClockNumberUtilityClass(slot) {
  return generateUtilityClass("MuiClockNumber", slot);
}
var clockNumberClasses = generateUtilityClasses("MuiClockNumber", ["root", "selected", "disabled"]);

// node_modules/@mui/x-date-pickers/TimeClock/ClockNumber.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var _excluded8 = ["className", "disabled", "index", "inner", "label", "selected"];
var useUtilityClasses7 = (ownerState) => {
  const {
    classes,
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", disabled && "disabled"]
  };
  return composeClasses(slots, getClockNumberUtilityClass, classes);
};
var ClockNumberRoot = styled_default("span", {
  name: "MuiClockNumber",
  slot: "Root",
  overridesResolver: (_, styles) => [styles.root, {
    [`&.${clockNumberClasses.disabled}`]: styles.disabled
  }, {
    [`&.${clockNumberClasses.selected}`]: styles.selected
  }]
})(({
  theme,
  ownerState
}) => _extends({
  height: CLOCK_HOUR_WIDTH,
  width: CLOCK_HOUR_WIDTH,
  position: "absolute",
  left: `calc((100% - ${CLOCK_HOUR_WIDTH}px) / 2)`,
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  borderRadius: "50%",
  color: (theme.vars || theme).palette.text.primary,
  fontFamily: theme.typography.fontFamily,
  "&:focused": {
    backgroundColor: (theme.vars || theme).palette.background.paper
  },
  [`&.${clockNumberClasses.selected}`]: {
    color: (theme.vars || theme).palette.primary.contrastText
  },
  [`&.${clockNumberClasses.disabled}`]: {
    pointerEvents: "none",
    color: (theme.vars || theme).palette.text.disabled
  }
}, ownerState.inner && _extends({}, theme.typography.body2, {
  color: (theme.vars || theme).palette.text.secondary
})));
function ClockNumber(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiClockNumber"
  });
  const {
    className,
    disabled,
    index,
    inner,
    label,
    selected
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded8);
  const ownerState = props;
  const classes = useUtilityClasses7(ownerState);
  const angle = index % 12 / 12 * Math.PI * 2 - Math.PI / 2;
  const length = (CLOCK_WIDTH - CLOCK_HOUR_WIDTH - 2) / 2 * (inner ? 0.65 : 1);
  const x = Math.round(Math.cos(angle) * length);
  const y = Math.round(Math.sin(angle) * length);
  return (0, import_jsx_runtime11.jsx)(ClockNumberRoot, _extends({
    className: clsx_default(className, classes.root),
    "aria-disabled": disabled ? true : void 0,
    "aria-selected": selected ? true : void 0,
    role: "option",
    style: {
      transform: `translate(${x}px, ${y + (CLOCK_WIDTH - CLOCK_HOUR_WIDTH) / 2}px`
    },
    ownerState
  }, other, {
    children: label
  }));
}

// node_modules/@mui/x-date-pickers/TimeClock/ClockNumbers.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var getHourNumbers = ({
  ampm,
  value,
  getClockNumberText,
  isDisabled,
  selectedId,
  utils
}) => {
  const currentHours = value ? utils.getHours(value) : null;
  const hourNumbers = [];
  const startHour = ampm ? 1 : 0;
  const endHour = ampm ? 12 : 23;
  const isSelected = (hour) => {
    if (currentHours === null) {
      return false;
    }
    if (ampm) {
      if (hour === 12) {
        return currentHours === 12 || currentHours === 0;
      }
      return currentHours === hour || currentHours - 12 === hour;
    }
    return currentHours === hour;
  };
  for (let hour = startHour; hour <= endHour; hour += 1) {
    let label = hour.toString();
    if (hour === 0) {
      label = "00";
    }
    const inner = !ampm && (hour === 0 || hour > 12);
    label = utils.formatNumber(label);
    const selected = isSelected(hour);
    hourNumbers.push((0, import_jsx_runtime12.jsx)(ClockNumber, {
      id: selected ? selectedId : void 0,
      index: hour,
      inner,
      selected,
      disabled: isDisabled(hour),
      label,
      "aria-label": getClockNumberText(label)
    }, hour));
  }
  return hourNumbers;
};
var getMinutesNumbers = ({
  utils,
  value,
  isDisabled,
  getClockNumberText,
  selectedId
}) => {
  const f = utils.formatNumber;
  return [[5, f("05")], [10, f("10")], [15, f("15")], [20, f("20")], [25, f("25")], [30, f("30")], [35, f("35")], [40, f("40")], [45, f("45")], [50, f("50")], [55, f("55")], [0, f("00")]].map(([numberValue, label], index) => {
    const selected = numberValue === value;
    return (0, import_jsx_runtime12.jsx)(ClockNumber, {
      label,
      id: selected ? selectedId : void 0,
      index: index + 1,
      inner: false,
      disabled: isDisabled(numberValue),
      selected,
      "aria-label": getClockNumberText(label)
    }, numberValue);
  });
};

// node_modules/@mui/x-date-pickers/TimeClock/TimeClock.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var _excluded9 = ["ampm", "ampmInClock", "autoFocus", "components", "componentsProps", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableClock", "shouldDisableTime", "showViewSwitcher", "onChange", "view", "views", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "timezone"];
var useUtilityClasses8 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    arrowSwitcher: ["arrowSwitcher"]
  };
  return composeClasses(slots, getTimeClockUtilityClass, classes);
};
var TimeClockRoot = styled_default(PickerViewRoot, {
  name: "MuiTimeClock",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  display: "flex",
  flexDirection: "column",
  position: "relative"
});
var TimeClockArrowSwitcher = styled_default(PickersArrowSwitcher, {
  name: "MuiTimeClock",
  slot: "ArrowSwitcher",
  overridesResolver: (props, styles) => styles.arrowSwitcher
})({
  position: "absolute",
  right: 12,
  top: 15
});
var TIME_CLOCK_DEFAULT_VIEWS = ["hours", "minutes"];
var TimeClock = React14.forwardRef(function TimeClock2(inProps, ref) {
  const utils = useUtils();
  const props = useThemeProps({
    props: inProps,
    name: "MuiTimeClock"
  });
  const {
    ampm = utils.is12HourCycleInCurrentLocale(),
    ampmInClock = false,
    autoFocus,
    components,
    componentsProps,
    slots: innerSlots,
    slotProps: innerSlotProps,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableIgnoringDatePartForTimeValidation = false,
    maxTime,
    minTime,
    disableFuture,
    disablePast,
    minutesStep = 1,
    shouldDisableClock,
    shouldDisableTime,
    showViewSwitcher,
    onChange,
    view: inView,
    views = TIME_CLOCK_DEFAULT_VIEWS,
    openTo,
    onViewChange,
    focusedView,
    onFocusedViewChange,
    className,
    disabled,
    readOnly,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
  const slots = innerSlots != null ? innerSlots : uncapitalizeObjectKeys(components);
  const slotProps = innerSlotProps != null ? innerSlotProps : componentsProps;
  const {
    value,
    handleValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "TimeClock",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const valueOrReferenceDate = useClockReferenceDate({
    value,
    referenceDate: referenceDateProp,
    utils,
    props,
    timezone
  });
  const localeText = useLocaleText();
  const now = useNow(timezone);
  const {
    view,
    setView,
    previousView,
    nextView,
    setValueAndGoToNextView
  } = useViews({
    view: inView,
    views,
    openTo,
    onViewChange,
    onChange: handleValueChange,
    focusedView,
    onFocusedViewChange
  });
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(valueOrReferenceDate, ampm, setValueAndGoToNextView);
  const isTimeDisabled = React14.useCallback((rawValue, viewType) => {
    const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils);
    const shouldCheckPastEnd = viewType === "hours" || viewType === "minutes" && views.includes("seconds");
    const containsValidTime = ({
      start,
      end
    }) => {
      if (minTime && isAfter(minTime, end)) {
        return false;
      }
      if (maxTime && isAfter(start, maxTime)) {
        return false;
      }
      if (disableFuture && isAfter(start, now)) {
        return false;
      }
      if (disablePast && isAfter(now, shouldCheckPastEnd ? end : start)) {
        return false;
      }
      return true;
    };
    const isValidValue = (timeValue, step = 1) => {
      if (timeValue % step !== 0) {
        return false;
      }
      if (shouldDisableClock != null && shouldDisableClock(timeValue, viewType)) {
        return false;
      }
      if (shouldDisableTime) {
        switch (viewType) {
          case "hours":
            return !shouldDisableTime(utils.setHours(valueOrReferenceDate, timeValue), "hours");
          case "minutes":
            return !shouldDisableTime(utils.setMinutes(valueOrReferenceDate, timeValue), "minutes");
          case "seconds":
            return !shouldDisableTime(utils.setSeconds(valueOrReferenceDate, timeValue), "seconds");
          default:
            return false;
        }
      }
      return true;
    };
    switch (viewType) {
      case "hours": {
        const valueWithMeridiem = convertValueToMeridiem(rawValue, meridiemMode, ampm);
        const dateWithNewHours = utils.setHours(valueOrReferenceDate, valueWithMeridiem);
        const start = utils.setSeconds(utils.setMinutes(dateWithNewHours, 0), 0);
        const end = utils.setSeconds(utils.setMinutes(dateWithNewHours, 59), 59);
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(valueWithMeridiem);
      }
      case "minutes": {
        const dateWithNewMinutes = utils.setMinutes(valueOrReferenceDate, rawValue);
        const start = utils.setSeconds(dateWithNewMinutes, 0);
        const end = utils.setSeconds(dateWithNewMinutes, 59);
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(rawValue, minutesStep);
      }
      case "seconds": {
        const dateWithNewSeconds = utils.setSeconds(valueOrReferenceDate, rawValue);
        const start = dateWithNewSeconds;
        const end = dateWithNewSeconds;
        return !containsValidTime({
          start,
          end
        }) || !isValidValue(rawValue);
      }
      default:
        throw new Error("not supported");
    }
  }, [ampm, valueOrReferenceDate, disableIgnoringDatePartForTimeValidation, maxTime, meridiemMode, minTime, minutesStep, shouldDisableClock, shouldDisableTime, utils, disableFuture, disablePast, now, views]);
  const selectedId = useId();
  const viewProps = React14.useMemo(() => {
    switch (view) {
      case "hours": {
        const handleHoursChange = (hourValue, isFinish) => {
          const valueWithMeridiem = convertValueToMeridiem(hourValue, meridiemMode, ampm);
          setValueAndGoToNextView(utils.setHours(valueOrReferenceDate, valueWithMeridiem), isFinish);
        };
        return {
          onChange: handleHoursChange,
          viewValue: utils.getHours(valueOrReferenceDate),
          children: getHourNumbers({
            value,
            utils,
            ampm,
            onChange: handleHoursChange,
            getClockNumberText: localeText.hoursClockNumberText,
            isDisabled: (hourValue) => disabled || isTimeDisabled(hourValue, "hours"),
            selectedId
          })
        };
      }
      case "minutes": {
        const minutesValue = utils.getMinutes(valueOrReferenceDate);
        const handleMinutesChange = (minuteValue, isFinish) => {
          setValueAndGoToNextView(utils.setMinutes(valueOrReferenceDate, minuteValue), isFinish);
        };
        return {
          viewValue: minutesValue,
          onChange: handleMinutesChange,
          children: getMinutesNumbers({
            utils,
            value: minutesValue,
            onChange: handleMinutesChange,
            getClockNumberText: localeText.minutesClockNumberText,
            isDisabled: (minuteValue) => disabled || isTimeDisabled(minuteValue, "minutes"),
            selectedId
          })
        };
      }
      case "seconds": {
        const secondsValue = utils.getSeconds(valueOrReferenceDate);
        const handleSecondsChange = (secondValue, isFinish) => {
          setValueAndGoToNextView(utils.setSeconds(valueOrReferenceDate, secondValue), isFinish);
        };
        return {
          viewValue: secondsValue,
          onChange: handleSecondsChange,
          children: getMinutesNumbers({
            utils,
            value: secondsValue,
            onChange: handleSecondsChange,
            getClockNumberText: localeText.secondsClockNumberText,
            isDisabled: (secondValue) => disabled || isTimeDisabled(secondValue, "seconds"),
            selectedId
          })
        };
      }
      default:
        throw new Error("You must provide the type for ClockView");
    }
  }, [view, utils, value, ampm, localeText.hoursClockNumberText, localeText.minutesClockNumberText, localeText.secondsClockNumberText, meridiemMode, setValueAndGoToNextView, valueOrReferenceDate, isTimeDisabled, selectedId, disabled]);
  const ownerState = props;
  const classes = useUtilityClasses8(ownerState);
  return (0, import_jsx_runtime14.jsxs)(TimeClockRoot, _extends({
    ref,
    className: clsx_default(classes.root, className),
    ownerState
  }, other, {
    children: [(0, import_jsx_runtime13.jsx)(Clock, _extends({
      autoFocus: autoFocus != null ? autoFocus : !!focusedView,
      ampmInClock: ampmInClock && views.includes("hours"),
      value,
      type: view,
      ampm,
      minutesStep,
      isTimeDisabled,
      meridiemMode,
      handleMeridiemChange,
      selectedId,
      disabled,
      readOnly
    }, viewProps)), showViewSwitcher && (0, import_jsx_runtime13.jsx)(TimeClockArrowSwitcher, {
      className: classes.arrowSwitcher,
      slots,
      slotProps,
      onGoToPrevious: () => setView(previousView),
      isPreviousDisabled: !previousView,
      previousLabel: localeText.openPreviousView,
      onGoToNext: () => setView(nextView),
      isNextDisabled: !nextView,
      nextLabel: localeText.openNextView,
      ownerState
    })]
  }));
});
true ? TimeClock.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: import_prop_types5.default.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default false
   */
  ampmInClock: import_prop_types5.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types5.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types5.default.object,
  className: import_prop_types5.default.string,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types5.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types5.default.object,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types5.default.any,
  /**
   * If `true`, the picker views and text field are disabled.
   * @default false
   */
  disabled: import_prop_types5.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types5.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types5.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types5.default.bool,
  /**
   * Controlled focused view.
   */
  focusedView: import_prop_types5.default.oneOf(["hours", "minutes", "seconds"]),
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types5.default.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types5.default.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types5.default.number,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TView The view type. Will be one of date or time views.
   * @param {TValue} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
   * @param {TView | undefined} selectedView Indicates the view in which the selection has been made.
   */
  onChange: import_prop_types5.default.func,
  /**
   * Callback fired on focused view change.
   * @template TView
   * @param {TView} view The new view to focus or not.
   * @param {boolean} hasFocus `true` if the view should be focused.
   */
  onFocusedViewChange: import_prop_types5.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types5.default.func,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types5.default.oneOf(["hours", "minutes", "seconds"]),
  /**
   * If `true`, the picker views and text field are read-only.
   * @default false
   */
  readOnly: import_prop_types5.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid time using the validation props, except callbacks such as `shouldDisableTime`.
   */
  referenceDate: import_prop_types5.default.any,
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: import_prop_types5.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types5.default.func,
  showViewSwitcher: import_prop_types5.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types5.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types5.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types5.default.oneOfType([import_prop_types5.default.arrayOf(import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object, import_prop_types5.default.bool])), import_prop_types5.default.func, import_prop_types5.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types5.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types5.default.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types5.default.oneOf(["hours", "minutes", "seconds"]),
  /**
   * Available views.
   * @default ['hours', 'minutes']
   */
  views: import_prop_types5.default.arrayOf(import_prop_types5.default.oneOf(["hours", "minutes", "seconds"]).isRequired)
} : void 0;

// node_modules/@mui/x-date-pickers/DigitalClock/DigitalClock.js
init_extends();
init_objectWithoutPropertiesLoose();
var React15 = __toESM(require_react());
init_clsx();
var import_prop_types6 = __toESM(require_prop_types());
init_useEventCallback();
init_composeClasses();
init_useForkRef();

// node_modules/@mui/x-date-pickers/DigitalClock/digitalClockClasses.js
init_generateUtilityClass();
init_generateUtilityClasses();
function getDigitalClockUtilityClass(slot) {
  return generateUtilityClass("MuiDigitalClock", slot);
}
var digitalClockClasses = generateUtilityClasses("MuiDigitalClock", ["root", "list", "item"]);

// node_modules/@mui/x-date-pickers/DigitalClock/DigitalClock.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var _excluded10 = ["ampm", "timeStep", "autoFocus", "components", "componentsProps", "slots", "slotProps", "value", "defaultValue", "referenceDate", "disableIgnoringDatePartForTimeValidation", "maxTime", "minTime", "disableFuture", "disablePast", "minutesStep", "shouldDisableClock", "shouldDisableTime", "onChange", "view", "openTo", "onViewChange", "focusedView", "onFocusedViewChange", "className", "disabled", "readOnly", "views", "skipDisabled", "timezone"];
var useUtilityClasses9 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    list: ["list"],
    item: ["item"]
  };
  return composeClasses(slots, getDigitalClockUtilityClass, classes);
};
var DigitalClockRoot = styled_default(PickerViewRoot, {
  name: "MuiDigitalClock",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  ownerState
}) => ({
  overflowY: "auto",
  width: "100%",
  "@media (prefers-reduced-motion: no-preference)": {
    scrollBehavior: ownerState.alreadyRendered ? "smooth" : "auto"
  },
  maxHeight: DIGITAL_CLOCK_VIEW_HEIGHT
}));
var DigitalClockList = styled_default(MenuList_default, {
  name: "MuiDigitalClock",
  slot: "List",
  overridesResolver: (props, styles) => styles.list
})({
  padding: 0
});
var DigitalClockItem = styled_default(MenuItem_default, {
  name: "MuiDigitalClock",
  slot: "Item",
  overridesResolver: (props, styles) => styles.item
})(({
  theme
}) => ({
  padding: "8px 16px",
  margin: "2px 4px",
  "&:first-of-type": {
    marginTop: 4
  },
  "&:hover": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.hoverOpacity)
  },
  "&.Mui-selected": {
    backgroundColor: (theme.vars || theme).palette.primary.main,
    color: (theme.vars || theme).palette.primary.contrastText,
    "&:focus-visible, &:hover": {
      backgroundColor: (theme.vars || theme).palette.primary.dark
    }
  },
  "&.Mui-focusVisible": {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.focusOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.focusOpacity)
  }
}));
var DigitalClock = React15.forwardRef(function DigitalClock2(inProps, ref) {
  var _ref, _slots$digitalClockIt, _slotProps$digitalClo;
  const utils = useUtils();
  const containerRef = React15.useRef(null);
  const handleRef = useForkRef(ref, containerRef);
  const props = useThemeProps({
    props: inProps,
    name: "MuiDigitalClock"
  });
  const {
    ampm = utils.is12HourCycleInCurrentLocale(),
    timeStep = 30,
    autoFocus,
    components,
    componentsProps,
    slots,
    slotProps,
    value: valueProp,
    defaultValue,
    referenceDate: referenceDateProp,
    disableIgnoringDatePartForTimeValidation = false,
    maxTime,
    minTime,
    disableFuture,
    disablePast,
    minutesStep = 1,
    shouldDisableClock,
    shouldDisableTime,
    onChange,
    view: inView,
    openTo,
    onViewChange,
    focusedView,
    onFocusedViewChange,
    className,
    disabled,
    readOnly,
    views = ["hours"],
    skipDisabled = false,
    timezone: timezoneProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded10);
  const {
    value,
    handleValueChange: handleRawValueChange,
    timezone
  } = useControlledValueWithTimezone({
    name: "DigitalClock",
    timezone: timezoneProp,
    value: valueProp,
    defaultValue,
    onChange,
    valueManager: singleItemValueManager
  });
  const localeText = useLocaleText();
  const now = useNow(timezone);
  const ownerState = React15.useMemo(() => _extends({}, props, {
    alreadyRendered: !!containerRef.current
  }), [props]);
  const classes = useUtilityClasses9(ownerState);
  const ClockItem = (_ref = (_slots$digitalClockIt = slots == null ? void 0 : slots.digitalClockItem) != null ? _slots$digitalClockIt : components == null ? void 0 : components.DigitalClockItem) != null ? _ref : DigitalClockItem;
  const clockItemProps = useSlotProps({
    elementType: ClockItem,
    externalSlotProps: (_slotProps$digitalClo = slotProps == null ? void 0 : slotProps.digitalClockItem) != null ? _slotProps$digitalClo : componentsProps == null ? void 0 : componentsProps.digitalClockItem,
    ownerState: {},
    className: classes.item
  });
  const valueOrReferenceDate = useClockReferenceDate({
    value,
    referenceDate: referenceDateProp,
    utils,
    props,
    timezone
  });
  const handleValueChange = useEventCallback_default((newValue) => handleRawValueChange(newValue, "finish", "hours"));
  const {
    setValueAndGoToNextView
  } = useViews({
    view: inView,
    views,
    openTo,
    onViewChange,
    onChange: handleValueChange,
    focusedView,
    onFocusedViewChange
  });
  const handleItemSelect = useEventCallback_default((newValue) => {
    setValueAndGoToNextView(newValue, "finish");
  });
  React15.useEffect(() => {
    if (containerRef.current === null) {
      return;
    }
    const selectedItem = containerRef.current.querySelector('[role="listbox"] [role="option"][aria-selected="true"]');
    if (!selectedItem) {
      return;
    }
    const offsetTop = selectedItem.offsetTop;
    containerRef.current.scrollTop = offsetTop - 4;
  });
  const isTimeDisabled = React15.useCallback((valueToCheck) => {
    const isAfter = createIsAfterIgnoreDatePart(disableIgnoringDatePartForTimeValidation, utils);
    const containsValidTime = () => {
      if (minTime && isAfter(minTime, valueToCheck)) {
        return false;
      }
      if (maxTime && isAfter(valueToCheck, maxTime)) {
        return false;
      }
      if (disableFuture && isAfter(valueToCheck, now)) {
        return false;
      }
      if (disablePast && isAfter(now, valueToCheck)) {
        return false;
      }
      return true;
    };
    const isValidValue = () => {
      if (utils.getMinutes(valueToCheck) % minutesStep !== 0) {
        return false;
      }
      if (shouldDisableClock != null && shouldDisableClock(utils.toJsDate(valueToCheck).getTime(), "hours")) {
        return false;
      }
      if (shouldDisableTime) {
        return !shouldDisableTime(valueToCheck, "hours");
      }
      return true;
    };
    return !containsValidTime() || !isValidValue();
  }, [disableIgnoringDatePartForTimeValidation, utils, minTime, maxTime, disableFuture, now, disablePast, minutesStep, shouldDisableClock, shouldDisableTime]);
  const timeOptions = React15.useMemo(() => {
    const startOfDay = utils.startOfDay(valueOrReferenceDate);
    return [startOfDay, ...Array.from({
      length: Math.ceil(24 * 60 / timeStep) - 1
    }, (_, index) => utils.addMinutes(startOfDay, timeStep * (index + 1)))];
  }, [valueOrReferenceDate, timeStep, utils]);
  return (0, import_jsx_runtime15.jsx)(DigitalClockRoot, _extends({
    ref: handleRef,
    className: clsx_default(classes.root, className),
    ownerState
  }, other, {
    children: (0, import_jsx_runtime15.jsx)(DigitalClockList, {
      autoFocusItem: autoFocus || !!focusedView,
      role: "listbox",
      "aria-label": localeText.timePickerToolbarTitle,
      className: classes.list,
      children: timeOptions.map((option) => {
        if (skipDisabled && isTimeDisabled(option)) {
          return null;
        }
        const isSelected = utils.isEqual(option, value);
        return (0, import_jsx_runtime15.jsx)(ClockItem, _extends({
          onClick: () => !readOnly && handleItemSelect(option),
          selected: isSelected,
          disabled: disabled || isTimeDisabled(option),
          disableRipple: readOnly,
          role: "option",
          "aria-disabled": readOnly,
          "aria-selected": isSelected
        }, clockItemProps, {
          children: utils.format(option, ampm ? "fullTime12h" : "fullTime24h")
        }), utils.toISO(option));
      })
    })
  }));
});
true ? DigitalClock.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: import_prop_types6.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types6.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types6.default.object,
  className: import_prop_types6.default.string,
  /**
   * Overrideable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types6.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types6.default.object,
  /**
   * The default selected value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types6.default.any,
  /**
   * If `true`, the picker views and text field are disabled.
   * @default false
   */
  disabled: import_prop_types6.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types6.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types6.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types6.default.bool,
  /**
   * Controlled focused view.
   */
  focusedView: import_prop_types6.default.oneOf(["hours"]),
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types6.default.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types6.default.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types6.default.number,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TView The view type. Will be one of date or time views.
   * @param {TValue} value The new value.
   * @param {PickerSelectionState | undefined} selectionState Indicates if the date selection is complete.
   * @param {TView | undefined} selectedView Indicates the view in which the selection has been made.
   */
  onChange: import_prop_types6.default.func,
  /**
   * Callback fired on focused view change.
   * @template TView
   * @param {TView} view The new view to focus or not.
   * @param {boolean} hasFocus `true` if the view should be focused.
   */
  onFocusedViewChange: import_prop_types6.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types6.default.func,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types6.default.oneOf(["hours"]),
  /**
   * If `true`, the picker views and text field are read-only.
   * @default false
   */
  readOnly: import_prop_types6.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid time using the validation props, except callbacks such as `shouldDisableTime`.
   */
  referenceDate: import_prop_types6.default.any,
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: import_prop_types6.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types6.default.func,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: import_prop_types6.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types6.default.object,
  /**
   * Overrideable component slots.
   * @default {}
   */
  slots: import_prop_types6.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types6.default.oneOfType([import_prop_types6.default.arrayOf(import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object, import_prop_types6.default.bool])), import_prop_types6.default.func, import_prop_types6.default.object]),
  /**
   * The time steps between two time options.
   * For example, if `timeStep = 45`, then the available time options will be `[00:00, 00:45, 01:30, 02:15, 03:00, etc.]`.
   * @default 30
   */
  timeStep: import_prop_types6.default.number,
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types6.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types6.default.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types6.default.oneOf(["hours"]),
  /**
   * Available views.
   * @default ['hours']
   */
  views: import_prop_types6.default.arrayOf(import_prop_types6.default.oneOf(["hours"]))
} : void 0;

// node_modules/@mui/x-date-pickers/timeViewRenderers/timeViewRenderers.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var renderTimeViewClock = ({
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  shouldDisableClock,
  minutesStep,
  ampm,
  ampmInClock,
  components,
  componentsProps,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  showViewSwitcher,
  disableIgnoringDatePartForTimeValidation,
  timezone
}) => (0, import_jsx_runtime16.jsx)(TimeClock, {
  view,
  onViewChange,
  focusedView: focusedView && isTimeView(focusedView) ? focusedView : null,
  onFocusedViewChange,
  views: views.filter(isTimeView),
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  shouldDisableClock,
  minutesStep,
  ampm,
  ampmInClock,
  components,
  componentsProps,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  showViewSwitcher,
  disableIgnoringDatePartForTimeValidation,
  timezone
});
var renderDigitalClockTimeView = ({
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  shouldDisableClock,
  minutesStep,
  ampm,
  components,
  componentsProps,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  disableIgnoringDatePartForTimeValidation,
  timeSteps,
  skipDisabled,
  timezone
}) => (0, import_jsx_runtime16.jsx)(DigitalClock, {
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views: views.filter(isTimeView),
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  shouldDisableClock,
  minutesStep,
  ampm,
  components,
  componentsProps,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  disableIgnoringDatePartForTimeValidation,
  timeStep: timeSteps == null ? void 0 : timeSteps.minutes,
  skipDisabled,
  timezone
});
var renderMultiSectionDigitalClockTimeView = ({
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  shouldDisableClock,
  minutesStep,
  ampm,
  components,
  componentsProps,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  disableIgnoringDatePartForTimeValidation,
  timeSteps,
  skipDisabled,
  timezone
}) => (0, import_jsx_runtime16.jsx)(MultiSectionDigitalClock, {
  view,
  onViewChange,
  focusedView,
  onFocusedViewChange,
  views: views.filter(isTimeView),
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minTime,
  maxTime,
  shouldDisableTime,
  shouldDisableClock,
  minutesStep,
  ampm,
  components,
  componentsProps,
  slots,
  slotProps,
  readOnly,
  disabled,
  sx,
  autoFocus,
  disableIgnoringDatePartForTimeValidation,
  timeSteps,
  skipDisabled,
  timezone
});

// node_modules/@mui/x-date-pickers/dateTimeViewRenderers/dateTimeViewRenderers.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var renderDesktopDateTimeView = ({
  view,
  onViewChange,
  views,
  focusedView,
  onFocusedViewChange,
  value,
  defaultValue,
  referenceDate,
  onChange,
  className,
  classes,
  disableFuture,
  disablePast,
  minDate,
  minTime,
  maxDate,
  maxTime,
  shouldDisableDate,
  shouldDisableMonth,
  shouldDisableYear,
  shouldDisableTime,
  shouldDisableClock,
  reduceAnimations,
  minutesStep,
  ampm,
  onMonthChange,
  monthsPerRow,
  onYearChange,
  yearsPerRow,
  defaultCalendarMonth,
  components,
  componentsProps,
  slots,
  slotProps,
  loading,
  renderLoading,
  disableHighlightToday,
  readOnly,
  disabled,
  showDaysOutsideCurrentMonth,
  dayOfWeekFormatter,
  sx,
  autoFocus,
  fixedWeekNumber,
  displayWeekNumber,
  timezone,
  disableIgnoringDatePartForTimeValidation,
  timeSteps,
  skipDisabled,
  timeViewsCount,
  shouldRenderTimeInASingleColumn
}) => {
  var _resolveComponentProp, _slotProps$actionBar;
  const isActionBarVisible = !!((_resolveComponentProp = resolveComponentProps((_slotProps$actionBar = slotProps == null ? void 0 : slotProps.actionBar) != null ? _slotProps$actionBar : componentsProps == null ? void 0 : componentsProps.actionBar, {})) != null && (_resolveComponentProp = _resolveComponentProp.actions) != null && _resolveComponentProp.length);
  const commonTimeProps = {
    view: isInternalTimeView(view) ? view : "hours",
    onViewChange,
    focusedView: focusedView && isInternalTimeView(focusedView) ? focusedView : null,
    onFocusedViewChange,
    views: views.filter(isInternalTimeView),
    value,
    defaultValue,
    referenceDate,
    onChange,
    className,
    classes,
    disableFuture,
    disablePast,
    minTime,
    maxTime,
    shouldDisableTime,
    shouldDisableClock,
    minutesStep,
    ampm,
    components,
    componentsProps,
    slots,
    slotProps,
    readOnly,
    disabled,
    autoFocus,
    disableIgnoringDatePartForTimeValidation,
    timeSteps,
    skipDisabled,
    timezone
  };
  return (0, import_jsx_runtime18.jsxs)(React17.Fragment, {
    children: [(0, import_jsx_runtime18.jsxs)(DateTimeViewWrapper, {
      children: [(0, import_jsx_runtime17.jsx)(DateCalendar, {
        view: isDatePickerView(view) ? view : "day",
        onViewChange,
        views: views.filter(isDatePickerView),
        focusedView: focusedView && isDatePickerView(focusedView) ? focusedView : null,
        onFocusedViewChange,
        value,
        defaultValue,
        referenceDate,
        onChange,
        className,
        classes,
        disableFuture,
        disablePast,
        minDate,
        maxDate,
        shouldDisableDate,
        shouldDisableMonth,
        shouldDisableYear,
        reduceAnimations,
        onMonthChange,
        monthsPerRow,
        onYearChange,
        yearsPerRow,
        defaultCalendarMonth,
        components,
        componentsProps,
        slots,
        slotProps,
        loading,
        renderLoading,
        disableHighlightToday,
        readOnly,
        disabled,
        showDaysOutsideCurrentMonth,
        dayOfWeekFormatter,
        sx,
        autoFocus,
        fixedWeekNumber,
        displayWeekNumber,
        timezone
      }), timeViewsCount > 0 && (0, import_jsx_runtime18.jsxs)(React17.Fragment, {
        children: [(0, import_jsx_runtime17.jsx)(Divider_default, {
          orientation: "vertical"
        }), shouldRenderTimeInASingleColumn ? renderDigitalClockTimeView(_extends({}, commonTimeProps, {
          view: "hours",
          views: ["hours"],
          focusedView: focusedView && isInternalTimeView(focusedView) ? "hours" : null,
          sx: _extends({
            width: "auto",
            [`&.${digitalClockClasses.root}`]: {
              maxHeight: VIEW_HEIGHT
            }
          }, Array.isArray(sx) ? sx : [sx])
        })) : renderMultiSectionDigitalClockTimeView(_extends({}, commonTimeProps, {
          view: isInternalTimeView(view) ? view : "hours",
          views: views.filter(isInternalTimeView),
          focusedView: focusedView && isInternalTimeView(focusedView) ? focusedView : null,
          sx: _extends({
            borderBottom: 0,
            width: "auto",
            [`.${multiSectionDigitalClockSectionClasses.root}`]: {
              maxHeight: "100%"
            }
          }, Array.isArray(sx) ? sx : [sx])
        }))]
      })]
    }), isActionBarVisible && (0, import_jsx_runtime17.jsx)(Divider_default, {})]
  });
};

// node_modules/@mui/x-date-pickers/internals/utils/date-time-utils.js
init_extends();
init_objectWithoutPropertiesLoose();
var _excluded11 = ["views", "format"];
var resolveDateTimeFormat = (utils, _ref) => {
  let {
    views,
    format
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded11);
  if (format) {
    return format;
  }
  const dateViews = [];
  const timeViews = [];
  views.forEach((view) => {
    if (isTimeView(view)) {
      timeViews.push(view);
    } else {
      dateViews.push(view);
    }
  });
  if (timeViews.length === 0) {
    return resolveDateFormat(utils, _extends({
      views: dateViews
    }, other), false);
  }
  if (dateViews.length === 0) {
    return resolveTimeFormat(utils, _extends({
      views: timeViews
    }, other));
  }
  const timeFormat = resolveTimeFormat(utils, _extends({
    views: timeViews
  }, other));
  const dateFormat = resolveDateFormat(utils, _extends({
    views: dateViews
  }, other), false);
  return `${dateFormat} ${timeFormat}`;
};
var resolveViews = (ampm, views, shouldUseSingleColumn) => {
  if (shouldUseSingleColumn) {
    return views.filter((view) => !isInternalTimeView(view) || view === "hours");
  }
  return ampm ? [...views, "meridiem"] : views;
};
var resolveShouldRenderTimeInASingleColumn = (timeSteps, threshold) => {
  var _timeSteps$hours, _timeSteps$minutes;
  return 24 * 60 / (((_timeSteps$hours = timeSteps.hours) != null ? _timeSteps$hours : 1) * ((_timeSteps$minutes = timeSteps.minutes) != null ? _timeSteps$minutes : 5)) <= threshold;
};
function resolveTimeViewsResponse({
  thresholdToRenderTimeInASingleColumn: inThreshold,
  ampm,
  timeSteps: inTimeSteps,
  views
}) {
  const thresholdToRenderTimeInASingleColumn = inThreshold != null ? inThreshold : 24;
  const timeSteps = _extends({
    hours: 1,
    minutes: 5,
    seconds: 5
  }, inTimeSteps);
  const shouldRenderTimeInASingleColumn = resolveShouldRenderTimeInASingleColumn(timeSteps, thresholdToRenderTimeInASingleColumn);
  return {
    thresholdToRenderTimeInASingleColumn,
    timeSteps,
    shouldRenderTimeInASingleColumn,
    views: resolveViews(ampm, views, shouldRenderTimeInASingleColumn)
  };
}

// node_modules/@mui/x-date-pickers/DesktopDateTimePicker/DesktopDateTimePicker.js
var DesktopDateTimePicker = React18.forwardRef(function DesktopDateTimePicker2(inProps, ref) {
  var _defaultizedProps$amp, _defaultizedProps$yea, _defaultizedProps$slo2, _defaultizedProps$slo3, _defaultizedProps$slo4, _props$localeText$ope, _props$localeText;
  const localeText = useLocaleText();
  const utils = useUtils();
  const defaultizedProps = useDateTimePickerDefaultizedProps(inProps, "MuiDesktopDateTimePicker");
  const {
    shouldRenderTimeInASingleColumn,
    thresholdToRenderTimeInASingleColumn,
    views,
    timeSteps
  } = resolveTimeViewsResponse(defaultizedProps);
  const shouldUseNewRenderer = !defaultizedProps.viewRenderers || Object.keys(defaultizedProps.viewRenderers).length === 0;
  const viewRenderers = (
    // we can only ensure the expected two-column layout if none of the renderers are overridden
    shouldUseNewRenderer ? {
      day: renderDesktopDateTimeView,
      month: renderDesktopDateTimeView,
      year: renderDesktopDateTimeView,
      hours: renderDesktopDateTimeView,
      minutes: renderDesktopDateTimeView,
      seconds: renderDesktopDateTimeView,
      meridiem: renderDesktopDateTimeView
    } : _extends({
      day: renderDateViewCalendar,
      month: renderDateViewCalendar,
      year: renderDateViewCalendar,
      hours: null,
      minutes: null,
      seconds: null,
      meridiem: null
    }, defaultizedProps.viewRenderers)
  );
  const ampmInClock = (_defaultizedProps$amp = defaultizedProps.ampmInClock) != null ? _defaultizedProps$amp : true;
  const actionBarActions = shouldUseNewRenderer ? ["accept"] : [];
  const props = _extends({}, defaultizedProps, {
    viewRenderers,
    format: resolveDateTimeFormat(utils, defaultizedProps),
    views,
    yearsPerRow: (_defaultizedProps$yea = defaultizedProps.yearsPerRow) != null ? _defaultizedProps$yea : 4,
    ampmInClock,
    timeSteps,
    thresholdToRenderTimeInASingleColumn,
    shouldRenderTimeInASingleColumn,
    slots: _extends({
      field: DateTimeField,
      openPickerIcon: CalendarIcon
    }, defaultizedProps.slots),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _defaultizedProps$slo;
        return _extends({}, resolveComponentProps((_defaultizedProps$slo = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends({
        hidden: true,
        ampmInClock,
        toolbarVariant: shouldUseNewRenderer ? "desktop" : "mobile"
      }, (_defaultizedProps$slo2 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo2.toolbar),
      tabs: _extends({
        hidden: true
      }, (_defaultizedProps$slo3 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo3.tabs),
      actionBar: _extends({
        actions: actionBarActions
      }, (_defaultizedProps$slo4 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo4.actionBar)
    })
  });
  const {
    renderPicker
  } = useDesktopPicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "date-time",
    getOpenDialogAriaText: (_props$localeText$ope = (_props$localeText = props.localeText) == null ? void 0 : _props$localeText.openDatePickerDialogue) != null ? _props$localeText$ope : localeText.openDatePickerDialogue,
    validator: validateDateTime
  });
  return renderPicker();
});
DesktopDateTimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: import_prop_types7.default.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: import_prop_types7.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types7.default.bool,
  /**
   * Class name applied to the root element.
   */
  className: import_prop_types7.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types7.default.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types7.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types7.default.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter.  Deprecated, will be removed in v7: Use `date` instead.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (_day: string, date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types7.default.func,
  /**
   * Default calendar month displayed when `value` and `defaultValue` are empty.
   * @deprecated Consider using `referenceDate` instead.
   */
  defaultCalendarMonth: import_prop_types7.default.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types7.default.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types7.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types7.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types7.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types7.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types7.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types7.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types7.default.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: import_prop_types7.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types7.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types7.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types7.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types7.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types7.default.object,
  /**
   * Maximal selectable date.
   */
  maxDate: import_prop_types7.default.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: import_prop_types7.default.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types7.default.any,
  /**
   * Minimal selectable date.
   */
  minDate: import_prop_types7.default.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: import_prop_types7.default.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types7.default.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types7.default.number,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: import_prop_types7.default.oneOf([3, 4]),
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: import_prop_types7.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: import_prop_types7.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types7.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types7.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types7.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types7.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types7.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types7.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types7.default.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: import_prop_types7.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types7.default.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types7.default.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: import_prop_types7.default.oneOf(["landscape", "portrait"]),
  readOnly: import_prop_types7.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types7.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types7.default.any,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: import_prop_types7.default.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types7.default.oneOfType([import_prop_types7.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types7.default.number, import_prop_types7.default.shape({
    endIndex: import_prop_types7.default.number.isRequired,
    startIndex: import_prop_types7.default.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: import_prop_types7.default.func,
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (e.g. when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: import_prop_types7.default.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: import_prop_types7.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types7.default.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: import_prop_types7.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types7.default.bool,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: import_prop_types7.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types7.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types7.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types7.default.oneOfType([import_prop_types7.default.arrayOf(import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object, import_prop_types7.default.bool])), import_prop_types7.default.func, import_prop_types7.default.object]),
  /**
   * Amount of time options below or at which the single column time renderer is used.
   * @default 24
   */
  thresholdToRenderTimeInASingleColumn: import_prop_types7.default.number,
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: import_prop_types7.default.shape({
    hours: import_prop_types7.default.number,
    minutes: import_prop_types7.default.number,
    seconds: import_prop_types7.default.number
  }),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types7.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types7.default.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types7.default.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: import_prop_types7.default.shape({
    day: import_prop_types7.default.func,
    hours: import_prop_types7.default.func,
    meridiem: import_prop_types7.default.func,
    minutes: import_prop_types7.default.func,
    month: import_prop_types7.default.func,
    seconds: import_prop_types7.default.func,
    year: import_prop_types7.default.func
  }),
  /**
   * Available views.
   */
  views: import_prop_types7.default.arrayOf(import_prop_types7.default.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4
   */
  yearsPerRow: import_prop_types7.default.oneOf([3, 4])
};

// node_modules/@mui/x-date-pickers/MobileDateTimePicker/MobileDateTimePicker.js
init_extends();
var React19 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());
init_utils();
var MobileDateTimePicker = React19.forwardRef(function MobileDateTimePicker2(inProps, ref) {
  var _defaultizedProps$amp, _defaultizedProps$slo2, _defaultizedProps$slo3, _props$localeText$ope, _props$localeText;
  const localeText = useLocaleText();
  const utils = useUtils();
  const defaultizedProps = useDateTimePickerDefaultizedProps(inProps, "MuiMobileDateTimePicker");
  const viewRenderers = _extends({
    day: renderDateViewCalendar,
    month: renderDateViewCalendar,
    year: renderDateViewCalendar,
    hours: renderTimeViewClock,
    minutes: renderTimeViewClock,
    seconds: renderTimeViewClock
  }, defaultizedProps.viewRenderers);
  const ampmInClock = (_defaultizedProps$amp = defaultizedProps.ampmInClock) != null ? _defaultizedProps$amp : false;
  const props = _extends({}, defaultizedProps, {
    viewRenderers,
    format: resolveDateTimeFormat(utils, defaultizedProps),
    ampmInClock,
    slots: _extends({
      field: DateTimeField
    }, defaultizedProps.slots),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _defaultizedProps$slo;
        return _extends({}, resolveComponentProps((_defaultizedProps$slo = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends({
        hidden: false,
        ampmInClock
      }, (_defaultizedProps$slo2 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo2.toolbar),
      tabs: _extends({
        hidden: false
      }, (_defaultizedProps$slo3 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo3.tabs)
    })
  });
  const {
    renderPicker
  } = useMobilePicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "date-time",
    getOpenDialogAriaText: (_props$localeText$ope = (_props$localeText = props.localeText) == null ? void 0 : _props$localeText.openDatePickerDialogue) != null ? _props$localeText$ope : localeText.openDatePickerDialogue,
    validator: validateDateTime
  });
  return renderPicker();
});
MobileDateTimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: import_prop_types8.default.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: import_prop_types8.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types8.default.bool,
  /**
   * Class name applied to the root element.
   */
  className: import_prop_types8.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types8.default.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types8.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types8.default.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter.  Deprecated, will be removed in v7: Use `date` instead.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (_day: string, date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types8.default.func,
  /**
   * Default calendar month displayed when `value` and `defaultValue` are empty.
   * @deprecated Consider using `referenceDate` instead.
   */
  defaultCalendarMonth: import_prop_types8.default.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types8.default.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types8.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types8.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types8.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types8.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types8.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types8.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types8.default.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: import_prop_types8.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types8.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types8.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types8.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types8.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types8.default.object,
  /**
   * Maximal selectable date.
   */
  maxDate: import_prop_types8.default.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: import_prop_types8.default.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types8.default.any,
  /**
   * Minimal selectable date.
   */
  minDate: import_prop_types8.default.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: import_prop_types8.default.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types8.default.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types8.default.number,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: import_prop_types8.default.oneOf([3, 4]),
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: import_prop_types8.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: import_prop_types8.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types8.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types8.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types8.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types8.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types8.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types8.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types8.default.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: import_prop_types8.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types8.default.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types8.default.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: import_prop_types8.default.oneOf(["landscape", "portrait"]),
  readOnly: import_prop_types8.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types8.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types8.default.any,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: import_prop_types8.default.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types8.default.oneOfType([import_prop_types8.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types8.default.number, import_prop_types8.default.shape({
    endIndex: import_prop_types8.default.number.isRequired,
    startIndex: import_prop_types8.default.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: import_prop_types8.default.func,
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (e.g. when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: import_prop_types8.default.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: import_prop_types8.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types8.default.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: import_prop_types8.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types8.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types8.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types8.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types8.default.oneOfType([import_prop_types8.default.arrayOf(import_prop_types8.default.oneOfType([import_prop_types8.default.func, import_prop_types8.default.object, import_prop_types8.default.bool])), import_prop_types8.default.func, import_prop_types8.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types8.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types8.default.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types8.default.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: import_prop_types8.default.shape({
    day: import_prop_types8.default.func,
    hours: import_prop_types8.default.func,
    minutes: import_prop_types8.default.func,
    month: import_prop_types8.default.func,
    seconds: import_prop_types8.default.func,
    year: import_prop_types8.default.func
  }),
  /**
   * Available views.
   */
  views: import_prop_types8.default.arrayOf(import_prop_types8.default.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 3
   */
  yearsPerRow: import_prop_types8.default.oneOf([3, 4])
};

// node_modules/@mui/x-date-pickers/DateTimePicker/DateTimePicker.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var _excluded12 = ["desktopModeMediaQuery"];
var DateTimePicker = React20.forwardRef(function DateTimePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDateTimePicker"
  });
  const {
    desktopModeMediaQuery = DEFAULT_DESKTOP_MODE_MEDIA_QUERY
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded12);
  const isDesktop = useMediaQuery(desktopModeMediaQuery, {
    defaultMatches: true
  });
  if (isDesktop) {
    return (0, import_jsx_runtime19.jsx)(DesktopDateTimePicker, _extends({
      ref
    }, other));
  }
  return (0, import_jsx_runtime19.jsx)(MobileDateTimePicker, _extends({
    ref
  }, other));
});
true ? DateTimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: import_prop_types9.default.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: import_prop_types9.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types9.default.bool,
  /**
   * Class name applied to the root element.
   */
  className: import_prop_types9.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types9.default.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types9.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types9.default.object,
  /**
   * Formats the day of week displayed in the calendar header.
   * @param {string} day The day of week provided by the adapter.  Deprecated, will be removed in v7: Use `date` instead.
   * @param {TDate} date The date of the day of week provided by the adapter.
   * @returns {string} The name to display.
   * @default (_day: string, date: TDate) => adapter.format(date, 'weekdayShort').charAt(0).toUpperCase()
   */
  dayOfWeekFormatter: import_prop_types9.default.func,
  /**
   * Default calendar month displayed when `value` and `defaultValue` are empty.
   * @deprecated Consider using `referenceDate` instead.
   */
  defaultCalendarMonth: import_prop_types9.default.any,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types9.default.any,
  /**
   * CSS media query when `Mobile` mode will be changed to `Desktop`.
   * @default '@media (pointer: fine)'
   * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
   */
  desktopModeMediaQuery: import_prop_types9.default.string,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types9.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types9.default.bool,
  /**
   * If `true`, today's date is rendering without highlighting with circle.
   * @default false
   */
  disableHighlightToday: import_prop_types9.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types9.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types9.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types9.default.bool,
  /**
   * If `true`, the week number will be display in the calendar.
   */
  displayWeekNumber: import_prop_types9.default.bool,
  /**
   * Calendar will show more weeks in order to match this value.
   * Put it to 6 for having fix number of week in Gregorian calendars
   * @default undefined
   */
  fixedWeekNumber: import_prop_types9.default.number,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types9.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types9.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types9.default.node,
  /**
   * If `true`, calls `renderLoading` instead of rendering the day calendar.
   * Can be used to preload information and show it in calendar.
   * @default false
   */
  loading: import_prop_types9.default.bool,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types9.default.object,
  /**
   * Maximal selectable date.
   */
  maxDate: import_prop_types9.default.any,
  /**
   * Maximal selectable moment of time with binding to date, to set max time in each day use `maxTime`.
   */
  maxDateTime: import_prop_types9.default.any,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types9.default.any,
  /**
   * Minimal selectable date.
   */
  minDate: import_prop_types9.default.any,
  /**
   * Minimal selectable moment of time with binding to date, to set min time in each day use `minTime`.
   */
  minDateTime: import_prop_types9.default.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types9.default.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types9.default.number,
  /**
   * Months rendered per row.
   * @default 3
   */
  monthsPerRow: import_prop_types9.default.oneOf([3, 4]),
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: import_prop_types9.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: import_prop_types9.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types9.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types9.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types9.default.func,
  /**
   * Callback fired on month change.
   * @template TDate
   * @param {TDate} month The new month.
   */
  onMonthChange: import_prop_types9.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types9.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types9.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types9.default.func,
  /**
   * Callback fired on year change.
   * @template TDate
   * @param {TDate} year The new year.
   */
  onYearChange: import_prop_types9.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types9.default.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types9.default.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: import_prop_types9.default.oneOf(["landscape", "portrait"]),
  readOnly: import_prop_types9.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types9.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types9.default.any,
  /**
   * Component displaying when passed `loading` true.
   * @returns {React.ReactNode} The node to render when loading.
   * @default () => <span data-mui-test="loading-progress">...</span>
   */
  renderLoading: import_prop_types9.default.func,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types9.default.oneOfType([import_prop_types9.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types9.default.number, import_prop_types9.default.shape({
    endIndex: import_prop_types9.default.number.isRequired,
    startIndex: import_prop_types9.default.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: import_prop_types9.default.func,
  /**
   * Disable specific date.
   *
   * Warning: This function can be called multiple times (e.g. when rendering date calendar, checking if focus can be moved to a certain date, etc.). Expensive computations can impact performance.
   *
   * @template TDate
   * @param {TDate} day The date to test.
   * @returns {boolean} If `true` the date will be disabled.
   */
  shouldDisableDate: import_prop_types9.default.func,
  /**
   * Disable specific month.
   * @template TDate
   * @param {TDate} month The month to test.
   * @returns {boolean} If `true`, the month will be disabled.
   */
  shouldDisableMonth: import_prop_types9.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types9.default.func,
  /**
   * Disable specific year.
   * @template TDate
   * @param {TDate} year The year to test.
   * @returns {boolean} If `true`, the year will be disabled.
   */
  shouldDisableYear: import_prop_types9.default.func,
  /**
   * If `true`, days outside the current month are rendered:
   *
   * - if `fixedWeekNumber` is defined, renders days to have the weeks requested.
   *
   * - if `fixedWeekNumber` is not defined, renders day to fill the first and last week of the current month.
   *
   * - ignored if `calendars` equals more than `1` on range pickers.
   * @default false
   */
  showDaysOutsideCurrentMonth: import_prop_types9.default.bool,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: import_prop_types9.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types9.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types9.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.func, import_prop_types9.default.object, import_prop_types9.default.bool])), import_prop_types9.default.func, import_prop_types9.default.object]),
  /**
   * Amount of time options below or at which the single column time renderer is used.
   * @default 24
   */
  thresholdToRenderTimeInASingleColumn: import_prop_types9.default.number,
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: import_prop_types9.default.shape({
    hours: import_prop_types9.default.number,
    minutes: import_prop_types9.default.number,
    seconds: import_prop_types9.default.number
  }),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types9.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types9.default.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types9.default.oneOf(["day", "hours", "meridiem", "minutes", "month", "seconds", "year"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: import_prop_types9.default.shape({
    day: import_prop_types9.default.func,
    hours: import_prop_types9.default.func,
    meridiem: import_prop_types9.default.func,
    minutes: import_prop_types9.default.func,
    month: import_prop_types9.default.func,
    seconds: import_prop_types9.default.func,
    year: import_prop_types9.default.func
  }),
  /**
   * Available views.
   */
  views: import_prop_types9.default.arrayOf(import_prop_types9.default.oneOf(["day", "hours", "minutes", "month", "seconds", "year"]).isRequired),
  /**
   * Years rendered per row.
   * @default 4 on desktop, 3 on mobile
   */
  yearsPerRow: import_prop_types9.default.oneOf([3, 4])
} : void 0;

// node_modules/@mui/x-date-pickers/TimePicker/TimePicker.js
init_extends();
init_objectWithoutPropertiesLoose();
var React26 = __toESM(require_react());
var import_prop_types14 = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-date-pickers/DesktopTimePicker/DesktopTimePicker.js
init_extends();
var React24 = __toESM(require_react());
var import_prop_types12 = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-date-pickers/TimeField/TimeField.js
init_extends();
init_objectWithoutPropertiesLoose();
var React21 = __toESM(require_react());
var import_prop_types10 = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-date-pickers/TimeField/useTimeField.js
init_extends();
var useDefaultizedTimeField = (props) => {
  var _props$ampm, _props$disablePast, _props$disableFuture, _props$format;
  const utils = useUtils();
  const ampm = (_props$ampm = props.ampm) != null ? _props$ampm : utils.is12HourCycleInCurrentLocale();
  const defaultFormat = ampm ? utils.formats.fullTime12h : utils.formats.fullTime24h;
  return _extends({}, props, {
    disablePast: (_props$disablePast = props.disablePast) != null ? _props$disablePast : false,
    disableFuture: (_props$disableFuture = props.disableFuture) != null ? _props$disableFuture : false,
    format: (_props$format = props.format) != null ? _props$format : defaultFormat
  });
};
var useTimeField = ({
  props: inProps,
  inputRef
}) => {
  const props = useDefaultizedTimeField(inProps);
  const {
    forwardedProps,
    internalProps
  } = splitFieldInternalAndForwardedProps(props, "time");
  return useField({
    inputRef,
    forwardedProps,
    internalProps,
    valueManager: singleItemValueManager,
    fieldValueManager: singleItemFieldValueManager,
    validator: validateTime,
    valueType: "time"
  });
};

// node_modules/@mui/x-date-pickers/TimeField/TimeField.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var _excluded13 = ["slots", "slotProps", "components", "componentsProps", "InputProps", "inputProps"];
var _excluded22 = ["inputRef"];
var _excluded32 = ["ref", "onPaste", "onKeyDown", "inputMode", "readOnly", "clearable", "onClear"];
var TimeField = React21.forwardRef(function TimeField2(inProps, ref) {
  var _ref, _slots$textField, _slotProps$textField;
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiTimeField"
  });
  const {
    slots,
    slotProps,
    components,
    componentsProps,
    InputProps,
    inputProps
  } = themeProps, other = _objectWithoutPropertiesLoose(themeProps, _excluded13);
  const ownerState = themeProps;
  const TextField = (_ref = (_slots$textField = slots == null ? void 0 : slots.textField) != null ? _slots$textField : components == null ? void 0 : components.TextField) != null ? _ref : TextField_default;
  const _useSlotProps = useSlotProps({
    elementType: TextField,
    externalSlotProps: (_slotProps$textField = slotProps == null ? void 0 : slotProps.textField) != null ? _slotProps$textField : componentsProps == null ? void 0 : componentsProps.textField,
    externalForwardedProps: other,
    ownerState
  }), {
    inputRef: externalInputRef
  } = _useSlotProps, textFieldProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded22);
  textFieldProps.inputProps = _extends({}, inputProps, textFieldProps.inputProps);
  textFieldProps.InputProps = _extends({}, InputProps, textFieldProps.InputProps);
  const _useTimeField = useTimeField({
    props: textFieldProps,
    inputRef: externalInputRef
  }), {
    ref: inputRef,
    onPaste,
    onKeyDown,
    inputMode,
    readOnly,
    clearable,
    onClear
  } = _useTimeField, fieldProps = _objectWithoutPropertiesLoose(_useTimeField, _excluded32);
  const {
    InputProps: ProcessedInputProps,
    fieldProps: processedFieldProps
  } = useClearableField({
    onClear,
    clearable,
    fieldProps,
    InputProps: fieldProps.InputProps,
    slots,
    slotProps,
    components,
    componentsProps
  });
  return (0, import_jsx_runtime20.jsx)(TextField, _extends({
    ref
  }, processedFieldProps, {
    InputProps: _extends({}, ProcessedInputProps, {
      readOnly
    }),
    inputProps: _extends({}, fieldProps.inputProps, {
      inputMode,
      onPaste,
      onKeyDown,
      ref: inputRef
    })
  }));
});
true ? TimeField.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: import_prop_types10.default.bool,
  /**
   * If `true`, the `input` element is focused during the first mount.
   * @default false
   */
  autoFocus: import_prop_types10.default.bool,
  className: import_prop_types10.default.string,
  /**
   * If `true`, a clear button will be shown in the field allowing value clearing.
   * @default false
   */
  clearable: import_prop_types10.default.bool,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * @default 'primary'
   */
  color: import_prop_types10.default.oneOf(["error", "info", "primary", "secondary", "success", "warning"]),
  component: import_prop_types10.default.elementType,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types10.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types10.default.object,
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: import_prop_types10.default.any,
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: import_prop_types10.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types10.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types10.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types10.default.bool,
  /**
   * If `true`, the component is displayed in focused state.
   */
  focused: import_prop_types10.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   */
  format: import_prop_types10.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types10.default.oneOf(["dense", "spacious"]),
  /**
   * Props applied to the [`FormHelperText`](/material-ui/api/form-helper-text/) element.
   */
  FormHelperTextProps: import_prop_types10.default.object,
  /**
   * If `true`, the input will take up the full width of its container.
   * @default false
   */
  fullWidth: import_prop_types10.default.bool,
  /**
   * The helper text content.
   */
  helperText: import_prop_types10.default.node,
  /**
   * If `true`, the label is hidden.
   * This is used to increase density for a `FilledInput`.
   * Be sure to add `aria-label` to the `input` element.
   * @default false
   */
  hiddenLabel: import_prop_types10.default.bool,
  /**
   * The id of the `input` element.
   * Use this prop to make `label` and `helperText` accessible for screen readers.
   */
  id: import_prop_types10.default.string,
  /**
   * Props applied to the [`InputLabel`](/material-ui/api/input-label/) element.
   * Pointer events like `onClick` are enabled if and only if `shrink` is `true`.
   */
  InputLabelProps: import_prop_types10.default.object,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   */
  inputProps: import_prop_types10.default.object,
  /**
   * Props applied to the Input element.
   * It will be a [`FilledInput`](/material-ui/api/filled-input/),
   * [`OutlinedInput`](/material-ui/api/outlined-input/) or [`Input`](/material-ui/api/input/)
   * component depending on the `variant` prop value.
   */
  InputProps: import_prop_types10.default.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types10.default.node,
  /**
   * If `dense` or `normal`, will adjust vertical spacing of this and contained components.
   * @default 'none'
   */
  margin: import_prop_types10.default.oneOf(["dense", "none", "normal"]),
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types10.default.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types10.default.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types10.default.number,
  /**
   * Name attribute of the `input` element.
   */
  name: import_prop_types10.default.string,
  onBlur: import_prop_types10.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types10.default.func,
  /**
   * Callback fired when the clear button is clicked.
   */
  onClear: import_prop_types10.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types10.default.func,
  onFocus: import_prop_types10.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types10.default.func,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   * @default false
   */
  readOnly: import_prop_types10.default.bool,
  /**
   * The date used to generate a part of the new value that is not present in the format when both `value` and `defaultValue` are empty.
   * For example, on time fields it will be used to determine the date to set.
   * @default The closest valid date using the validation props, except callbacks such as `shouldDisableDate`. Value is rounded to the most granular section used.
   */
  referenceDate: import_prop_types10.default.any,
  /**
   * If `true`, the label is displayed as required and the `input` element is required.
   * @default false
   */
  required: import_prop_types10.default.bool,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types10.default.oneOfType([import_prop_types10.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types10.default.number, import_prop_types10.default.shape({
    endIndex: import_prop_types10.default.number.isRequired,
    startIndex: import_prop_types10.default.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: import_prop_types10.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types10.default.func,
  /**
   * If `true`, the format will respect the leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `8/16/2018`)
   * If `false`, the format will always add leading zeroes (e.g: on dayjs, the format `M/D/YYYY` will render `08/16/2018`)
   *
   * Warning nÂ°1: Luxon is not able to respect the leading zeroes when using macro tokens (e.g: "DD"), so `shouldRespectLeadingZeros={true}` might lead to inconsistencies when using `AdapterLuxon`.
   *
   * Warning nÂ°2: When `shouldRespectLeadingZeros={true}`, the field will add an invisible character on the sections containing a single digit to make sure `onChange` is fired.
   * If you need to get the clean value from the input, you can remove this character using `input.value.replace(/\u200e/g, '')`.
   *
   * Warning nÂ°3: When used in strict mode, dayjs and moment require to respect the leading zeros.
   * This mean that when using `shouldRespectLeadingZeros={false}`, if you retrieve the value directly from the input (not listening to `onChange`) and your format contains tokens without leading zeros, the value will not be parsed by your library.
   *
   * @default `false`
   */
  shouldRespectLeadingZeros: import_prop_types10.default.bool,
  /**
   * The size of the component.
   */
  size: import_prop_types10.default.oneOf(["medium", "small"]),
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types10.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types10.default.object,
  style: import_prop_types10.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object, import_prop_types10.default.bool])), import_prop_types10.default.func, import_prop_types10.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types10.default.string,
  /**
   * The ref object used to imperatively interact with the field.
   */
  unstableFieldRef: import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object]),
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types10.default.any,
  /**
   * The variant to use.
   * @default 'outlined'
   */
  variant: import_prop_types10.default.oneOf(["filled", "outlined", "standard"])
} : void 0;

// node_modules/@mui/x-date-pickers/TimePicker/shared.js
init_extends();
var React23 = __toESM(require_react());

// node_modules/@mui/x-date-pickers/TimePicker/TimePickerToolbar.js
init_objectWithoutPropertiesLoose();
init_extends();
var React22 = __toESM(require_react());
var import_prop_types11 = __toESM(require_prop_types());
init_utils();

// node_modules/@mui/x-date-pickers/TimePicker/timePickerToolbarClasses.js
init_utils();
function getTimePickerToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiTimePickerToolbar", slot);
}
var timePickerToolbarClasses = generateUtilityClasses("MuiTimePickerToolbar", ["root", "separator", "hourMinuteLabel", "hourMinuteLabelLandscape", "hourMinuteLabelReverse", "ampmSelection", "ampmLandscape", "ampmLabel"]);

// node_modules/@mui/x-date-pickers/TimePicker/TimePickerToolbar.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var _excluded14 = ["ampm", "ampmInClock", "value", "isLandscape", "onChange", "view", "onViewChange", "views", "disabled", "readOnly"];
var useUtilityClasses10 = (ownerState) => {
  const {
    theme,
    isLandscape,
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    separator: ["separator"],
    hourMinuteLabel: ["hourMinuteLabel", isLandscape && "hourMinuteLabelLandscape", theme.direction === "rtl" && "hourMinuteLabelReverse"],
    ampmSelection: ["ampmSelection", isLandscape && "ampmLandscape"],
    ampmLabel: ["ampmLabel"]
  };
  return composeClasses(slots, getTimePickerToolbarUtilityClass, classes);
};
var TimePickerToolbarRoot = styled_default(PickersToolbar, {
  name: "MuiTimePickerToolbar",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
var TimePickerToolbarSeparator = styled_default(PickersToolbarText, {
  name: "MuiTimePickerToolbar",
  slot: "Separator",
  overridesResolver: (props, styles) => styles.separator
})({
  outline: 0,
  margin: "0 4px 0 2px",
  cursor: "default"
});
var TimePickerToolbarHourMinuteLabel = styled_default("div", {
  name: "MuiTimePickerToolbar",
  slot: "HourMinuteLabel",
  overridesResolver: (props, styles) => [{
    [`&.${timePickerToolbarClasses.hourMinuteLabelLandscape}`]: styles.hourMinuteLabelLandscape,
    [`&.${timePickerToolbarClasses.hourMinuteLabelReverse}`]: styles.hourMinuteLabelReverse
  }, styles.hourMinuteLabel]
})(({
  theme,
  ownerState
}) => _extends({
  display: "flex",
  justifyContent: "flex-end",
  alignItems: "flex-end"
}, ownerState.isLandscape && {
  marginTop: "auto"
}, theme.direction === "rtl" && {
  flexDirection: "row-reverse"
}));
TimePickerToolbarHourMinuteLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  as: import_prop_types11.default.elementType,
  ownerState: import_prop_types11.default.object.isRequired,
  sx: import_prop_types11.default.oneOfType([import_prop_types11.default.arrayOf(import_prop_types11.default.oneOfType([import_prop_types11.default.func, import_prop_types11.default.object, import_prop_types11.default.bool])), import_prop_types11.default.func, import_prop_types11.default.object])
};
var TimePickerToolbarAmPmSelection = styled_default("div", {
  name: "MuiTimePickerToolbar",
  slot: "AmPmSelection",
  overridesResolver: (props, styles) => [{
    [`.${timePickerToolbarClasses.ampmLabel}`]: styles.ampmLabel
  }, {
    [`&.${timePickerToolbarClasses.ampmLandscape}`]: styles.ampmLandscape
  }, styles.ampmSelection]
})(({
  ownerState
}) => _extends({
  display: "flex",
  flexDirection: "column",
  marginRight: "auto",
  marginLeft: 12
}, ownerState.isLandscape && {
  margin: "4px 0 auto",
  flexDirection: "row",
  justifyContent: "space-around",
  flexBasis: "100%"
}, {
  [`& .${timePickerToolbarClasses.ampmLabel}`]: {
    fontSize: 17
  }
}));
TimePickerToolbarAmPmSelection.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  as: import_prop_types11.default.elementType,
  ownerState: import_prop_types11.default.object.isRequired,
  sx: import_prop_types11.default.oneOfType([import_prop_types11.default.arrayOf(import_prop_types11.default.oneOfType([import_prop_types11.default.func, import_prop_types11.default.object, import_prop_types11.default.bool])), import_prop_types11.default.func, import_prop_types11.default.object])
};
function TimePickerToolbar(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTimePickerToolbar"
  });
  const {
    ampm,
    ampmInClock,
    value,
    isLandscape,
    onChange,
    view,
    onViewChange,
    views,
    disabled,
    readOnly
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded14);
  const utils = useUtils();
  const localeText = useLocaleText();
  const theme = useTheme();
  const showAmPmControl = Boolean(ampm && !ampmInClock && views.includes("hours"));
  const {
    meridiemMode,
    handleMeridiemChange
  } = useMeridiemMode(value, ampm, onChange);
  const formatHours = (time) => ampm ? utils.format(time, "hours12h") : utils.format(time, "hours24h");
  const ownerState = props;
  const classes = useUtilityClasses10(_extends({}, ownerState, {
    theme
  }));
  const separator = (0, import_jsx_runtime21.jsx)(TimePickerToolbarSeparator, {
    tabIndex: -1,
    value: ":",
    variant: "h3",
    selected: false,
    className: classes.separator
  });
  return (0, import_jsx_runtime22.jsxs)(TimePickerToolbarRoot, _extends({
    landscapeDirection: "row",
    toolbarTitle: localeText.timePickerToolbarTitle,
    isLandscape,
    ownerState,
    className: classes.root
  }, other, {
    children: [(0, import_jsx_runtime22.jsxs)(TimePickerToolbarHourMinuteLabel, {
      className: classes.hourMinuteLabel,
      ownerState,
      children: [arrayIncludes(views, "hours") && (0, import_jsx_runtime21.jsx)(PickersToolbarButton, {
        tabIndex: -1,
        variant: "h3",
        onClick: () => onViewChange("hours"),
        selected: view === "hours",
        value: value ? formatHours(value) : "--"
      }), arrayIncludes(views, ["hours", "minutes"]) && separator, arrayIncludes(views, "minutes") && (0, import_jsx_runtime21.jsx)(PickersToolbarButton, {
        tabIndex: -1,
        variant: "h3",
        onClick: () => onViewChange("minutes"),
        selected: view === "minutes",
        value: value ? utils.format(value, "minutes") : "--"
      }), arrayIncludes(views, ["minutes", "seconds"]) && separator, arrayIncludes(views, "seconds") && (0, import_jsx_runtime21.jsx)(PickersToolbarButton, {
        variant: "h3",
        onClick: () => onViewChange("seconds"),
        selected: view === "seconds",
        value: value ? utils.format(value, "seconds") : "--"
      })]
    }), showAmPmControl && (0, import_jsx_runtime22.jsxs)(TimePickerToolbarAmPmSelection, {
      className: classes.ampmSelection,
      ownerState,
      children: [(0, import_jsx_runtime21.jsx)(PickersToolbarButton, {
        disableRipple: true,
        variant: "subtitle2",
        selected: meridiemMode === "am",
        typographyClassName: classes.ampmLabel,
        value: formatMeridiem(utils, "am"),
        onClick: readOnly ? void 0 : () => handleMeridiemChange("am"),
        disabled
      }), (0, import_jsx_runtime21.jsx)(PickersToolbarButton, {
        disableRipple: true,
        variant: "subtitle2",
        selected: meridiemMode === "pm",
        typographyClassName: classes.ampmLabel,
        value: formatMeridiem(utils, "pm"),
        onClick: readOnly ? void 0 : () => handleMeridiemChange("pm"),
        disabled
      })]
    })]
  }));
}
true ? TimePickerToolbar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  ampm: import_prop_types11.default.bool,
  ampmInClock: import_prop_types11.default.bool,
  classes: import_prop_types11.default.object,
  /**
   * className applied to the root component.
   */
  className: import_prop_types11.default.string,
  disabled: import_prop_types11.default.bool,
  /**
   * If `true`, show the toolbar even in desktop mode.
   * @default `true` for Desktop, `false` for Mobile.
   */
  hidden: import_prop_types11.default.bool,
  isLandscape: import_prop_types11.default.bool.isRequired,
  onChange: import_prop_types11.default.func.isRequired,
  /**
   * Callback called when a toolbar is clicked
   * @template TView
   * @param {TView} view The view to open
   */
  onViewChange: import_prop_types11.default.func.isRequired,
  readOnly: import_prop_types11.default.bool,
  sx: import_prop_types11.default.oneOfType([import_prop_types11.default.arrayOf(import_prop_types11.default.oneOfType([import_prop_types11.default.func, import_prop_types11.default.object, import_prop_types11.default.bool])), import_prop_types11.default.func, import_prop_types11.default.object]),
  titleId: import_prop_types11.default.string,
  /**
   * Toolbar date format.
   */
  toolbarFormat: import_prop_types11.default.string,
  /**
   * Toolbar value placeholderâ€”it is displayed when the value is empty.
   * @default "â€“â€“"
   */
  toolbarPlaceholder: import_prop_types11.default.node,
  value: import_prop_types11.default.any,
  /**
   * Currently visible picker view.
   */
  view: import_prop_types11.default.oneOf(["hours", "meridiem", "minutes", "seconds"]).isRequired,
  views: import_prop_types11.default.arrayOf(import_prop_types11.default.oneOf(["hours", "meridiem", "minutes", "seconds"]).isRequired).isRequired
} : void 0;

// node_modules/@mui/x-date-pickers/TimePicker/shared.js
function useTimePickerDefaultizedProps(props, name) {
  var _themeProps$ampm, _themeProps$slots, _themeProps$slotProps, _themeProps$disableFu, _themeProps$disablePa;
  const utils = useUtils();
  const themeProps = useThemeProps({
    props,
    name
  });
  const ampm = (_themeProps$ampm = themeProps.ampm) != null ? _themeProps$ampm : utils.is12HourCycleInCurrentLocale();
  const localeText = React23.useMemo(() => {
    var _themeProps$localeTex;
    if (((_themeProps$localeTex = themeProps.localeText) == null ? void 0 : _themeProps$localeTex.toolbarTitle) == null) {
      return themeProps.localeText;
    }
    return _extends({}, themeProps.localeText, {
      timePickerToolbarTitle: themeProps.localeText.toolbarTitle
    });
  }, [themeProps.localeText]);
  const slots = (_themeProps$slots = themeProps.slots) != null ? _themeProps$slots : uncapitalizeObjectKeys(themeProps.components);
  const slotProps = (_themeProps$slotProps = themeProps.slotProps) != null ? _themeProps$slotProps : themeProps.componentsProps;
  return _extends({}, themeProps, {
    ampm,
    localeText
  }, applyDefaultViewProps({
    views: themeProps.views,
    openTo: themeProps.openTo,
    defaultViews: ["hours", "minutes"],
    defaultOpenTo: "hours"
  }), {
    disableFuture: (_themeProps$disableFu = themeProps.disableFuture) != null ? _themeProps$disableFu : false,
    disablePast: (_themeProps$disablePa = themeProps.disablePast) != null ? _themeProps$disablePa : false,
    slots: _extends({
      toolbar: TimePickerToolbar
    }, slots),
    slotProps: _extends({}, slotProps, {
      toolbar: _extends({
        ampm,
        ampmInClock: themeProps.ampmInClock
      }, slotProps == null ? void 0 : slotProps.toolbar)
    })
  });
}

// node_modules/@mui/x-date-pickers/DesktopTimePicker/DesktopTimePicker.js
var DesktopTimePicker = React24.forwardRef(function DesktopTimePicker2(inProps, ref) {
  var _defaultizedProps$amp, _viewRenderers$hours, _defaultizedProps$slo2, _defaultizedProps$slo3, _props$localeText$ope, _props$localeText;
  const localeText = useLocaleText();
  const utils = useUtils();
  const defaultizedProps = useTimePickerDefaultizedProps(inProps, "MuiDesktopTimePicker");
  const {
    shouldRenderTimeInASingleColumn,
    views: resolvedViews,
    timeSteps
  } = resolveTimeViewsResponse(defaultizedProps);
  const renderTimeView = shouldRenderTimeInASingleColumn ? renderDigitalClockTimeView : renderMultiSectionDigitalClockTimeView;
  const viewRenderers = _extends({
    hours: renderTimeView,
    minutes: renderTimeView,
    seconds: renderTimeView,
    meridiem: renderTimeView
  }, defaultizedProps.viewRenderers);
  const ampmInClock = (_defaultizedProps$amp = defaultizedProps.ampmInClock) != null ? _defaultizedProps$amp : true;
  const actionBarActions = shouldRenderTimeInASingleColumn ? [] : ["accept"];
  const shouldHoursRendererContainMeridiemView = ((_viewRenderers$hours = viewRenderers.hours) == null ? void 0 : _viewRenderers$hours.name) === renderMultiSectionDigitalClockTimeView.name;
  const views = !shouldHoursRendererContainMeridiemView ? resolvedViews.filter((view) => view !== "meridiem") : resolvedViews;
  const props = _extends({}, defaultizedProps, {
    ampmInClock,
    timeSteps,
    viewRenderers,
    format: resolveTimeFormat(utils, defaultizedProps),
    // Setting only `hours` time view in case of single column time picker
    // Allows for easy view lifecycle management
    views: shouldRenderTimeInASingleColumn ? ["hours"] : views,
    slots: _extends({
      field: TimeField,
      openPickerIcon: ClockIcon
    }, defaultizedProps.slots),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _defaultizedProps$slo;
        return _extends({}, resolveComponentProps((_defaultizedProps$slo = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends({
        hidden: true,
        ampmInClock
      }, (_defaultizedProps$slo2 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo2.toolbar),
      actionBar: _extends({
        actions: actionBarActions
      }, (_defaultizedProps$slo3 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo3.actionBar)
    })
  });
  const {
    renderPicker
  } = useDesktopPicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "time",
    getOpenDialogAriaText: (_props$localeText$ope = (_props$localeText = props.localeText) == null ? void 0 : _props$localeText.openTimePickerDialogue) != null ? _props$localeText$ope : localeText.openTimePickerDialogue,
    validator: validateTime
  });
  return renderPicker();
});
DesktopTimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: import_prop_types12.default.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: import_prop_types12.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types12.default.bool,
  /**
   * Class name applied to the root element.
   */
  className: import_prop_types12.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types12.default.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types12.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types12.default.object,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types12.default.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types12.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types12.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types12.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types12.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types12.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types12.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types12.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types12.default.node,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types12.default.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types12.default.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types12.default.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types12.default.number,
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: import_prop_types12.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: import_prop_types12.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types12.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types12.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types12.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types12.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types12.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types12.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types12.default.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types12.default.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: import_prop_types12.default.oneOf(["landscape", "portrait"]),
  readOnly: import_prop_types12.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types12.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types12.default.any,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types12.default.oneOfType([import_prop_types12.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types12.default.number, import_prop_types12.default.shape({
    endIndex: import_prop_types12.default.number.isRequired,
    startIndex: import_prop_types12.default.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: import_prop_types12.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types12.default.func,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: import_prop_types12.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types12.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types12.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types12.default.oneOfType([import_prop_types12.default.arrayOf(import_prop_types12.default.oneOfType([import_prop_types12.default.func, import_prop_types12.default.object, import_prop_types12.default.bool])), import_prop_types12.default.func, import_prop_types12.default.object]),
  /**
   * Amount of time options below or at which the single column time renderer is used.
   * @default 24
   */
  thresholdToRenderTimeInASingleColumn: import_prop_types12.default.number,
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: import_prop_types12.default.shape({
    hours: import_prop_types12.default.number,
    minutes: import_prop_types12.default.number,
    seconds: import_prop_types12.default.number
  }),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types12.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types12.default.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types12.default.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: import_prop_types12.default.shape({
    hours: import_prop_types12.default.func,
    meridiem: import_prop_types12.default.func,
    minutes: import_prop_types12.default.func,
    seconds: import_prop_types12.default.func
  }),
  /**
   * Available views.
   */
  views: import_prop_types12.default.arrayOf(import_prop_types12.default.oneOf(["hours", "minutes", "seconds"]).isRequired)
};

// node_modules/@mui/x-date-pickers/MobileTimePicker/MobileTimePicker.js
init_extends();
var React25 = __toESM(require_react());
var import_prop_types13 = __toESM(require_prop_types());
init_utils();
var MobileTimePicker = React25.forwardRef(function MobileTimePicker2(inProps, ref) {
  var _defaultizedProps$amp, _defaultizedProps$slo2, _props$localeText$ope, _props$localeText;
  const localeText = useLocaleText();
  const utils = useUtils();
  const defaultizedProps = useTimePickerDefaultizedProps(inProps, "MuiMobileTimePicker");
  const viewRenderers = _extends({
    hours: renderTimeViewClock,
    minutes: renderTimeViewClock,
    seconds: renderTimeViewClock
  }, defaultizedProps.viewRenderers);
  const ampmInClock = (_defaultizedProps$amp = defaultizedProps.ampmInClock) != null ? _defaultizedProps$amp : false;
  const props = _extends({}, defaultizedProps, {
    ampmInClock,
    viewRenderers,
    format: resolveTimeFormat(utils, defaultizedProps),
    slots: _extends({
      field: TimeField
    }, defaultizedProps.slots),
    slotProps: _extends({}, defaultizedProps.slotProps, {
      field: (ownerState) => {
        var _defaultizedProps$slo;
        return _extends({}, resolveComponentProps((_defaultizedProps$slo = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo.field, ownerState), extractValidationProps(defaultizedProps), {
          ref
        });
      },
      toolbar: _extends({
        hidden: false,
        ampmInClock
      }, (_defaultizedProps$slo2 = defaultizedProps.slotProps) == null ? void 0 : _defaultizedProps$slo2.toolbar)
    })
  });
  const {
    renderPicker
  } = useMobilePicker({
    props,
    valueManager: singleItemValueManager,
    valueType: "time",
    getOpenDialogAriaText: (_props$localeText$ope = (_props$localeText = props.localeText) == null ? void 0 : _props$localeText.openTimePickerDialogue) != null ? _props$localeText$ope : localeText.openTimePickerDialogue,
    validator: validateTime
  });
  return renderPicker();
});
MobileTimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: import_prop_types13.default.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: import_prop_types13.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types13.default.bool,
  /**
   * Class name applied to the root element.
   */
  className: import_prop_types13.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types13.default.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types13.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types13.default.object,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types13.default.any,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types13.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types13.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types13.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types13.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types13.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types13.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types13.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types13.default.node,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types13.default.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types13.default.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types13.default.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types13.default.number,
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: import_prop_types13.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: import_prop_types13.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types13.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types13.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types13.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types13.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types13.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types13.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types13.default.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types13.default.oneOf(["hours", "minutes", "seconds"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: import_prop_types13.default.oneOf(["landscape", "portrait"]),
  readOnly: import_prop_types13.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types13.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types13.default.any,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types13.default.oneOfType([import_prop_types13.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types13.default.number, import_prop_types13.default.shape({
    endIndex: import_prop_types13.default.number.isRequired,
    startIndex: import_prop_types13.default.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: import_prop_types13.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types13.default.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types13.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types13.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types13.default.oneOfType([import_prop_types13.default.arrayOf(import_prop_types13.default.oneOfType([import_prop_types13.default.func, import_prop_types13.default.object, import_prop_types13.default.bool])), import_prop_types13.default.func, import_prop_types13.default.object]),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types13.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types13.default.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types13.default.oneOf(["hours", "minutes", "seconds"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: import_prop_types13.default.shape({
    hours: import_prop_types13.default.func,
    minutes: import_prop_types13.default.func,
    seconds: import_prop_types13.default.func
  }),
  /**
   * Available views.
   */
  views: import_prop_types13.default.arrayOf(import_prop_types13.default.oneOf(["hours", "minutes", "seconds"]).isRequired)
};

// node_modules/@mui/x-date-pickers/TimePicker/TimePicker.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var _excluded15 = ["desktopModeMediaQuery"];
var TimePicker = React26.forwardRef(function TimePicker2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTimePicker"
  });
  const {
    desktopModeMediaQuery = DEFAULT_DESKTOP_MODE_MEDIA_QUERY
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded15);
  const isDesktop = useMediaQuery(desktopModeMediaQuery, {
    defaultMatches: true
  });
  if (isDesktop) {
    return (0, import_jsx_runtime23.jsx)(DesktopTimePicker, _extends({
      ref
    }, other));
  }
  return (0, import_jsx_runtime23.jsx)(MobileTimePicker, _extends({
    ref
  }, other));
});
true ? TimePicker.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * 12h/24h view for hour selection clock.
   * @default `utils.is12HourCycleInCurrentLocale()`
   */
  ampm: import_prop_types14.default.bool,
  /**
   * Display ampm controls under the clock (instead of in the toolbar).
   * @default true on desktop, false on mobile
   */
  ampmInClock: import_prop_types14.default.bool,
  /**
   * If `true`, the main element is focused during the first mount.
   * This main element is:
   * - the element chosen by the visible view if any (i.e: the selected day on the `day` view).
   * - the `input` element if there is a field rendered.
   */
  autoFocus: import_prop_types14.default.bool,
  /**
   * Class name applied to the root element.
   */
  className: import_prop_types14.default.string,
  /**
   * If `true`, the popover or modal will close after submitting the full date.
   * @default `true` for desktop, `false` for mobile (based on the chosen wrapper and `desktopModeMediaQuery` prop).
   */
  closeOnSelect: import_prop_types14.default.bool,
  /**
   * Overridable components.
   * @default {}
   * @deprecated Please use `slots`.
   */
  components: import_prop_types14.default.object,
  /**
   * The props used for each component slot.
   * @default {}
   * @deprecated Please use `slotProps`.
   */
  componentsProps: import_prop_types14.default.object,
  /**
   * The default value.
   * Used when the component is not controlled.
   */
  defaultValue: import_prop_types14.default.any,
  /**
   * CSS media query when `Mobile` mode will be changed to `Desktop`.
   * @default '@media (pointer: fine)'
   * @example '@media (min-width: 720px)' or theme.breakpoints.up("sm")
   */
  desktopModeMediaQuery: import_prop_types14.default.string,
  /**
   * If `true`, the picker and text field are disabled.
   * @default false
   */
  disabled: import_prop_types14.default.bool,
  /**
   * If `true`, disable values after the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disableFuture: import_prop_types14.default.bool,
  /**
   * Do not ignore date part when validating min/max time.
   * @default false
   */
  disableIgnoringDatePartForTimeValidation: import_prop_types14.default.bool,
  /**
   * If `true`, the open picker button will not be rendered (renders only the field).
   * @default false
   */
  disableOpenPicker: import_prop_types14.default.bool,
  /**
   * If `true`, disable values before the current date for date components, time for time components and both for date time components.
   * @default false
   */
  disablePast: import_prop_types14.default.bool,
  /**
   * Format of the date when rendered in the input(s).
   * Defaults to localized format based on the used `views`.
   */
  format: import_prop_types14.default.string,
  /**
   * Density of the format when rendered in the input.
   * Setting `formatDensity` to `"spacious"` will add a space before and after each `/`, `-` and `.` character.
   * @default "dense"
   */
  formatDensity: import_prop_types14.default.oneOf(["dense", "spacious"]),
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType_default,
  /**
   * The label content.
   */
  label: import_prop_types14.default.node,
  /**
   * Locale for components texts.
   * Allows overriding texts coming from `LocalizationProvider` and `theme`.
   */
  localeText: import_prop_types14.default.object,
  /**
   * Maximal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  maxTime: import_prop_types14.default.any,
  /**
   * Minimal selectable time.
   * The date part of the object will be ignored unless `props.disableIgnoringDatePartForTimeValidation === true`.
   */
  minTime: import_prop_types14.default.any,
  /**
   * Step over minutes.
   * @default 1
   */
  minutesStep: import_prop_types14.default.number,
  /**
   * Name attribute used by the `input` element in the Field.
   */
  name: import_prop_types14.default.string,
  /**
   * Callback fired when the value is accepted.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The value that was just accepted.
   */
  onAccept: import_prop_types14.default.func,
  /**
   * Callback fired when the value changes.
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TValue} value The new value.
   * @param {FieldChangeHandlerContext<TError>} context The context containing the validation result of the current value.
   */
  onChange: import_prop_types14.default.func,
  /**
   * Callback fired when the popup requests to be closed.
   * Use in controlled mode (see `open`).
   */
  onClose: import_prop_types14.default.func,
  /**
   * Callback fired when the error associated to the current value changes.
   * If the error has a non-null value, then the `TextField` will be rendered in `error` state.
   *
   * @template TValue The value type. Will be either the same type as `value` or `null`. Can be in `[start, end]` format in case of range value.
   * @template TError The validation error type. Will be either `string` or a `null`. Can be in `[start, end]` format in case of range value.
   * @param {TError} error The new error describing why the current value is not valid.
   * @param {TValue} value The value associated to the error.
   */
  onError: import_prop_types14.default.func,
  /**
   * Callback fired when the popup requests to be opened.
   * Use in controlled mode (see `open`).
   */
  onOpen: import_prop_types14.default.func,
  /**
   * Callback fired when the selected sections change.
   * @param {FieldSelectedSections} newValue The new selected sections.
   */
  onSelectedSectionsChange: import_prop_types14.default.func,
  /**
   * Callback fired on view change.
   * @template TView
   * @param {TView} view The new view.
   */
  onViewChange: import_prop_types14.default.func,
  /**
   * Control the popup or dialog open state.
   * @default false
   */
  open: import_prop_types14.default.bool,
  /**
   * The default visible view.
   * Used when the component view is not controlled.
   * Must be a valid option from `views` list.
   */
  openTo: import_prop_types14.default.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * Force rendering in particular orientation.
   */
  orientation: import_prop_types14.default.oneOf(["landscape", "portrait"]),
  readOnly: import_prop_types14.default.bool,
  /**
   * If `true`, disable heavy animations.
   * @default `@media(prefers-reduced-motion: reduce)` || `navigator.userAgent` matches Android <10 or iOS <13
   */
  reduceAnimations: import_prop_types14.default.bool,
  /**
   * The date used to generate the new value when both `value` and `defaultValue` are empty.
   * @default The closest valid date-time using the validation props, except callbacks like `shouldDisable<...>`.
   */
  referenceDate: import_prop_types14.default.any,
  /**
   * The currently selected sections.
   * This prop accept four formats:
   * 1. If a number is provided, the section at this index will be selected.
   * 2. If an object with a `startIndex` and `endIndex` properties are provided, the sections between those two indexes will be selected.
   * 3. If a string of type `FieldSectionType` is provided, the first section with that name will be selected.
   * 4. If `null` is provided, no section will be selected
   * If not provided, the selected sections will be handled internally.
   */
  selectedSections: import_prop_types14.default.oneOfType([import_prop_types14.default.oneOf(["all", "day", "hours", "meridiem", "minutes", "month", "seconds", "weekDay", "year"]), import_prop_types14.default.number, import_prop_types14.default.shape({
    endIndex: import_prop_types14.default.number.isRequired,
    startIndex: import_prop_types14.default.number.isRequired
  })]),
  /**
   * Disable specific clock time.
   * @param {number} clockValue The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   * @deprecated Consider using `shouldDisableTime`.
   */
  shouldDisableClock: import_prop_types14.default.func,
  /**
   * Disable specific time.
   * @template TDate
   * @param {TDate} value The value to check.
   * @param {TimeView} view The clock type of the timeValue.
   * @returns {boolean} If `true` the time will be disabled.
   */
  shouldDisableTime: import_prop_types14.default.func,
  /**
   * If `true`, disabled digital clock items will not be rendered.
   * @default false
   */
  skipDisabled: import_prop_types14.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types14.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types14.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types14.default.oneOfType([import_prop_types14.default.arrayOf(import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.object, import_prop_types14.default.bool])), import_prop_types14.default.func, import_prop_types14.default.object]),
  /**
   * Amount of time options below or at which the single column time renderer is used.
   * @default 24
   */
  thresholdToRenderTimeInASingleColumn: import_prop_types14.default.number,
  /**
   * The time steps between two time unit options.
   * For example, if `timeStep.minutes = 8`, then the available minute options will be `[0, 8, 16, 24, 32, 40, 48, 56]`.
   * When single column time renderer is used, only `timeStep.minutes` will be used.
   * @default{ hours: 1, minutes: 5, seconds: 5 }
   */
  timeSteps: import_prop_types14.default.shape({
    hours: import_prop_types14.default.number,
    minutes: import_prop_types14.default.number,
    seconds: import_prop_types14.default.number
  }),
  /**
   * Choose which timezone to use for the value.
   * Example: "default", "system", "UTC", "America/New_York".
   * If you pass values from other timezones to some props, they will be converted to this timezone before being used.
   * @see See the {@link https://mui.com/x/react-date-pickers/timezone/ timezones documention} for more details.
   * @default The timezone of the `value` or `defaultValue` prop is defined, 'default' otherwise.
   */
  timezone: import_prop_types14.default.string,
  /**
   * The selected value.
   * Used when the component is controlled.
   */
  value: import_prop_types14.default.any,
  /**
   * The visible view.
   * Used when the component view is controlled.
   * Must be a valid option from `views` list.
   */
  view: import_prop_types14.default.oneOf(["hours", "meridiem", "minutes", "seconds"]),
  /**
   * Define custom view renderers for each section.
   * If `null`, the section will only have field editing.
   * If `undefined`, internally defined view will be the used.
   */
  viewRenderers: import_prop_types14.default.shape({
    hours: import_prop_types14.default.func,
    meridiem: import_prop_types14.default.func,
    minutes: import_prop_types14.default.func,
    seconds: import_prop_types14.default.func
  }),
  /**
   * Available views.
   */
  views: import_prop_types14.default.arrayOf(import_prop_types14.default.oneOf(["hours", "minutes", "seconds"]).isRequired)
} : void 0;

// node_modules/material-react-table/dist/index.esm.js
var getColumnId = (columnDef) => {
  var _a, _b, _c, _d;
  return (_d = (_a = columnDef.id) !== null && _a !== void 0 ? _a : (_c = (_b = columnDef.accessorKey) === null || _b === void 0 ? void 0 : _b.toString) === null || _c === void 0 ? void 0 : _c.call(_b)) !== null && _d !== void 0 ? _d : columnDef.header;
};
var getAllLeafColumnDefs = (columns) => {
  const allLeafColumnDefs = [];
  const getLeafColumns = (cols) => {
    cols.forEach((col) => {
      if (col.columns) {
        getLeafColumns(col.columns);
      } else {
        allLeafColumnDefs.push(col);
      }
    });
  };
  getLeafColumns(columns);
  return allLeafColumnDefs;
};
var prepareColumns = ({ columnDefs, tableOptions }) => {
  const { aggregationFns: aggregationFns2 = {}, defaultDisplayColumn, filterFns: filterFns2 = {}, sortingFns: sortingFns2 = {}, state: { columnFilterFns = {} } = {} } = tableOptions;
  return columnDefs.map((columnDef) => {
    var _a, _b;
    if (!columnDef.id)
      columnDef.id = getColumnId(columnDef);
    if (!columnDef.columnDefType)
      columnDef.columnDefType = "data";
    if ((_a = columnDef.columns) === null || _a === void 0 ? void 0 : _a.length) {
      columnDef.columnDefType = "group";
      columnDef.columns = prepareColumns({
        columnDefs: columnDef.columns,
        tableOptions
      });
    } else if (columnDef.columnDefType === "data") {
      if (Array.isArray(columnDef.aggregationFn)) {
        const aggFns = columnDef.aggregationFn;
        columnDef.aggregationFn = (columnId, leafRows, childRows) => aggFns.map((fn) => {
          var _a2;
          return (_a2 = aggregationFns2[fn]) === null || _a2 === void 0 ? void 0 : _a2.call(aggregationFns2, columnId, leafRows, childRows);
        });
      }
      if (Object.keys(filterFns2).includes(columnFilterFns[columnDef.id])) {
        columnDef.filterFn = (_b = filterFns2[columnFilterFns[columnDef.id]]) !== null && _b !== void 0 ? _b : filterFns2.fuzzy;
        columnDef._filterFn = columnFilterFns[columnDef.id];
      }
      if (Object.keys(sortingFns2).includes(columnDef.sortingFn)) {
        columnDef.sortingFn = sortingFns2[columnDef.sortingFn];
      }
    } else if (columnDef.columnDefType === "display") {
      columnDef = Object.assign(Object.assign({}, defaultDisplayColumn), columnDef);
    }
    return columnDef;
  });
};
var reorderColumn = (draggedColumn, targetColumn, columnOrder) => {
  if (draggedColumn.getCanPin()) {
    draggedColumn.pin(targetColumn.getIsPinned());
  }
  const newColumnOrder = [...columnOrder];
  newColumnOrder.splice(newColumnOrder.indexOf(targetColumn.id), 0, newColumnOrder.splice(newColumnOrder.indexOf(draggedColumn.id), 1)[0]);
  return newColumnOrder;
};
var getDefaultColumnFilterFn = (columnDef) => {
  const { filterVariant } = columnDef;
  if (filterVariant === "multi-select")
    return "arrIncludesSome";
  if (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.includes("range"))
    return "betweenInclusive";
  if (filterVariant === "select" || filterVariant === "checkbox")
    return "equals";
  return "fuzzy";
};
var flexRender2 = flexRender;
function createMRTColumnHelper() {
  return {
    accessor: (accessor, column) => {
      return typeof accessor === "function" ? Object.assign(Object.assign({}, column), { accessorFn: accessor }) : Object.assign(Object.assign({}, column), { accessorKey: accessor });
    },
    display: (column) => column,
    group: (column) => column
  };
}
var createRow2 = (table, originalRow, rowIndex = -1, depth = 0, subRows, parentId) => createRow(table, "mrt-row-create", originalRow !== null && originalRow !== void 0 ? originalRow : Object.assign({}, ...getAllLeafColumnDefs(table.options.columns).map((col) => ({
  [getColumnId(col)]: ""
}))), rowIndex, depth, subRows, parentId);
var parseFromValuesOrFunc = (fn, arg) => fn instanceof Function ? fn(arg) : fn;
var getValueAndLabel = (option) => {
  var _a, _b, _c;
  let label = "";
  let value = "";
  if (option) {
    if (typeof option !== "object") {
      label = option;
      value = option;
    } else {
      label = (_b = (_a = option.label) !== null && _a !== void 0 ? _a : option.text) !== null && _b !== void 0 ? _b : option.value;
      value = (_c = option.value) !== null && _c !== void 0 ? _c : label;
    }
  }
  return { label, value };
};
var isCellEditable = ({ cell, table }) => {
  const { enableEditing } = table.options;
  const { column: { columnDef }, row } = cell;
  return !cell.getIsPlaceholder() && parseFromValuesOrFunc(enableEditing, row) && parseFromValuesOrFunc(columnDef.enableEditing, row) !== false;
};
var openEditingCell = ({ cell, table }) => {
  const { options: { editDisplayMode }, refs: { editInputRefs } } = table;
  const { column } = cell;
  if (isCellEditable({ cell, table }) && editDisplayMode === "cell") {
    table.setEditingCell(cell);
    queueMicrotask(() => {
      var _a;
      const textField = editInputRefs.current[column.id];
      if (textField) {
        textField.focus();
        (_a = textField.select) === null || _a === void 0 ? void 0 : _a.call(textField);
      }
    });
  }
};
function defaultDisplayColumnProps({ header, id, size, tableOptions }) {
  const { defaultDisplayColumn, displayColumnDefOptions, localization } = tableOptions;
  return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultDisplayColumn), { header: header ? localization[header] : "", size }), displayColumnDefOptions === null || displayColumnDefOptions === void 0 ? void 0 : displayColumnDefOptions[id]), { id });
}
var showRowPinningColumn = (tableOptions) => {
  const { enableRowPinning, rowPinningDisplayMode } = tableOptions;
  return !!(enableRowPinning && !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.startsWith("select")));
};
var showRowDragColumn = (tableOptions) => {
  const { enableRowDragging, enableRowOrdering } = tableOptions;
  return !!(enableRowDragging || enableRowOrdering);
};
var showRowExpandColumn = (tableOptions) => {
  const { enableExpanding, enableGrouping, renderDetailPanel, state: { grouping } } = tableOptions;
  return !!(enableExpanding || enableGrouping && (grouping === null || grouping === void 0 ? void 0 : grouping.length) || renderDetailPanel);
};
var showRowActionsColumn = (tableOptions) => {
  const { createDisplayMode, editDisplayMode, enableEditing, enableRowActions, state: { creatingRow } } = tableOptions;
  return !!(enableRowActions || creatingRow && createDisplayMode === "row" || enableEditing && ["modal", "row"].includes(editDisplayMode !== null && editDisplayMode !== void 0 ? editDisplayMode : ""));
};
var showRowSelectionColumn = (tableOptions) => !!tableOptions.enableRowSelection;
var showRowNumbersColumn = (tableOptions) => !!tableOptions.enableRowNumbers;
var showRowSpacerColumn = (tableOptions) => tableOptions.layoutMode === "grid-no-grow";
var getLeadingDisplayColumnIds = (tableOptions) => [
  showRowPinningColumn(tableOptions) && "mrt-row-pin",
  showRowDragColumn(tableOptions) && "mrt-row-drag",
  tableOptions.positionActionsColumn === "first" && showRowActionsColumn(tableOptions) && "mrt-row-actions",
  tableOptions.positionExpandColumn === "first" && showRowExpandColumn(tableOptions) && "mrt-row-expand",
  showRowSelectionColumn(tableOptions) && "mrt-row-select",
  showRowNumbersColumn(tableOptions) && "mrt-row-numbers"
].filter(Boolean);
var getTrailingDisplayColumnIds = (tableOptions) => [
  tableOptions.positionActionsColumn === "last" && showRowActionsColumn(tableOptions) && "mrt-row-actions",
  tableOptions.positionExpandColumn === "last" && showRowExpandColumn(tableOptions) && "mrt-row-expand",
  showRowSpacerColumn(tableOptions) && "mrt-row-spacer"
].filter(Boolean);
var getDefaultColumnOrderIds = (tableOptions, reset = false) => {
  const { state: { columnOrder: currentColumnOrderIds = [] } } = tableOptions;
  const leadingDisplayColIds = getLeadingDisplayColumnIds(tableOptions);
  const trailingDisplayColIds = getTrailingDisplayColumnIds(tableOptions);
  const defaultColumnDefIds = getAllLeafColumnDefs(tableOptions.columns).map((columnDef) => getColumnId(columnDef));
  let allLeafColumnDefIds = reset ? defaultColumnDefIds : Array.from(/* @__PURE__ */ new Set([...currentColumnOrderIds, ...defaultColumnDefIds]));
  allLeafColumnDefIds = allLeafColumnDefIds.filter((colId) => !leadingDisplayColIds.includes(colId) && !trailingDisplayColIds.includes(colId));
  return [
    ...leadingDisplayColIds,
    ...allLeafColumnDefIds,
    ...trailingDisplayColIds
  ];
};
var fuzzy$1 = (rowA, rowB, columnId) => {
  let dir = 0;
  if (rowA.columnFiltersMeta[columnId]) {
    dir = compareItems(rowA.columnFiltersMeta[columnId], rowB.columnFiltersMeta[columnId]);
  }
  return dir === 0 ? sortingFns.alphanumeric(rowA, rowB, columnId) : dir;
};
var MRT_SortingFns = Object.assign(Object.assign({}, sortingFns), { fuzzy: fuzzy$1 });
var rankGlobalFuzzy = (rowA, rowB) => Math.max(...Object.values(rowB.columnFiltersMeta).map((v) => v.rank)) - Math.max(...Object.values(rowA.columnFiltersMeta).map((v) => v.rank));
var getMRT_Rows = (table, all) => {
  const { getCenterRows, getPrePaginationRowModel, getRowModel, getState, getTopRows, options: { createDisplayMode, enablePagination, enableRowPinning, manualPagination, positionCreatingRow, rowPinningDisplayMode } } = table;
  const { creatingRow, pagination } = getState();
  const isRankingRows = getIsRankingRows(table);
  let rows = [];
  if (!isRankingRows) {
    rows = !enableRowPinning || (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) ? all ? getPrePaginationRowModel().rows : getRowModel().rows : getCenterRows();
  } else {
    rows = getPrePaginationRowModel().rows.sort((a, b) => rankGlobalFuzzy(a, b));
    if (enablePagination && !manualPagination && !all) {
      const start = pagination.pageIndex * pagination.pageSize;
      rows = rows.slice(start, start + pagination.pageSize);
    }
    if (enableRowPinning && !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky"))) {
      rows = rows.filter((row) => !row.getIsPinned());
    }
  }
  if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky"))) {
    const centerPinnedRowIds = rows.filter((row) => row.getIsPinned()).map((r) => r.id);
    rows = [
      ...getTopRows().filter((row) => !centerPinnedRowIds.includes(row.id)),
      ...rows
    ];
  }
  if (positionCreatingRow !== void 0 && creatingRow && createDisplayMode === "row") {
    const creatingRowIndex = !isNaN(+positionCreatingRow) ? +positionCreatingRow : positionCreatingRow === "top" ? 0 : rows.length;
    rows = [
      ...rows.slice(0, creatingRowIndex),
      creatingRow,
      ...rows.slice(creatingRowIndex)
    ];
  }
  return rows;
};
var getCanRankRows = (table) => {
  const { getState, options: { enableGlobalFilterRankedResults, manualExpanding, manualFiltering, manualGrouping, manualSorting } } = table;
  const { expanded, globalFilterFn } = getState();
  return !manualExpanding && !manualFiltering && !manualGrouping && !manualSorting && enableGlobalFilterRankedResults && globalFilterFn === "fuzzy" && expanded !== true && !Object.values(expanded).some(Boolean);
};
var getIsRankingRows = (table) => {
  const { globalFilter, sorting } = table.getState();
  return getCanRankRows(table) && globalFilter && !Object.values(sorting).some(Boolean);
};
var getIsRowSelected = ({ row, table }) => {
  const { options: { enableRowSelection } } = table;
  return row.getIsSelected() || parseFromValuesOrFunc(enableRowSelection, row) && row.getCanSelectSubRows() && row.getIsAllSubRowsSelected();
};
var getMRT_RowSelectionHandler = ({ row, staticRowIndex = 0, table }) => (event, value) => {
  var _a;
  const { getState, options: { enableBatchRowSelection, enableMultiRowSelection, enableRowPinning, manualPagination, rowPinningDisplayMode }, refs: { lastSelectedRowId } } = table;
  const { pagination: { pageIndex, pageSize } } = getState();
  const paginationOffset = manualPagination ? 0 : pageSize * pageIndex;
  const wasCurrentRowChecked = getIsRowSelected({ row, table });
  row.toggleSelected(value !== null && value !== void 0 ? value : !wasCurrentRowChecked);
  const changedRowIds = /* @__PURE__ */ new Set([row.id]);
  if (enableBatchRowSelection && enableMultiRowSelection && event.nativeEvent.shiftKey && lastSelectedRowId.current !== null) {
    const rows = getMRT_Rows(table, true);
    const lastIndex = rows.findIndex((r) => r.id === lastSelectedRowId.current);
    if (lastIndex !== -1) {
      const isLastIndexChecked = getIsRowSelected({
        row: rows === null || rows === void 0 ? void 0 : rows[lastIndex],
        table
      });
      const currentIndex = staticRowIndex + paginationOffset;
      const [start, end] = lastIndex < currentIndex ? [lastIndex, currentIndex] : [currentIndex, lastIndex];
      if (wasCurrentRowChecked !== isLastIndexChecked) {
        for (let i = start; i <= end; i++) {
          rows[i].toggleSelected(!wasCurrentRowChecked);
          changedRowIds.add(rows[i].id);
        }
      }
    }
  }
  lastSelectedRowId.current = row.id;
  if (row.getCanSelectSubRows() && row.getIsAllSubRowsSelected()) {
    (_a = row.subRows) === null || _a === void 0 ? void 0 : _a.forEach((r) => r.toggleSelected(false));
  }
  if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("select"))) {
    changedRowIds.forEach((rowId) => {
      const rowToTogglePin = table.getRow(rowId);
      rowToTogglePin.pin(!wasCurrentRowChecked ? (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("bottom")) ? "bottom" : "top" : false);
    });
  }
};
var getMRT_SelectAllHandler = ({ table }) => (event, value, forceAll) => {
  const { options: { enableRowPinning, rowPinningDisplayMode, selectAllMode }, refs: { lastSelectedRowId } } = table;
  selectAllMode === "all" || forceAll ? table.toggleAllRowsSelected(value !== null && value !== void 0 ? value : event.target.checked) : table.toggleAllPageRowsSelected(value !== null && value !== void 0 ? value : event.target.checked);
  if (enableRowPinning && (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("select"))) {
    table.setRowPinning({ bottom: [], top: [] });
  }
  lastSelectedRowId.current = null;
};
var MRT_AggregationFns = Object.assign({}, aggregationFns);
var fuzzy = (row, columnId, filterValue, addMeta) => {
  const itemRank = rankItem(row.getValue(columnId), filterValue, {
    threshold: rankings.MATCHES
  });
  addMeta(itemRank);
  return itemRank.passed;
};
fuzzy.autoRemove = (val) => !val;
var contains = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().includes(filterValue.toString().toLowerCase().trim());
contains.autoRemove = (val) => !val;
var startsWith = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().startsWith(filterValue.toString().toLowerCase().trim());
startsWith.autoRemove = (val) => !val;
var endsWith = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim().endsWith(filterValue.toString().toLowerCase().trim());
endsWith.autoRemove = (val) => !val;
var equals2 = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() === (filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString().toLowerCase().trim());
equals2.autoRemove = (val) => !val;
var notEquals = (row, id, filterValue) => row.getValue(id).toString().toLowerCase().trim() !== filterValue.toString().toLowerCase().trim();
notEquals.autoRemove = (val) => !val;
var greaterThan = (row, id, filterValue) => !isNaN(+filterValue) && !isNaN(+row.getValue(id)) ? +row.getValue(id) > +filterValue : row.getValue(id).toString().toLowerCase().trim() > (filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString().toLowerCase().trim());
greaterThan.autoRemove = (val) => !val;
var greaterThanOrEqualTo = (row, id, filterValue) => equals2(row, id, filterValue) || greaterThan(row, id, filterValue);
greaterThanOrEqualTo.autoRemove = (val) => !val;
var lessThan = (row, id, filterValue) => !isNaN(+filterValue) && !isNaN(+row.getValue(id)) ? +row.getValue(id) < +filterValue : row.getValue(id).toString().toLowerCase().trim() < (filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString().toLowerCase().trim());
lessThan.autoRemove = (val) => !val;
var lessThanOrEqualTo = (row, id, filterValue) => equals2(row, id, filterValue) || lessThan(row, id, filterValue);
lessThanOrEqualTo.autoRemove = (val) => !val;
var between = (row, id, filterValues) => (["", void 0].includes(filterValues[0]) || greaterThan(row, id, filterValues[0])) && (!isNaN(+filterValues[0]) && !isNaN(+filterValues[1]) && +filterValues[0] > +filterValues[1] || ["", void 0].includes(filterValues[1]) || lessThan(row, id, filterValues[1]));
between.autoRemove = (val) => !val;
var betweenInclusive = (row, id, filterValues) => (["", void 0].includes(filterValues[0]) || greaterThanOrEqualTo(row, id, filterValues[0])) && (!isNaN(+filterValues[0]) && !isNaN(+filterValues[1]) && +filterValues[0] > +filterValues[1] || ["", void 0].includes(filterValues[1]) || lessThanOrEqualTo(row, id, filterValues[1]));
betweenInclusive.autoRemove = (val) => !val;
var empty = (row, id, _filterValue) => !row.getValue(id).toString().trim();
empty.autoRemove = (val) => !val;
var notEmpty = (row, id, _filterValue) => !!row.getValue(id).toString().trim();
notEmpty.autoRemove = (val) => !val;
var MRT_FilterFns = Object.assign(Object.assign({}, filterFns), {
  between,
  betweenInclusive,
  contains,
  empty,
  endsWith,
  equals: equals2,
  fuzzy,
  greaterThan,
  greaterThanOrEqualTo,
  lessThan,
  lessThanOrEqualTo,
  notEmpty,
  notEquals,
  startsWith
});
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
var MRT_EditActionButtons = (_a) => {
  var { row, table, variant = "icon" } = _a, rest = __rest(_a, ["row", "table", "variant"]);
  const { getState, options: { icons: { CancelIcon: CancelIcon2, SaveIcon: SaveIcon2 }, localization, onCreatingRowCancel, onCreatingRowSave, onEditingRowCancel, onEditingRowSave }, refs: { editInputRefs }, setCreatingRow, setEditingRow } = table;
  const { creatingRow, editingRow, isSaving } = getState();
  const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
  const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
  const handleCancel = () => {
    if (isCreating) {
      onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });
      setCreatingRow(null);
    } else if (isEditing) {
      onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });
      setEditingRow(null);
    }
    row._valuesCache = {};
  };
  const handleSubmitRow = () => {
    var _a2;
    (_a2 = Object.values(editInputRefs === null || editInputRefs === void 0 ? void 0 : editInputRefs.current).filter((inputRef) => {
      var _a3, _b;
      return row.id === ((_b = (_a3 = inputRef === null || inputRef === void 0 ? void 0 : inputRef.name) === null || _a3 === void 0 ? void 0 : _a3.split("_")) === null || _b === void 0 ? void 0 : _b[0]);
    })) === null || _a2 === void 0 ? void 0 : _a2.forEach((input) => {
      if (input.value !== void 0 && Object.hasOwn(row === null || row === void 0 ? void 0 : row._valuesCache, input.name)) {
        row._valuesCache[input.name] = input.value;
      }
    });
    if (isCreating)
      onCreatingRowSave === null || onCreatingRowSave === void 0 ? void 0 : onCreatingRowSave({
        exitCreatingMode: () => setCreatingRow(null),
        row,
        table,
        values: row._valuesCache
      });
    else if (isEditing) {
      onEditingRowSave === null || onEditingRowSave === void 0 ? void 0 : onEditingRowSave({
        exitEditingMode: () => setEditingRow(null),
        row,
        table,
        values: row === null || row === void 0 ? void 0 : row._valuesCache
      });
    }
  };
  return (0, import_jsx_runtime24.jsx)(Box_default, { onClick: (e) => e.stopPropagation(), sx: (theme) => Object.assign({ display: "flex", gap: "0.75rem" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: variant === "icon" ? (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(Tooltip_default, { title: localization.cancel, children: (0, import_jsx_runtime24.jsx)(IconButton_default, { "aria-label": localization.cancel, onClick: handleCancel, children: (0, import_jsx_runtime24.jsx)(CancelIcon2, {}) }) }), (isCreating && onCreatingRowSave || isEditing && onEditingRowSave) && (0, import_jsx_runtime24.jsx)(Tooltip_default, { title: localization.save, children: (0, import_jsx_runtime24.jsx)(IconButton_default, { "aria-label": localization.save, color: "info", onClick: handleSubmitRow, children: isSaving ? (0, import_jsx_runtime24.jsx)(CircularProgress_default, { size: 18 }) : (0, import_jsx_runtime24.jsx)(SaveIcon2, {}) }) })] }) : (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(Button_default, { onClick: handleCancel, sx: { minWidth: "100px" }, children: localization.cancel }), (0, import_jsx_runtime24.jsxs)(Button_default, { onClick: handleSubmitRow, sx: { minWidth: "100px" }, variant: "contained", children: [isSaving && (0, import_jsx_runtime24.jsx)(CircularProgress_default, { color: "inherit", size: 18 }), localization.save] })] }) });
};
var parseCSSVarId = (id) => id.replace(/[^a-zA-Z0-9]/g, "_");
var getMRTTheme = (mrtTheme, muiTheme) => {
  var _a;
  const mrtThemeOverrides = parseFromValuesOrFunc(mrtTheme, muiTheme);
  const baseBackgroundColor = (_a = mrtThemeOverrides === null || mrtThemeOverrides === void 0 ? void 0 : mrtThemeOverrides.baseBackgroundColor) !== null && _a !== void 0 ? _a : muiTheme.palette.mode === "dark" ? lighten(muiTheme.palette.background.default, 0.05) : muiTheme.palette.background.default;
  return Object.assign({ baseBackgroundColor, draggingBorderColor: muiTheme.palette.primary.main, matchHighlightColor: muiTheme.palette.mode === "dark" ? darken(muiTheme.palette.warning.dark, 0.25) : lighten(muiTheme.palette.warning.light, 0.5), menuBackgroundColor: lighten(baseBackgroundColor, 0.07), pinnedRowBackgroundColor: alpha(muiTheme.palette.primary.main, 0.1), selectedRowBackgroundColor: alpha(muiTheme.palette.primary.main, 0.2) }, mrtThemeOverrides);
};
var commonCellBeforeAfterStyles = {
  content: '""',
  height: "100%",
  left: 0,
  position: "absolute",
  top: 0,
  width: "100%",
  zIndex: -1
};
var getCommonPinnedCellStyles = ({ column, table, theme }) => {
  const { baseBackgroundColor } = table.options.mrtTheme;
  const isPinned = column === null || column === void 0 ? void 0 : column.getIsPinned();
  return {
    '&[data-pinned="true"]': {
      "&:before": Object.assign({ backgroundColor: alpha(darken(baseBackgroundColor, theme.palette.mode === "dark" ? 0.05 : 0.01), 0.97), boxShadow: column ? isPinned === "left" && column.getIsLastColumn(isPinned) ? `-4px 0 4px -4px ${alpha(theme.palette.grey[700], 0.5)} inset` : isPinned === "right" && column.getIsFirstColumn(isPinned) ? `4px 0 4px -4px ${alpha(theme.palette.grey[700], 0.5)} inset` : void 0 : void 0 }, commonCellBeforeAfterStyles)
    }
  };
};
var getCommonMRTCellStyles = ({ column, header, table, tableCellProps, theme }) => {
  var _a, _b, _c, _d, _e, _f;
  const { getState, options: { enableColumnVirtualization, layoutMode } } = table;
  const { draggingColumn } = getState();
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const isColumnPinned = columnDef.columnDefType !== "group" && column.getIsPinned();
  const widthStyles = {
    minWidth: `max(calc(var(--${header ? "header" : "col"}-${parseCSSVarId((_a = header === null || header === void 0 ? void 0 : header.id) !== null && _a !== void 0 ? _a : column.id)}-size) * 1px), ${(_b = columnDef.minSize) !== null && _b !== void 0 ? _b : 30}px)`,
    width: `calc(var(--${header ? "header" : "col"}-${parseCSSVarId((_c = header === null || header === void 0 ? void 0 : header.id) !== null && _c !== void 0 ? _c : column.id)}-size) * 1px)`
  };
  if (layoutMode === "grid") {
    widthStyles.flex = `${[0, false].includes(columnDef.grow) ? 0 : `var(--${header ? "header" : "col"}-${parseCSSVarId((_d = header === null || header === void 0 ? void 0 : header.id) !== null && _d !== void 0 ? _d : column.id)}-size)`} 0 auto`;
  } else if (layoutMode === "grid-no-grow") {
    widthStyles.flex = `${+(columnDef.grow || 0)} 0 auto`;
  }
  const pinnedStyles = isColumnPinned ? Object.assign(Object.assign({}, getCommonPinnedCellStyles({ column, table, theme })), { left: isColumnPinned === "left" ? `${column.getStart("left")}px` : void 0, opacity: 0.97, position: "sticky", right: isColumnPinned === "right" ? `${column.getAfter("right")}px` : void 0 }) : {};
  return Object.assign(Object.assign(Object.assign({ backgroundColor: "inherit", backgroundImage: "inherit", display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, justifyContent: columnDefType === "group" ? "center" : (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? tableCellProps.align : void 0, opacity: ((_e = table.getState().draggingColumn) === null || _e === void 0 ? void 0 : _e.id) === column.id || ((_f = table.getState().hoveredColumn) === null || _f === void 0 ? void 0 : _f.id) === column.id ? 0.5 : 1, position: "relative", transition: enableColumnVirtualization ? "none" : `padding 150ms ease-in-out`, zIndex: column.getIsResizing() || (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? 2 : columnDefType !== "group" && isColumnPinned ? 1 : 0 }, pinnedStyles), widthStyles), parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme));
};
var getCommonToolbarStyles = ({ table }) => ({
  alignItems: "flex-start",
  backgroundColor: table.options.mrtTheme.baseBackgroundColor,
  display: "grid",
  flexWrap: "wrap-reverse",
  minHeight: "3.5rem",
  overflow: "hidden",
  position: "relative",
  transition: "all 150ms ease-in-out",
  zIndex: 1
});
var flipIconStyles = (theme) => theme.direction === "rtl" ? { style: { transform: "scaleX(-1)" } } : void 0;
var getCommonTooltipProps = (placement) => ({
  disableInteractive: true,
  enterDelay: 1e3,
  enterNextDelay: 1e3,
  placement
});
var MRT_ActionMenuItem = (_a) => {
  var { icon, label, onOpenSubMenu, table } = _a, rest = __rest(_a, ["icon", "label", "onOpenSubMenu", "table"]);
  const { options: { icons: { ArrowRightIcon: ArrowRightIcon2 } } } = table;
  return (0, import_jsx_runtime24.jsxs)(MenuItem_default, Object.assign({ sx: {
    alignItems: "center",
    justifyContent: "space-between",
    minWidth: "120px",
    my: 0,
    py: "6px"
  } }, rest, { children: [(0, import_jsx_runtime24.jsxs)(Box_default, { sx: {
    alignItems: "center",
    display: "flex"
  }, children: [(0, import_jsx_runtime24.jsx)(ListItemIcon_default, { children: icon }), label] }), onOpenSubMenu && (0, import_jsx_runtime24.jsx)(IconButton_default, { onClick: onOpenSubMenu, onMouseEnter: onOpenSubMenu, size: "small", sx: { p: 0 }, children: (0, import_jsx_runtime24.jsx)(ArrowRightIcon2, {}) })] }));
};
var MRT_RowActionMenu = (_a) => {
  var { anchorEl, handleEdit, row, setAnchorEl, staticRowIndex, table } = _a, rest = __rest(_a, ["anchorEl", "handleEdit", "row", "setAnchorEl", "staticRowIndex", "table"]);
  const { getState, options: { editDisplayMode, enableEditing, icons: { EditIcon: EditIcon2 }, localization, mrtTheme: { menuBackgroundColor }, renderRowActionMenuItems } } = table;
  const { density } = getState();
  return (0, import_jsx_runtime24.jsxs)(Menu_default, Object.assign({ MenuListProps: {
    dense: density === "compact",
    sx: {
      backgroundColor: menuBackgroundColor
    }
  }, anchorEl, disableScrollLock: true, onClick: (event) => event.stopPropagation(), onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: [parseFromValuesOrFunc(enableEditing, row) && ["modal", "row"].includes(editDisplayMode) && (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { icon: (0, import_jsx_runtime24.jsx)(EditIcon2, {}), label: localization.edit, onClick: handleEdit, table }), renderRowActionMenuItems === null || renderRowActionMenuItems === void 0 ? void 0 : renderRowActionMenuItems({
    closeMenu: () => setAnchorEl(null),
    row,
    staticRowIndex,
    table
  })] }));
};
var commonIconButtonStyles = {
  "&:hover": {
    opacity: 1
  },
  height: "2rem",
  ml: "10px",
  opacity: 0.5,
  transition: "opacity 150ms",
  width: "2rem"
};
var MRT_ToggleRowActionMenuButton = (_a) => {
  var { cell, row, staticRowIndex, table } = _a, rest = __rest(_a, ["cell", "row", "staticRowIndex", "table"]);
  const { getState, options: { createDisplayMode, editDisplayMode, enableEditing, icons: { EditIcon: EditIcon2, MoreHorizIcon: MoreHorizIcon2 }, localization, renderRowActionMenuItems, renderRowActions }, setEditingRow } = table;
  const { creatingRow, editingRow } = getState();
  const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
  const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
  const showEditActionButtons = isCreating && createDisplayMode === "row" || isEditing && editDisplayMode === "row";
  const [anchorEl, setAnchorEl] = (0, import_react.useState)(null);
  const handleOpenRowActionMenu = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setAnchorEl(event.currentTarget);
  };
  const handleStartEditMode = (event) => {
    event.stopPropagation();
    setEditingRow(Object.assign({}, row));
    setAnchorEl(null);
  };
  return (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, { children: renderRowActions && !showEditActionButtons ? renderRowActions({ cell, row, staticRowIndex, table }) : showEditActionButtons ? (0, import_jsx_runtime24.jsx)(MRT_EditActionButtons, { row, table }) : !renderRowActionMenuItems && parseFromValuesOrFunc(enableEditing, row) && ["modal", "row"].includes(editDisplayMode) ? (0, import_jsx_runtime24.jsx)(Tooltip_default, { placement: "right", title: localization.edit, children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": localization.edit, onClick: handleStartEditMode, sx: commonIconButtonStyles }, rest, { children: (0, import_jsx_runtime24.jsx)(EditIcon2, {}) })) }) : renderRowActionMenuItems ? (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, getCommonTooltipProps(), { title: localization.rowActions, children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": localization.rowActions, onClick: handleOpenRowActionMenu, size: "small", sx: commonIconButtonStyles }, rest, { children: (0, import_jsx_runtime24.jsx)(MoreHorizIcon2, {}) })) })), (0, import_jsx_runtime24.jsx)(MRT_RowActionMenu, { anchorEl, handleEdit: handleStartEditMode, row, setAnchorEl, staticRowIndex, table })] }) : null });
};
var getMRT_RowActionsColumnDef = (tableOptions) => {
  return Object.assign({ Cell: ({ cell, row, staticRowIndex, table }) => (0, import_jsx_runtime24.jsx)(MRT_ToggleRowActionMenuButton, { cell, row, staticRowIndex, table }) }, defaultDisplayColumnProps({
    header: "actions",
    id: "mrt-row-actions",
    size: 70,
    tableOptions
  }));
};
var MRT_GrabHandleButton = (_a) => {
  var _b, _c;
  var { location, table } = _a, rest = __rest(_a, ["location", "table"]);
  const { options: { icons: { DragHandleIcon: DragHandleIcon2 }, localization } } = table;
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, getCommonTooltipProps("top"), { title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.move, children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": (_c = rest.title) !== null && _c !== void 0 ? _c : localization.move, disableRipple: true, draggable: "true", size: "small" }, rest, { onClick: (e) => {
    var _a2;
    e.stopPropagation();
    (_a2 = rest === null || rest === void 0 ? void 0 : rest.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(rest, e);
  }, sx: (theme) => Object.assign({ "&:active": {
    cursor: "grabbing"
  }, "&:hover": {
    backgroundColor: "transparent",
    opacity: 1
  }, cursor: "grab", m: "0 -0.1rem", opacity: location === "row" ? 1 : 0.5, p: "2px", transition: "all 150ms ease-in-out" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), title: void 0, children: (0, import_jsx_runtime24.jsx)(DragHandleIcon2, {}) })) }));
};
var MRT_TableBodyRowGrabHandle = (_a) => {
  var { row, rowRef, table } = _a, rest = __rest(_a, ["row", "rowRef", "table"]);
  const { options: { muiRowDragHandleProps } } = table;
  const iconButtonProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiRowDragHandleProps, {
    row,
    table
  })), rest);
  const handleDragStart = (event) => {
    var _a2;
    (_a2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a2 === void 0 ? void 0 : _a2.call(iconButtonProps, event);
    try {
      event.dataTransfer.setDragImage(rowRef.current, 0, 0);
    } catch (e) {
      console.error(e);
    }
    table.setDraggingRow(row);
  };
  const handleDragEnd = (event) => {
    var _a2;
    (_a2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a2 === void 0 ? void 0 : _a2.call(iconButtonProps, event);
    table.setDraggingRow(null);
    table.setHoveredRow(null);
  };
  return (0, import_jsx_runtime24.jsx)(MRT_GrabHandleButton, Object.assign({}, iconButtonProps, { location: "row", onDragEnd: handleDragEnd, onDragStart: handleDragStart, table }));
};
var getMRT_RowDragColumnDef = (tableOptions) => {
  return Object.assign({ Cell: ({ row, rowRef, table }) => (0, import_jsx_runtime24.jsx)(MRT_TableBodyRowGrabHandle, { row, rowRef, table }), grow: false }, defaultDisplayColumnProps({
    header: "move",
    id: "mrt-row-drag",
    size: 60,
    tableOptions
  }));
};
var MRT_ExpandAllButton = (_a) => {
  var _b, _c;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getCanSomeRowsExpand, getIsAllRowsExpanded, getIsSomeRowsExpanded, getState, options: { icons: { KeyboardDoubleArrowDownIcon: KeyboardDoubleArrowDownIcon2 }, localization, muiExpandAllButtonProps, renderDetailPanel }, toggleAllRowsExpanded } = table;
  const { density, isLoading } = getState();
  const iconButtonProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiExpandAllButtonProps, {
    table
  })), rest);
  const isAllRowsExpanded = getIsAllRowsExpanded();
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, getCommonTooltipProps(), { title: (_b = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _b !== void 0 ? _b : isAllRowsExpanded ? localization.collapseAll : localization.expandAll, children: (0, import_jsx_runtime24.jsx)("span", { children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": localization.expandAll, disabled: isLoading || !renderDetailPanel && !getCanSomeRowsExpand(), onClick: () => toggleAllRowsExpanded(!isAllRowsExpanded) }, iconButtonProps, { sx: (theme) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.25rem", mt: density !== "compact" ? "-0.25rem" : void 0, width: density === "compact" ? "1.75rem" : "2.25rem" }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme)), title: void 0, children: (_c = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _c !== void 0 ? _c : (0, import_jsx_runtime24.jsx)(KeyboardDoubleArrowDownIcon2, { style: {
    transform: `rotate(${isAllRowsExpanded ? -180 : getIsSomeRowsExpanded() ? -90 : 0}deg)`,
    transition: "transform 150ms"
  } }) })) }) }));
};
var MRT_ExpandButton = ({ row, staticRowIndex, table }) => {
  var _a, _b;
  const theme = useTheme();
  const { getState, options: { icons: { ExpandMoreIcon: ExpandMoreIcon2 }, localization, muiExpandButtonProps, positionExpandColumn, renderDetailPanel } } = table;
  const { density } = getState();
  const iconButtonProps = parseFromValuesOrFunc(muiExpandButtonProps, {
    row,
    staticRowIndex,
    table
  });
  const canExpand = row.getCanExpand();
  const isExpanded = row.getIsExpanded();
  const handleToggleExpand = (event) => {
    var _a2;
    event.stopPropagation();
    row.toggleExpanded();
    (_a2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(iconButtonProps, event);
  };
  const detailPanel = !!(renderDetailPanel === null || renderDetailPanel === void 0 ? void 0 : renderDetailPanel({ row, table }));
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({ disableHoverListener: !canExpand && !detailPanel }, getCommonTooltipProps(), { title: (_a = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _a !== void 0 ? _a : isExpanded ? localization.collapse : localization.expand, children: (0, import_jsx_runtime24.jsx)("span", { children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": localization.expand, disabled: !canExpand && !detailPanel }, iconButtonProps, { onClick: handleToggleExpand, sx: (theme2) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.25rem", opacity: !canExpand && !detailPanel ? 0.3 : 1, [theme2.direction === "rtl" || positionExpandColumn === "last" ? "mr" : "ml"]: `${row.depth * 16}px`, width: density === "compact" ? "1.75rem" : "2.25rem" }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme2)), title: void 0, children: (_b = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _b !== void 0 ? _b : (0, import_jsx_runtime24.jsx)(ExpandMoreIcon2, { style: {
    transform: `rotate(${!canExpand && !renderDetailPanel ? positionExpandColumn === "last" || theme.direction === "rtl" ? 90 : -90 : isExpanded ? -180 : 0}deg)`,
    transition: "transform 150ms"
  } }) })) }) }));
};
var getMRT_RowExpandColumnDef = (tableOptions) => {
  var _a;
  const { defaultColumn, enableExpandAll, groupedColumnMode, positionExpandColumn, renderDetailPanel, state: { grouping } } = tableOptions;
  const alignProps = positionExpandColumn === "last" ? {
    align: "right"
  } : void 0;
  return Object.assign({ Cell: ({ cell, column, row, staticRowIndex, table }) => {
    var _a2, _b, _c;
    const expandButtonProps = { row, staticRowIndex, table };
    const subRowsLength = (_a2 = row.subRows) === null || _a2 === void 0 ? void 0 : _a2.length;
    if (groupedColumnMode === "remove" && row.groupingColumnId) {
      return (0, import_jsx_runtime24.jsxs)(Stack_default, { alignItems: "center", flexDirection: "row", gap: "0.25rem", children: [(0, import_jsx_runtime24.jsx)(MRT_ExpandButton, Object.assign({}, expandButtonProps)), (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, getCommonTooltipProps("right"), { title: table.getColumn(row.groupingColumnId).columnDef.header, children: (0, import_jsx_runtime24.jsx)("span", { children: row.groupingValue }) })), !!subRowsLength && (0, import_jsx_runtime24.jsxs)("span", { children: ["(", subRowsLength, ")"] })] });
    } else {
      return (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(MRT_ExpandButton, Object.assign({}, expandButtonProps)), (_c = (_b = column.columnDef).GroupedCell) === null || _c === void 0 ? void 0 : _c.call(_b, { cell, column, row, table })] });
    }
  }, Header: enableExpandAll ? ({ table }) => {
    var _a2;
    return (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(MRT_ExpandAllButton, { table }), groupedColumnMode === "remove" && ((_a2 = grouping === null || grouping === void 0 ? void 0 : grouping.map((groupedColumnId) => table.getColumn(groupedColumnId).columnDef.header)) === null || _a2 === void 0 ? void 0 : _a2.join(", "))] });
  } : void 0, muiTableBodyCellProps: alignProps, muiTableHeadCellProps: alignProps }, defaultDisplayColumnProps({
    header: "expand",
    id: "mrt-row-expand",
    size: groupedColumnMode === "remove" ? (_a = defaultColumn === null || defaultColumn === void 0 ? void 0 : defaultColumn.size) !== null && _a !== void 0 ? _a : 180 : renderDetailPanel ? enableExpandAll ? 60 : 70 : 100,
    tableOptions
  }));
};
var getMRT_RowNumbersColumnDef = (tableOptions) => {
  const { localization, rowNumberDisplayMode } = tableOptions;
  const { pagination: { pageIndex, pageSize } } = tableOptions.state;
  return Object.assign({ Cell: ({ row, staticRowIndex }) => {
    var _a;
    return ((_a = rowNumberDisplayMode === "static" ? (staticRowIndex || 0) + (pageSize || 0) * (pageIndex || 0) : row.index) !== null && _a !== void 0 ? _a : 0) + 1;
  }, Header: () => localization.rowNumber, grow: false }, defaultDisplayColumnProps({
    header: "rowNumbers",
    id: "mrt-row-numbers",
    size: 50,
    tableOptions
  }));
};
var MRT_RowPinButton = (_a) => {
  var { pinningPosition, row, table } = _a, rest = __rest(_a, ["pinningPosition", "row", "table"]);
  const { options: { icons: { CloseIcon: CloseIcon2, PushPinIcon: PushPinIcon2 }, localization, rowPinningDisplayMode } } = table;
  const isPinned = row.getIsPinned();
  const [tooltipOpened, setTooltipOpened] = (0, import_react.useState)(false);
  const handleTogglePin = (event) => {
    setTooltipOpened(false);
    event.stopPropagation();
    row.pin(isPinned ? false : pinningPosition);
  };
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, getCommonTooltipProps(), { open: tooltipOpened, title: isPinned ? localization.unpin : localization.pin, children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": localization.pin, onClick: handleTogglePin, onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false), size: "small" }, rest, { sx: (theme) => Object.assign({ height: "24px", width: "24px" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: isPinned ? (0, import_jsx_runtime24.jsx)(CloseIcon2, {}) : (0, import_jsx_runtime24.jsx)(PushPinIcon2, { fontSize: "small", style: {
    transform: `rotate(${rowPinningDisplayMode === "sticky" ? 135 : pinningPosition === "top" ? 180 : 0}deg)`
  } }) })) }));
};
var MRT_TableBodyRowPinButton = (_a) => {
  var { row, table } = _a, rest = __rest(_a, ["row", "table"]);
  const { getState, options: { enableRowPinning, rowPinningDisplayMode } } = table;
  const { density } = getState();
  const canPin = parseFromValuesOrFunc(enableRowPinning, row);
  if (!canPin)
    return null;
  const rowPinButtonProps = Object.assign({
    row,
    table
  }, rest);
  if (rowPinningDisplayMode === "top-and-bottom" && !row.getIsPinned()) {
    return (0, import_jsx_runtime24.jsxs)(Box_default, { sx: {
      display: "flex",
      flexDirection: density === "compact" ? "row" : "column"
    }, children: [(0, import_jsx_runtime24.jsx)(MRT_RowPinButton, Object.assign({ pinningPosition: "top" }, rowPinButtonProps)), (0, import_jsx_runtime24.jsx)(MRT_RowPinButton, Object.assign({ pinningPosition: "bottom" }, rowPinButtonProps))] });
  }
  return (0, import_jsx_runtime24.jsx)(MRT_RowPinButton, Object.assign({ pinningPosition: rowPinningDisplayMode === "bottom" ? "bottom" : "top" }, rowPinButtonProps));
};
var getMRT_RowPinningColumnDef = (tableOptions) => {
  return Object.assign({ Cell: ({ row, table }) => (0, import_jsx_runtime24.jsx)(MRT_TableBodyRowPinButton, { row, table }), grow: false }, defaultDisplayColumnProps({
    header: "pin",
    id: "mrt-row-pin",
    size: 60,
    tableOptions
  }));
};
var MRT_SelectCheckbox = (_a) => {
  var _b;
  var { row, staticRowIndex, table } = _a, rest = __rest(_a, ["row", "staticRowIndex", "table"]);
  const { getState, options: { enableMultiRowSelection, localization, muiSelectAllCheckboxProps, muiSelectCheckboxProps, selectAllMode } } = table;
  const { density, isLoading } = getState();
  const selectAll = !row;
  const allRowsSelected = selectAll ? selectAllMode === "page" ? table.getIsAllPageRowsSelected() : table.getIsAllRowsSelected() : void 0;
  const isChecked = selectAll ? allRowsSelected : getIsRowSelected({ row, table });
  const checkboxProps = Object.assign(Object.assign({}, selectAll ? parseFromValuesOrFunc(muiSelectAllCheckboxProps, { table }) : parseFromValuesOrFunc(muiSelectCheckboxProps, {
    row,
    staticRowIndex,
    table
  })), rest);
  const onSelectionChange = row ? getMRT_RowSelectionHandler({
    row,
    staticRowIndex,
    table
  }) : void 0;
  const onSelectAllChange = getMRT_SelectAllHandler({ table });
  const commonProps = Object.assign(Object.assign({ "aria-label": selectAll ? localization.toggleSelectAll : localization.toggleSelectRow, checked: isChecked, disabled: isLoading || row && !row.getCanSelect() || (row === null || row === void 0 ? void 0 : row.id) === "mrt-row-create", inputProps: {
    "aria-label": selectAll ? localization.toggleSelectAll : localization.toggleSelectRow
  }, onChange: (event) => {
    event.stopPropagation();
    selectAll ? onSelectAllChange(event) : onSelectionChange(event);
  }, size: density === "compact" ? "small" : "medium" }, checkboxProps), { onClick: (e) => {
    var _a2;
    e.stopPropagation();
    (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(checkboxProps, e);
  }, sx: (theme) => Object.assign({ height: density === "compact" ? "1.75rem" : "2.5rem", m: density !== "compact" ? "-0.4rem" : void 0, width: density === "compact" ? "1.75rem" : "2.5rem", zIndex: 0 }, parseFromValuesOrFunc(checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx, theme)), title: void 0 });
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, getCommonTooltipProps(), { title: (_b = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _b !== void 0 ? _b : selectAll ? localization.toggleSelectAll : localization.toggleSelectRow, children: enableMultiRowSelection === false ? (0, import_jsx_runtime24.jsx)(Radio_default, Object.assign({}, commonProps)) : (0, import_jsx_runtime24.jsx)(Checkbox_default, Object.assign({ indeterminate: !isChecked && selectAll ? table.getIsSomeRowsSelected() : (row === null || row === void 0 ? void 0 : row.getIsSomeSelected()) && row.getCanSelectSubRows() }, commonProps)) }));
};
var getMRT_RowSelectColumnDef = (tableOptions) => {
  const { enableMultiRowSelection, enableSelectAll } = tableOptions;
  return Object.assign({ Cell: ({ row, staticRowIndex, table }) => (0, import_jsx_runtime24.jsx)(MRT_SelectCheckbox, { row, staticRowIndex, table }), Header: enableSelectAll && enableMultiRowSelection ? ({ table }) => (0, import_jsx_runtime24.jsx)(MRT_SelectCheckbox, { table }) : void 0, grow: false }, defaultDisplayColumnProps({
    header: "select",
    id: "mrt-row-select",
    size: enableSelectAll ? 60 : 70,
    tableOptions
  }));
};
var MRT_Default_Icons = {
  ArrowDownwardIcon: import_ArrowDownward.default,
  ArrowRightIcon: import_ArrowRight.default,
  CancelIcon: import_Cancel.default,
  ChevronLeftIcon: import_ChevronLeft.default,
  ChevronRightIcon: import_ChevronRight.default,
  ClearAllIcon: import_ClearAll.default,
  CloseIcon: import_Close.default,
  ContentCopy: import_ContentCopy.default,
  DensityLargeIcon: import_DensityLarge.default,
  DensityMediumIcon: import_DensityMedium.default,
  DensitySmallIcon: import_DensitySmall.default,
  DragHandleIcon: import_DragHandle.default,
  DynamicFeedIcon: import_DynamicFeed.default,
  EditIcon: import_Edit.default,
  ExpandMoreIcon: import_ExpandMore.default,
  FilterAltIcon: import_FilterAlt.default,
  FilterListIcon: import_FilterList.default,
  FilterListOffIcon: import_FilterListOff.default,
  FirstPageIcon: import_FirstPage.default,
  FullscreenExitIcon: import_FullscreenExit.default,
  FullscreenIcon: import_Fullscreen.default,
  KeyboardDoubleArrowDownIcon: import_KeyboardDoubleArrowDown.default,
  LastPageIcon: import_LastPage.default,
  MoreHorizIcon: import_MoreHoriz.default,
  MoreVertIcon: import_MoreVert.default,
  PushPinIcon: import_PushPin.default,
  RestartAltIcon: import_RestartAlt.default,
  SaveIcon: import_Save.default,
  SearchIcon: import_Search.default,
  SearchOffIcon: import_SearchOff.default,
  SortIcon: import_Sort.default,
  SyncAltIcon: import_SyncAlt.default,
  ViewColumnIcon: import_ViewColumn.default,
  VisibilityOffIcon: import_VisibilityOff.default
};
var MRT_Localization_EN = {
  actions: "Actions",
  and: "and",
  cancel: "Cancel",
  changeFilterMode: "Change filter mode",
  changeSearchMode: "Change search mode",
  clearFilter: "Clear filter",
  clearSearch: "Clear search",
  clearSelection: "Clear selection",
  clearSort: "Clear sort",
  clickToCopy: "Click to copy",
  copy: "Copy",
  collapse: "Collapse",
  collapseAll: "Collapse all",
  columnActions: "Column Actions",
  copiedToClipboard: "Copied to clipboard",
  dropToGroupBy: "Drop to group by {column}",
  edit: "Edit",
  expand: "Expand",
  expandAll: "Expand all",
  filterArrIncludes: "Includes",
  filterArrIncludesAll: "Includes all",
  filterArrIncludesSome: "Includes",
  filterBetween: "Between",
  filterBetweenInclusive: "Between Inclusive",
  filterByColumn: "Filter by {column}",
  filterContains: "Contains",
  filterEmpty: "Empty",
  filterEndsWith: "Ends With",
  filterEquals: "Equals",
  filterEqualsString: "Equals",
  filterFuzzy: "Fuzzy",
  filterGreaterThan: "Greater Than",
  filterGreaterThanOrEqualTo: "Greater Than Or Equal To",
  filterInNumberRange: "Between",
  filterIncludesString: "Contains",
  filterIncludesStringSensitive: "Contains",
  filterLessThan: "Less Than",
  filterLessThanOrEqualTo: "Less Than Or Equal To",
  filterMode: "Filter Mode: {filterType}",
  filterNotEmpty: "Not Empty",
  filterNotEquals: "Not Equals",
  filterStartsWith: "Starts With",
  filterWeakEquals: "Equals",
  filteringByColumn: "Filtering by {column} - {filterType} {filterValue}",
  goToFirstPage: "Go to first page",
  goToLastPage: "Go to last page",
  goToNextPage: "Go to next page",
  goToPreviousPage: "Go to previous page",
  grab: "Grab",
  groupByColumn: "Group by {column}",
  groupedBy: "Grouped by ",
  hideAll: "Hide all",
  hideColumn: "Hide {column} column",
  max: "Max",
  min: "Min",
  move: "Move",
  noRecordsToDisplay: "No records to display",
  noResultsFound: "No results found",
  of: "of",
  or: "or",
  pin: "Pin",
  pinToLeft: "Pin to left",
  pinToRight: "Pin to right",
  resetColumnSize: "Reset column size",
  resetOrder: "Reset order",
  rowActions: "Row Actions",
  rowNumber: "#",
  rowNumbers: "Row Numbers",
  rowsPerPage: "Rows per page",
  save: "Save",
  search: "Search",
  selectedCountOfRowCountRowsSelected: "{selectedCount} of {rowCount} row(s) selected",
  select: "Select",
  showAll: "Show all",
  showAllColumns: "Show all columns",
  showHideColumns: "Show/Hide columns",
  showHideFilters: "Show/Hide filters",
  showHideSearch: "Show/Hide search",
  sortByColumnAsc: "Sort by {column} ascending",
  sortByColumnDesc: "Sort by {column} descending",
  sortedByColumnAsc: "Sorted by {column} ascending",
  sortedByColumnDesc: "Sorted by {column} descending",
  thenBy: ", then by ",
  toggleDensity: "Toggle density",
  toggleFullScreen: "Toggle full screen",
  toggleSelectAll: "Toggle select all",
  toggleSelectRow: "Toggle select row",
  toggleVisibility: "Toggle visibility",
  ungroupByColumn: "Ungroup by {column}",
  unpin: "Unpin",
  unpinAll: "Unpin all"
};
var MRT_DefaultColumn = {
  filterVariant: "text",
  maxSize: 1e3,
  minSize: 40,
  size: 180
};
var MRT_DefaultDisplayColumn = {
  columnDefType: "display",
  enableClickToCopy: false,
  enableColumnActions: false,
  enableColumnDragging: false,
  enableColumnFilter: false,
  enableColumnOrdering: false,
  enableEditing: false,
  enableGlobalFilter: false,
  enableGrouping: false,
  enableHiding: false,
  enableResizing: false,
  enableSorting: false
};
var useMRT_TableOptions = (_a) => {
  var _b;
  var { aggregationFns: aggregationFns2, autoResetExpanded = false, columnFilterDisplayMode = "subheader", columnResizeDirection, columnResizeMode = "onChange", createDisplayMode = "modal", defaultColumn, defaultDisplayColumn, editDisplayMode = "modal", enableBatchRowSelection = true, enableBottomToolbar = true, enableColumnActions = true, enableColumnFilters = true, enableColumnOrdering = false, enableColumnPinning = false, enableColumnResizing = false, enableColumnVirtualization, enableDensityToggle = true, enableExpandAll = true, enableExpanding, enableFacetedValues = false, enableFilterMatchHighlighting = true, enableFilters = true, enableFullScreenToggle = true, enableGlobalFilter = true, enableGlobalFilterRankedResults = true, enableGrouping = false, enableHiding = true, enableMultiRowSelection = true, enableMultiSort = true, enablePagination = true, enableRowPinning = false, enableRowSelection = false, enableRowVirtualization, enableSelectAll = true, enableSorting = true, enableStickyHeader = false, enableTableFooter = true, enableTableHead = true, enableToolbarInternalActions = true, enableTopToolbar = true, filterFns: filterFns2, icons, layoutMode, localization, manualFiltering, manualGrouping, manualPagination, manualSorting, mrtTheme, paginationDisplayMode = "default", positionActionsColumn = "first", positionCreatingRow = "top", positionExpandColumn = "first", positionGlobalFilter = "right", positionPagination = "bottom", positionToolbarAlertBanner = "top", positionToolbarDropZone = "top", rowNumberDisplayMode = "static", rowPinningDisplayMode = "sticky", selectAllMode = "page", sortingFns: sortingFns2 } = _a, rest = __rest(_a, ["aggregationFns", "autoResetExpanded", "columnFilterDisplayMode", "columnResizeDirection", "columnResizeMode", "createDisplayMode", "defaultColumn", "defaultDisplayColumn", "editDisplayMode", "enableBatchRowSelection", "enableBottomToolbar", "enableColumnActions", "enableColumnFilters", "enableColumnOrdering", "enableColumnPinning", "enableColumnResizing", "enableColumnVirtualization", "enableDensityToggle", "enableExpandAll", "enableExpanding", "enableFacetedValues", "enableFilterMatchHighlighting", "enableFilters", "enableFullScreenToggle", "enableGlobalFilter", "enableGlobalFilterRankedResults", "enableGrouping", "enableHiding", "enableMultiRowSelection", "enableMultiSort", "enablePagination", "enableRowPinning", "enableRowSelection", "enableRowVirtualization", "enableSelectAll", "enableSorting", "enableStickyHeader", "enableTableFooter", "enableTableHead", "enableToolbarInternalActions", "enableTopToolbar", "filterFns", "icons", "layoutMode", "localization", "manualFiltering", "manualGrouping", "manualPagination", "manualSorting", "mrtTheme", "paginationDisplayMode", "positionActionsColumn", "positionCreatingRow", "positionExpandColumn", "positionGlobalFilter", "positionPagination", "positionToolbarAlertBanner", "positionToolbarDropZone", "rowNumberDisplayMode", "rowPinningDisplayMode", "selectAllMode", "sortingFns"]);
  const theme = useTheme();
  icons = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_Default_Icons), icons), [icons]);
  localization = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_Localization_EN), localization), [localization]);
  mrtTheme = (0, import_react.useMemo)(() => getMRTTheme(mrtTheme, theme), [mrtTheme, theme]);
  aggregationFns2 = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_AggregationFns), aggregationFns2), []);
  filterFns2 = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_FilterFns), filterFns2), []);
  sortingFns2 = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_SortingFns), sortingFns2), []);
  defaultColumn = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_DefaultColumn), defaultColumn), [defaultColumn]);
  defaultDisplayColumn = (0, import_react.useMemo)(() => Object.assign(Object.assign({}, MRT_DefaultDisplayColumn), defaultDisplayColumn), [defaultDisplayColumn]);
  [enableColumnVirtualization, enableRowVirtualization] = (0, import_react.useMemo)(() => [enableColumnVirtualization, enableRowVirtualization], []);
  if (!columnResizeDirection) {
    columnResizeDirection = theme.direction || "ltr";
  }
  layoutMode = layoutMode || (enableColumnResizing ? "grid-no-grow" : "semantic");
  if (layoutMode === "semantic" && (enableRowVirtualization || enableColumnVirtualization)) {
    layoutMode = "grid";
  }
  if (enableRowVirtualization) {
    enableStickyHeader = true;
  }
  if (enablePagination === false && manualPagination === void 0) {
    manualPagination = true;
  }
  if (!((_b = rest.data) === null || _b === void 0 ? void 0 : _b.length)) {
    manualFiltering = true;
    manualGrouping = true;
    manualPagination = true;
    manualSorting = true;
  }
  return Object.assign({
    aggregationFns: aggregationFns2,
    autoResetExpanded,
    columnFilterDisplayMode,
    columnResizeDirection,
    columnResizeMode,
    createDisplayMode,
    defaultColumn,
    defaultDisplayColumn,
    editDisplayMode,
    enableBatchRowSelection,
    enableBottomToolbar,
    enableColumnActions,
    enableColumnFilters,
    enableColumnOrdering,
    enableColumnPinning,
    enableColumnResizing,
    enableColumnVirtualization,
    enableDensityToggle,
    enableExpandAll,
    enableExpanding,
    enableFacetedValues,
    enableFilterMatchHighlighting,
    enableFilters,
    enableFullScreenToggle,
    enableGlobalFilter,
    enableGlobalFilterRankedResults,
    enableGrouping,
    enableHiding,
    enableMultiRowSelection,
    enableMultiSort,
    enablePagination,
    enableRowPinning,
    enableRowSelection,
    enableRowVirtualization,
    enableSelectAll,
    enableSorting,
    enableStickyHeader,
    enableTableFooter,
    enableTableHead,
    enableToolbarInternalActions,
    enableTopToolbar,
    filterFns: filterFns2,
    getCoreRowModel: getCoreRowModel(),
    getExpandedRowModel: enableExpanding || enableGrouping ? getExpandedRowModel() : void 0,
    getFacetedMinMaxValues: enableFacetedValues ? getFacetedMinMaxValues() : void 0,
    getFacetedRowModel: enableFacetedValues ? getFacetedRowModel() : void 0,
    getFacetedUniqueValues: enableFacetedValues ? getFacetedUniqueValues() : void 0,
    getFilteredRowModel: enableColumnFilters || enableGlobalFilter || enableFilters ? getFilteredRowModel() : void 0,
    getGroupedRowModel: enableGrouping ? getGroupedRowModel() : void 0,
    getPaginationRowModel: enablePagination ? getPaginationRowModel() : void 0,
    getSortedRowModel: enableSorting ? getSortedRowModel() : void 0,
    getSubRows: (row) => row === null || row === void 0 ? void 0 : row.subRows,
    icons,
    layoutMode,
    localization,
    manualFiltering,
    manualGrouping,
    manualPagination,
    manualSorting,
    mrtTheme,
    paginationDisplayMode,
    positionActionsColumn,
    positionCreatingRow,
    positionExpandColumn,
    positionGlobalFilter,
    positionPagination,
    positionToolbarAlertBanner,
    positionToolbarDropZone,
    rowNumberDisplayMode,
    rowPinningDisplayMode,
    selectAllMode,
    sortingFns: sortingFns2
  }, rest);
};
var blankColProps = {
  children: null,
  sx: {
    minWidth: 0,
    p: 0,
    width: 0
  }
};
var getMRT_RowSpacerColumnDef = (tableOptions) => {
  return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultDisplayColumnProps({
    id: "mrt-row-spacer",
    size: 0,
    tableOptions
  })), { grow: true }), MRT_DefaultDisplayColumn), { muiTableBodyCellProps: blankColProps, muiTableFooterCellProps: blankColProps, muiTableHeadCellProps: blankColProps });
};
var useMRT_Effects = (table) => {
  const { getIsSomeRowsPinned, getPrePaginationRowModel, getState, options: { enablePagination, enableRowPinning, rowCount } } = table;
  const { columnOrder, density, globalFilter, isFullScreen, isLoading, pagination, showSkeletons, sorting } = getState();
  const totalColumnCount = table.options.columns.length;
  const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;
  const rerender = (0, import_react.useReducer)(() => ({}), {})[1];
  const initialBodyHeight = (0, import_react.useRef)();
  const previousTop = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    if (typeof window !== "undefined") {
      initialBodyHeight.current = document.body.style.height;
    }
  }, []);
  (0, import_react.useEffect)(() => {
    if (typeof window !== "undefined") {
      if (isFullScreen) {
        previousTop.current = document.body.getBoundingClientRect().top;
        document.body.style.height = "100dvh";
      } else {
        document.body.style.height = initialBodyHeight.current;
        if (!previousTop.current)
          return;
        window.scrollTo({
          behavior: "instant",
          top: -1 * previousTop.current
        });
      }
    }
  }, [isFullScreen]);
  (0, import_react.useEffect)(() => {
    if (totalColumnCount !== columnOrder.length) {
      table.setColumnOrder(getDefaultColumnOrderIds(table.options));
    }
  }, [totalColumnCount]);
  (0, import_react.useEffect)(() => {
    if (!enablePagination || isLoading || showSkeletons)
      return;
    const { pageIndex, pageSize } = pagination;
    const firstVisibleRowIndex = pageIndex * pageSize;
    if (firstVisibleRowIndex >= totalRowCount) {
      table.setPageIndex(Math.ceil(totalRowCount / pageSize) - 1);
    }
  }, [totalRowCount]);
  const appliedSort = (0, import_react.useRef)(sorting);
  (0, import_react.useEffect)(() => {
    if (sorting.length) {
      appliedSort.current = sorting;
    }
  }, [sorting]);
  (0, import_react.useEffect)(() => {
    if (!getCanRankRows(table))
      return;
    if (globalFilter) {
      table.setSorting([]);
    } else {
      table.setSorting(() => appliedSort.current || []);
    }
  }, [globalFilter]);
  (0, import_react.useEffect)(() => {
    if (enableRowPinning && getIsSomeRowsPinned()) {
      setTimeout(() => {
        rerender();
      }, 150);
    }
  }, [density]);
};
var useMRT_TableInstance = (definedTableOptions) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
  const lastSelectedRowId = (0, import_react.useRef)(null);
  const actionCellRef = (0, import_react.useRef)(null);
  const bottomToolbarRef = (0, import_react.useRef)(null);
  const editInputRefs = (0, import_react.useRef)({});
  const filterInputRefs = (0, import_react.useRef)({});
  const searchInputRef = (0, import_react.useRef)(null);
  const tableContainerRef = (0, import_react.useRef)(null);
  const tableHeadCellRefs = (0, import_react.useRef)({});
  const tablePaperRef = (0, import_react.useRef)(null);
  const topToolbarRef = (0, import_react.useRef)(null);
  const tableHeadRef = (0, import_react.useRef)(null);
  const tableFooterRef = (0, import_react.useRef)(null);
  const initialState = (0, import_react.useMemo)(() => {
    var _a2, _b2, _c2;
    const initState = (_a2 = definedTableOptions.initialState) !== null && _a2 !== void 0 ? _a2 : {};
    initState.columnOrder = (_b2 = initState.columnOrder) !== null && _b2 !== void 0 ? _b2 : getDefaultColumnOrderIds(Object.assign(Object.assign({}, definedTableOptions), { state: Object.assign(Object.assign({}, definedTableOptions.initialState), definedTableOptions.state) }));
    initState.globalFilterFn = (_c2 = definedTableOptions.globalFilterFn) !== null && _c2 !== void 0 ? _c2 : "fuzzy";
    return initState;
  }, []);
  definedTableOptions.initialState = initialState;
  const [actionCell, setActionCell] = (0, import_react.useState)((_a = initialState.actionCell) !== null && _a !== void 0 ? _a : null);
  const [creatingRow, _setCreatingRow] = (0, import_react.useState)((_b = initialState.creatingRow) !== null && _b !== void 0 ? _b : null);
  const [columnFilterFns, setColumnFilterFns] = (0, import_react.useState)(() => Object.assign({}, ...getAllLeafColumnDefs(definedTableOptions.columns).map((col) => {
    var _a2, _b2, _c2, _d2;
    return {
      [getColumnId(col)]: col.filterFn instanceof Function ? (_a2 = col.filterFn.name) !== null && _a2 !== void 0 ? _a2 : "custom" : (_d2 = (_b2 = col.filterFn) !== null && _b2 !== void 0 ? _b2 : (_c2 = initialState === null || initialState === void 0 ? void 0 : initialState.columnFilterFns) === null || _c2 === void 0 ? void 0 : _c2[getColumnId(col)]) !== null && _d2 !== void 0 ? _d2 : getDefaultColumnFilterFn(col)
    };
  })));
  const [columnOrder, onColumnOrderChange] = (0, import_react.useState)((_c = initialState.columnOrder) !== null && _c !== void 0 ? _c : []);
  const [columnSizingInfo, onColumnSizingInfoChange] = (0, import_react.useState)((_d = initialState.columnSizingInfo) !== null && _d !== void 0 ? _d : {});
  const [density, setDensity] = (0, import_react.useState)((_e = initialState === null || initialState === void 0 ? void 0 : initialState.density) !== null && _e !== void 0 ? _e : "comfortable");
  const [draggingColumn, setDraggingColumn] = (0, import_react.useState)((_f = initialState.draggingColumn) !== null && _f !== void 0 ? _f : null);
  const [draggingRow, setDraggingRow] = (0, import_react.useState)((_g = initialState.draggingRow) !== null && _g !== void 0 ? _g : null);
  const [editingCell, setEditingCell] = (0, import_react.useState)((_h = initialState.editingCell) !== null && _h !== void 0 ? _h : null);
  const [editingRow, setEditingRow] = (0, import_react.useState)((_j = initialState.editingRow) !== null && _j !== void 0 ? _j : null);
  const [globalFilterFn, setGlobalFilterFn] = (0, import_react.useState)((_k = initialState.globalFilterFn) !== null && _k !== void 0 ? _k : "fuzzy");
  const [grouping, onGroupingChange] = (0, import_react.useState)((_l = initialState.grouping) !== null && _l !== void 0 ? _l : []);
  const [hoveredColumn, setHoveredColumn] = (0, import_react.useState)((_m = initialState.hoveredColumn) !== null && _m !== void 0 ? _m : null);
  const [hoveredRow, setHoveredRow] = (0, import_react.useState)((_o = initialState.hoveredRow) !== null && _o !== void 0 ? _o : null);
  const [isFullScreen, setIsFullScreen] = (0, import_react.useState)((_p = initialState === null || initialState === void 0 ? void 0 : initialState.isFullScreen) !== null && _p !== void 0 ? _p : false);
  const [pagination, onPaginationChange] = (0, import_react.useState)((_q = initialState === null || initialState === void 0 ? void 0 : initialState.pagination) !== null && _q !== void 0 ? _q : { pageIndex: 0, pageSize: 10 });
  const [showAlertBanner, setShowAlertBanner] = (0, import_react.useState)((_r = initialState === null || initialState === void 0 ? void 0 : initialState.showAlertBanner) !== null && _r !== void 0 ? _r : false);
  const [showColumnFilters, setShowColumnFilters] = (0, import_react.useState)((_s = initialState === null || initialState === void 0 ? void 0 : initialState.showColumnFilters) !== null && _s !== void 0 ? _s : false);
  const [showGlobalFilter, setShowGlobalFilter] = (0, import_react.useState)((_t = initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) !== null && _t !== void 0 ? _t : false);
  const [showToolbarDropZone, setShowToolbarDropZone] = (0, import_react.useState)((_u = initialState === null || initialState === void 0 ? void 0 : initialState.showToolbarDropZone) !== null && _u !== void 0 ? _u : false);
  definedTableOptions.state = Object.assign({
    actionCell,
    columnFilterFns,
    columnOrder,
    columnSizingInfo,
    creatingRow,
    density,
    draggingColumn,
    draggingRow,
    editingCell,
    editingRow,
    globalFilterFn,
    grouping,
    hoveredColumn,
    hoveredRow,
    isFullScreen,
    pagination,
    showAlertBanner,
    showColumnFilters,
    showGlobalFilter,
    showToolbarDropZone
  }, definedTableOptions.state);
  const statefulTableOptions = definedTableOptions;
  const columnDefsRef = (0, import_react.useRef)([]);
  statefulTableOptions.columns = statefulTableOptions.state.columnSizingInfo.isResizingColumn || statefulTableOptions.state.draggingColumn || statefulTableOptions.state.draggingRow ? columnDefsRef.current : prepareColumns({
    columnDefs: [
      ...[
        showRowPinningColumn(statefulTableOptions) && getMRT_RowPinningColumnDef(statefulTableOptions),
        showRowDragColumn(statefulTableOptions) && getMRT_RowDragColumnDef(statefulTableOptions),
        showRowActionsColumn(statefulTableOptions) && getMRT_RowActionsColumnDef(statefulTableOptions),
        showRowExpandColumn(statefulTableOptions) && getMRT_RowExpandColumnDef(statefulTableOptions),
        showRowSelectionColumn(statefulTableOptions) && getMRT_RowSelectColumnDef(statefulTableOptions),
        showRowNumbersColumn(statefulTableOptions) && getMRT_RowNumbersColumnDef(statefulTableOptions)
      ].filter(Boolean),
      ...statefulTableOptions.columns,
      ...[
        showRowSpacerColumn(statefulTableOptions) && getMRT_RowSpacerColumnDef(statefulTableOptions)
      ].filter(Boolean)
    ],
    tableOptions: statefulTableOptions
  });
  columnDefsRef.current = statefulTableOptions.columns;
  statefulTableOptions.data = (0, import_react.useMemo)(() => (statefulTableOptions.state.isLoading || statefulTableOptions.state.showSkeletons) && !statefulTableOptions.data.length ? [
    ...Array(Math.min(statefulTableOptions.state.pagination.pageSize, 20)).fill(null)
  ].map(() => Object.assign({}, ...getAllLeafColumnDefs(statefulTableOptions.columns).map((col) => ({
    [getColumnId(col)]: null
  })))) : statefulTableOptions.data, [
    statefulTableOptions.data,
    statefulTableOptions.state.isLoading,
    statefulTableOptions.state.showSkeletons
  ]);
  const table = useReactTable(Object.assign(Object.assign({
    onColumnOrderChange,
    onColumnSizingInfoChange,
    onGroupingChange,
    onPaginationChange
  }, statefulTableOptions), { globalFilterFn: (_v = statefulTableOptions.filterFns) === null || _v === void 0 ? void 0 : _v[globalFilterFn !== null && globalFilterFn !== void 0 ? globalFilterFn : "fuzzy"] }));
  table.refs = {
    actionCellRef,
    bottomToolbarRef,
    editInputRefs,
    filterInputRefs,
    lastSelectedRowId,
    searchInputRef,
    tableContainerRef,
    tableFooterRef,
    tableHeadCellRefs,
    tableHeadRef,
    tablePaperRef,
    topToolbarRef
  };
  table.setActionCell = (_w = statefulTableOptions.onActionCellChange) !== null && _w !== void 0 ? _w : setActionCell;
  table.setCreatingRow = (row) => {
    var _a2, _b2;
    let _row = row;
    if (row === true) {
      _row = createRow2(table);
    }
    (_b2 = (_a2 = statefulTableOptions === null || statefulTableOptions === void 0 ? void 0 : statefulTableOptions.onCreatingRowChange) === null || _a2 === void 0 ? void 0 : _a2.call(statefulTableOptions, _row)) !== null && _b2 !== void 0 ? _b2 : _setCreatingRow(_row);
  };
  table.setColumnFilterFns = (_x = statefulTableOptions.onColumnFilterFnsChange) !== null && _x !== void 0 ? _x : setColumnFilterFns;
  table.setDensity = (_y = statefulTableOptions.onDensityChange) !== null && _y !== void 0 ? _y : setDensity;
  table.setDraggingColumn = (_z = statefulTableOptions.onDraggingColumnChange) !== null && _z !== void 0 ? _z : setDraggingColumn;
  table.setDraggingRow = (_0 = statefulTableOptions.onDraggingRowChange) !== null && _0 !== void 0 ? _0 : setDraggingRow;
  table.setEditingCell = (_1 = statefulTableOptions.onEditingCellChange) !== null && _1 !== void 0 ? _1 : setEditingCell;
  table.setEditingRow = (_2 = statefulTableOptions.onEditingRowChange) !== null && _2 !== void 0 ? _2 : setEditingRow;
  table.setGlobalFilterFn = (_3 = statefulTableOptions.onGlobalFilterFnChange) !== null && _3 !== void 0 ? _3 : setGlobalFilterFn;
  table.setHoveredColumn = (_4 = statefulTableOptions.onHoveredColumnChange) !== null && _4 !== void 0 ? _4 : setHoveredColumn;
  table.setHoveredRow = (_5 = statefulTableOptions.onHoveredRowChange) !== null && _5 !== void 0 ? _5 : setHoveredRow;
  table.setIsFullScreen = (_6 = statefulTableOptions.onIsFullScreenChange) !== null && _6 !== void 0 ? _6 : setIsFullScreen;
  table.setShowAlertBanner = (_7 = statefulTableOptions.onShowAlertBannerChange) !== null && _7 !== void 0 ? _7 : setShowAlertBanner;
  table.setShowColumnFilters = (_8 = statefulTableOptions.onShowColumnFiltersChange) !== null && _8 !== void 0 ? _8 : setShowColumnFilters;
  table.setShowGlobalFilter = (_9 = statefulTableOptions.onShowGlobalFilterChange) !== null && _9 !== void 0 ? _9 : setShowGlobalFilter;
  table.setShowToolbarDropZone = (_10 = statefulTableOptions.onShowToolbarDropZoneChange) !== null && _10 !== void 0 ? _10 : setShowToolbarDropZone;
  useMRT_Effects(table);
  return table;
};
var useMaterialReactTable = (tableOptions) => useMRT_TableInstance(useMRT_TableOptions(tableOptions));
var extraIndexRangeExtractor = (range, draggingIndex) => {
  const newIndexes = defaultRangeExtractor(range);
  if (draggingIndex === void 0)
    return newIndexes;
  if (draggingIndex >= 0 && draggingIndex < Math.max(range.startIndex - range.overscan, 0)) {
    newIndexes.unshift(draggingIndex);
  }
  if (draggingIndex >= 0 && draggingIndex > range.endIndex + range.overscan) {
    newIndexes.push(draggingIndex);
  }
  return newIndexes;
};
var useMRT_ColumnVirtualizer = (table) => {
  var _a, _b, _c, _d;
  const { getLeftLeafColumns, getRightLeafColumns, getState, getVisibleLeafColumns, options: { columnVirtualizerInstanceRef, columnVirtualizerOptions, enableColumnPinning, enableColumnVirtualization }, refs: { tableContainerRef } } = table;
  const { columnPinning, draggingColumn } = getState();
  if (!enableColumnVirtualization)
    return void 0;
  const columnVirtualizerProps = parseFromValuesOrFunc(columnVirtualizerOptions, {
    table
  });
  const visibleColumns = getVisibleLeafColumns();
  const [leftPinnedIndexes, rightPinnedIndexes] = (0, import_react.useMemo)(() => enableColumnPinning ? [
    getLeftLeafColumns().map((c) => c.getPinnedIndex()),
    getRightLeafColumns().map((column) => visibleColumns.length - column.getPinnedIndex() - 1).sort((a, b) => a - b)
  ] : [[], []], [columnPinning, enableColumnPinning]);
  const numPinnedLeft = leftPinnedIndexes.length;
  const numPinnedRight = rightPinnedIndexes.length;
  const draggingColumnIndex = (0, import_react.useMemo)(() => (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) ? visibleColumns.findIndex((c) => c.id === (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) : void 0, [draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id]);
  const columnVirtualizer = useVirtualizer(Object.assign({ count: visibleColumns.length, estimateSize: (index) => visibleColumns[index].getSize(), getScrollElement: () => tableContainerRef.current, horizontal: true, overscan: 3, rangeExtractor: (0, import_react.useCallback)((range) => {
    const newIndexes = extraIndexRangeExtractor(range, draggingColumnIndex);
    if (!numPinnedLeft && !numPinnedRight) {
      return newIndexes;
    }
    return [
      .../* @__PURE__ */ new Set([
        ...leftPinnedIndexes,
        ...newIndexes,
        ...rightPinnedIndexes
      ])
    ];
  }, [leftPinnedIndexes, rightPinnedIndexes, draggingColumnIndex]) }, columnVirtualizerProps));
  const virtualColumns = columnVirtualizer.getVirtualItems();
  columnVirtualizer.virtualColumns = virtualColumns;
  const numColumns = virtualColumns.length;
  if (numColumns) {
    const totalSize = columnVirtualizer.getTotalSize();
    const leftNonPinnedStart = ((_a = virtualColumns[numPinnedLeft]) === null || _a === void 0 ? void 0 : _a.start) || 0;
    const leftNonPinnedEnd = ((_b = virtualColumns[leftPinnedIndexes.length - 1]) === null || _b === void 0 ? void 0 : _b.end) || 0;
    const rightNonPinnedStart = ((_c = virtualColumns[numColumns - numPinnedRight]) === null || _c === void 0 ? void 0 : _c.start) || 0;
    const rightNonPinnedEnd = ((_d = virtualColumns[numColumns - numPinnedRight - 1]) === null || _d === void 0 ? void 0 : _d.end) || 0;
    columnVirtualizer.virtualPaddingLeft = leftNonPinnedStart - leftNonPinnedEnd;
    columnVirtualizer.virtualPaddingRight = totalSize - rightNonPinnedEnd - (numPinnedRight ? totalSize - rightNonPinnedStart : 0);
  }
  if (columnVirtualizerInstanceRef) {
    columnVirtualizerInstanceRef.current = columnVirtualizer;
  }
  return columnVirtualizer;
};
var useMRT_RowVirtualizer = (table, rows) => {
  var _a;
  const { getRowModel, getState, options: { enableRowVirtualization, renderDetailPanel, rowVirtualizerInstanceRef, rowVirtualizerOptions }, refs: { tableContainerRef } } = table;
  const { density, draggingRow, expanded } = getState();
  if (!enableRowVirtualization)
    return void 0;
  const rowVirtualizerProps = parseFromValuesOrFunc(rowVirtualizerOptions, {
    table
  });
  const rowCount = (_a = rows === null || rows === void 0 ? void 0 : rows.length) !== null && _a !== void 0 ? _a : getRowModel().rows.length;
  const normalRowHeight = density === "compact" ? 37 : density === "comfortable" ? 58 : 73;
  const rowVirtualizer = useVirtualizer(Object.assign({ count: renderDetailPanel ? rowCount * 2 : rowCount, estimateSize: (index) => renderDetailPanel && index % 2 === 1 ? expanded === true ? 100 : 0 : normalRowHeight, getScrollElement: () => tableContainerRef.current, measureElement: typeof window !== "undefined" && navigator.userAgent.indexOf("Firefox") === -1 ? (element) => element === null || element === void 0 ? void 0 : element.getBoundingClientRect().height : void 0, overscan: 4, rangeExtractor: (0, import_react.useCallback)((range) => {
    var _a2;
    return extraIndexRangeExtractor(range, (_a2 = draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.index) !== null && _a2 !== void 0 ? _a2 : 0);
  }, [draggingRow]) }, rowVirtualizerProps));
  rowVirtualizer.virtualRows = rowVirtualizer.getVirtualItems();
  if (rowVirtualizerInstanceRef) {
    rowVirtualizerInstanceRef.current = rowVirtualizer;
  }
  return rowVirtualizer;
};
var useMRT_Rows = (table) => {
  const { getRowModel, getState, options: { data, enableGlobalFilterRankedResults, positionCreatingRow } } = table;
  const { creatingRow, expanded, globalFilter, pagination, rowPinning, sorting } = getState();
  const rows = (0, import_react.useMemo)(() => getMRT_Rows(table), [
    creatingRow,
    data,
    enableGlobalFilterRankedResults,
    expanded,
    getRowModel().rows,
    globalFilter,
    pagination.pageIndex,
    pagination.pageSize,
    positionCreatingRow,
    rowPinning,
    sorting
  ]);
  return rows;
};
var allowedTypes = ["string", "number"];
var MRT_TableBodyCellValue = ({ cell, rowRef, staticColumnIndex, staticRowIndex, table }) => {
  var _a, _b, _c;
  const { getState, options: { enableFilterMatchHighlighting, mrtTheme: { matchHighlightColor } } } = table;
  const { column, row } = cell;
  const { columnDef } = column;
  const { globalFilter, globalFilterFn } = getState();
  const filterValue = column.getFilterValue();
  let renderedCellValue = cell.getIsAggregated() && columnDef.AggregatedCell ? columnDef.AggregatedCell({
    cell,
    column,
    row,
    table
  }) : row.getIsGrouped() && !cell.getIsGrouped() ? null : cell.getIsGrouped() && columnDef.GroupedCell ? columnDef.GroupedCell({
    cell,
    column,
    row,
    table
  }) : void 0;
  const isGroupedValue = renderedCellValue !== void 0;
  if (!isGroupedValue) {
    renderedCellValue = cell.renderValue();
  }
  if (enableFilterMatchHighlighting && columnDef.enableFilterMatchHighlighting !== false && String(renderedCellValue) && allowedTypes.includes(typeof renderedCellValue) && (filterValue && allowedTypes.includes(typeof filterValue) && ["autocomplete", "text"].includes(columnDef.filterVariant) || globalFilter && allowedTypes.includes(typeof globalFilter) && column.getCanGlobalFilter())) {
    const chunks = highlightWords === null || highlightWords === void 0 ? void 0 : highlightWords({
      matchExactly: (filterValue ? columnDef._filterFn : globalFilterFn) !== "fuzzy",
      query: ((_a = filterValue !== null && filterValue !== void 0 ? filterValue : globalFilter) !== null && _a !== void 0 ? _a : "").toString(),
      text: renderedCellValue === null || renderedCellValue === void 0 ? void 0 : renderedCellValue.toString()
    });
    if ((chunks === null || chunks === void 0 ? void 0 : chunks.length) > 1 || ((_b = chunks === null || chunks === void 0 ? void 0 : chunks[0]) === null || _b === void 0 ? void 0 : _b.match)) {
      renderedCellValue = (0, import_jsx_runtime24.jsx)("span", { "aria-label": renderedCellValue, role: "note", children: (_c = chunks === null || chunks === void 0 ? void 0 : chunks.map(({ key, match, text: text2 }) => (0, import_jsx_runtime24.jsx)(Box_default, { "aria-hidden": "true", component: "span", sx: match ? {
        backgroundColor: matchHighlightColor,
        borderRadius: "2px",
        color: (theme) => theme.palette.mode === "dark" ? theme.palette.common.white : theme.palette.common.black,
        padding: "2px 1px"
      } : void 0, children: text2 }, key))) !== null && _c !== void 0 ? _c : renderedCellValue });
    }
  }
  if (columnDef.Cell && !isGroupedValue) {
    renderedCellValue = columnDef.Cell({
      cell,
      column,
      renderedCellValue,
      row,
      rowRef,
      staticColumnIndex,
      staticRowIndex,
      table
    });
  }
  return renderedCellValue;
};
var MRT_CopyButton = (_a) => {
  var _b;
  var { cell, table } = _a, rest = __rest(_a, ["cell", "table"]);
  const { options: { localization, muiCopyButtonProps } } = table;
  const { column, row } = cell;
  const { columnDef } = column;
  const [copied, setCopied] = (0, import_react.useState)(false);
  const handleCopy = (event, text2) => {
    event.stopPropagation();
    navigator.clipboard.writeText(text2);
    setCopied(true);
    setTimeout(() => setCopied(false), 4e3);
  };
  const buttonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiCopyButtonProps, {
    cell,
    column,
    row,
    table
  })), parseFromValuesOrFunc(columnDef.muiCopyButtonProps, {
    cell,
    column,
    row,
    table
  })), rest);
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, getCommonTooltipProps("top"), { title: (_b = buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.title) !== null && _b !== void 0 ? _b : copied ? localization.copiedToClipboard : localization.clickToCopy, children: (0, import_jsx_runtime24.jsx)(Button_default, Object.assign({ onClick: (e) => handleCopy(e, cell.getValue()), size: "small", type: "button", variant: "text" }, buttonProps, { sx: (theme) => Object.assign({ backgroundColor: "transparent", border: "none", color: "inherit", cursor: "copy", fontFamily: "inherit", fontSize: "inherit", letterSpacing: "inherit", m: "-0.25rem", minWidth: "unset", py: 0, textAlign: "inherit", textTransform: "inherit" }, parseFromValuesOrFunc(buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.sx, theme)), title: void 0 })) }));
};
var MRT_EditCellTextField = (_a) => {
  var _b, _c;
  var { cell, table } = _a, rest = __rest(_a, ["cell", "table"]);
  const { getState, options: { createDisplayMode, editDisplayMode, muiEditTextFieldProps }, refs: { editInputRefs }, setCreatingRow, setEditingCell, setEditingRow } = table;
  const { column, row } = cell;
  const { columnDef } = column;
  const { creatingRow, editingRow } = getState();
  const { editSelectOptions, editVariant } = columnDef;
  const isCreating = (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
  const isEditing = (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id;
  const [value, setValue] = (0, import_react.useState)(() => cell.getValue());
  const textFieldProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiEditTextFieldProps, {
    cell,
    column,
    row,
    table
  })), parseFromValuesOrFunc(columnDef.muiEditTextFieldProps, {
    cell,
    column,
    row,
    table
  })), rest);
  const selectOptions = parseFromValuesOrFunc(editSelectOptions, {
    cell,
    column,
    row,
    table
  });
  const isSelectEdit = editVariant === "select" || (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.select);
  const saveInputValueToRowCache = (newValue) => {
    row._valuesCache[column.id] = newValue;
    if (isCreating) {
      setCreatingRow(row);
    } else if (isEditing) {
      setEditingRow(row);
    }
  };
  const handleChange = (event) => {
    var _a2;
    (_a2 = textFieldProps.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, event);
    setValue(event.target.value);
    if (isSelectEdit) {
      saveInputValueToRowCache(event.target.value);
    }
  };
  const handleBlur = (event) => {
    var _a2;
    (_a2 = textFieldProps.onBlur) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, event);
    saveInputValueToRowCache(value);
    setEditingCell(null);
  };
  const handleEnterKeyDown = (event) => {
    var _a2, _b2;
    (_a2 = textFieldProps.onKeyDown) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, event);
    if (event.key === "Enter" && !event.shiftKey) {
      (_b2 = editInputRefs.current[column.id]) === null || _b2 === void 0 ? void 0 : _b2.blur();
    }
  };
  if (columnDef.Edit) {
    return (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, { children: (_b = columnDef.Edit) === null || _b === void 0 ? void 0 : _b.call(columnDef, { cell, column, row, table }) });
  }
  return (0, import_jsx_runtime24.jsx)(TextField_default, Object.assign({ disabled: parseFromValuesOrFunc(columnDef.enableEditing, row) === false, fullWidth: true, inputRef: (inputRef) => {
    if (inputRef) {
      editInputRefs.current[column.id] = inputRef;
      if (textFieldProps.inputRef) {
        textFieldProps.inputRef = inputRef;
      }
    }
  }, label: ["custom", "modal"].includes(isCreating ? createDisplayMode : editDisplayMode) ? columnDef.header : void 0, margin: "none", name: column.id, placeholder: !["custom", "modal"].includes(isCreating ? createDisplayMode : editDisplayMode) ? columnDef.header : void 0, select: isSelectEdit, size: "small", value: value !== null && value !== void 0 ? value : "", variant: "standard" }, textFieldProps, { InputProps: Object.assign(Object.assign(Object.assign({}, textFieldProps.variant !== "outlined" ? { disableUnderline: editDisplayMode === "table" } : {}), textFieldProps.InputProps), { sx: (theme) => {
    var _a2;
    return Object.assign({ mb: 0 }, parseFromValuesOrFunc((_a2 = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.InputProps) === null || _a2 === void 0 ? void 0 : _a2.sx, theme));
  } }), SelectProps: {
    MenuProps: { disableScrollLock: true }
  }, inputProps: Object.assign({ autoComplete: "new-password" }, textFieldProps.inputProps), onBlur: handleBlur, onChange: handleChange, onClick: (e) => {
    var _a2;
    e.stopPropagation();
    (_a2 = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, e);
  }, onKeyDown: handleEnterKeyDown, children: (_c = textFieldProps.children) !== null && _c !== void 0 ? _c : selectOptions === null || selectOptions === void 0 ? void 0 : selectOptions.map((option) => {
    const { label, value: value2 } = getValueAndLabel(option);
    return (0, import_jsx_runtime24.jsx)(MenuItem_default, { sx: {
      alignItems: "center",
      display: "flex",
      gap: "0.5rem",
      m: 0
    }, value: value2, children: label }, value2);
  }) }));
};
var MRT_TableBodyCell = (_a) => {
  var _b, _c, _d, _e, _f;
  var { cell, numRows, rowRef, staticColumnIndex, staticRowIndex, table } = _a, rest = __rest(_a, ["cell", "numRows", "rowRef", "staticColumnIndex", "staticRowIndex", "table"]);
  const theme = useTheme();
  const { getState, options: { columnResizeDirection, columnResizeMode, createDisplayMode, editDisplayMode, enableCellActions, enableClickToCopy, enableColumnOrdering, enableColumnPinning, enableGrouping, layoutMode, mrtTheme: { draggingBorderColor }, muiSkeletonProps, muiTableBodyCellProps }, setHoveredColumn } = table;
  const { actionCell, columnSizingInfo, creatingRow, density, draggingColumn, draggingRow, editingCell, editingRow, hoveredColumn, hoveredRow, isLoading, showSkeletons } = getState();
  const { column, row } = cell;
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const args = { cell, column, row, table };
  const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyCellProps, args)), parseFromValuesOrFunc(columnDef.muiTableBodyCellProps, args)), rest);
  const skeletonProps = parseFromValuesOrFunc(muiSkeletonProps, {
    cell,
    column,
    row,
    table
  });
  const [skeletonWidth, setSkeletonWidth] = (0, import_react.useState)(100);
  (0, import_react.useEffect)(() => {
    if (!isLoading && !showSkeletons || skeletonWidth !== 100)
      return;
    const size = column.getSize();
    setSkeletonWidth(columnDefType === "display" ? size / 2 : Math.round(Math.random() * (size - size / 3) + size / 3));
  }, [isLoading, showSkeletons]);
  const draggingBorders = (0, import_react.useMemo)(() => {
    const isDraggingColumn = (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id;
    const isHoveredColumn = (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id;
    const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;
    const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;
    const isFirstColumn = column.getIsFirstColumn();
    const isLastColumn = column.getIsLastColumn();
    const isLastRow = numRows && staticRowIndex === numRows - 1;
    const isResizingColumn = columnSizingInfo.isResizingColumn === column.id;
    const showResizeBorder = isResizingColumn && columnResizeMode === "onChange";
    const borderStyle = showResizeBorder ? `2px solid ${draggingBorderColor} !important` : isDraggingColumn || isDraggingRow ? `1px dashed ${theme.palette.grey[500]} !important` : isHoveredColumn || isHoveredRow || isResizingColumn ? `2px dashed ${draggingBorderColor} !important` : void 0;
    if (showResizeBorder) {
      return columnResizeDirection === "ltr" ? { borderRight: borderStyle } : { borderLeft: borderStyle };
    }
    return borderStyle ? {
      borderBottom: isDraggingRow || isHoveredRow || isLastRow && !isResizingColumn ? borderStyle : void 0,
      borderLeft: isDraggingColumn || isHoveredColumn || (isDraggingRow || isHoveredRow) && isFirstColumn ? borderStyle : void 0,
      borderRight: isDraggingColumn || isHoveredColumn || (isDraggingRow || isHoveredRow) && isLastColumn ? borderStyle : void 0,
      borderTop: isDraggingRow || isHoveredRow ? borderStyle : void 0
    } : void 0;
  }, [
    columnSizingInfo.isResizingColumn,
    draggingColumn,
    draggingRow,
    hoveredColumn,
    hoveredRow,
    staticRowIndex
  ]);
  const isColumnPinned = enableColumnPinning && columnDef.columnDefType !== "group" && column.getIsPinned();
  const isEditable = isCellEditable({ cell, table });
  const isEditing = isEditable && !["custom", "modal"].includes(editDisplayMode) && (editDisplayMode === "table" || (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) === row.id || (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) === cell.id) && !row.getIsGrouped();
  const isCreating = isEditable && createDisplayMode === "row" && (creatingRow === null || creatingRow === void 0 ? void 0 : creatingRow.id) === row.id;
  const showClickToCopyButton = (parseFromValuesOrFunc(enableClickToCopy, cell) === true || parseFromValuesOrFunc(columnDef.enableClickToCopy, cell) === true) && !["context-menu", false].includes(
    // @ts-ignore
    parseFromValuesOrFunc(columnDef.enableClickToCopy, cell)
  );
  const isRightClickable = parseFromValuesOrFunc(enableCellActions, cell);
  const cellValueProps = {
    cell,
    table
  };
  const handleDoubleClick = (event) => {
    var _a2;
    (_a2 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDoubleClick) === null || _a2 === void 0 ? void 0 : _a2.call(tableCellProps, event);
    openEditingCell({ cell, table });
  };
  const handleDragEnter = (e) => {
    var _a2;
    (_a2 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onDragEnter) === null || _a2 === void 0 ? void 0 : _a2.call(tableCellProps, e);
    if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      setHoveredColumn(null);
    }
    if (enableColumnOrdering && draggingColumn) {
      setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
    }
  };
  const handleContextMenu = (e) => {
    var _a2;
    (_a2 = tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.onContextMenu) === null || _a2 === void 0 ? void 0 : _a2.call(tableCellProps, e);
    if (isRightClickable) {
      e.preventDefault();
      table.setActionCell(cell);
      table.refs.actionCellRef.current = e.currentTarget;
    }
  };
  return (0, import_jsx_runtime24.jsx)(TableCell_default, Object.assign({ align: theme.direction === "rtl" ? "right" : "left", "data-index": staticColumnIndex, "data-pinned": !!isColumnPinned || void 0 }, tableCellProps, { onContextMenu: handleContextMenu, onDoubleClick: handleDoubleClick, onDragEnter: handleDragEnter, sx: (theme2) => Object.assign(Object.assign({ "&:hover": {
    outline: (actionCell === null || actionCell === void 0 ? void 0 : actionCell.id) === cell.id || editDisplayMode === "cell" && isEditable || editDisplayMode === "table" && (isCreating || isEditing) ? `1px solid ${theme2.palette.grey[500]}` : void 0,
    textOverflow: "clip"
  }, alignItems: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "center" : void 0, cursor: isRightClickable ? "context-menu" : isEditable && editDisplayMode === "cell" ? "pointer" : "inherit", outline: (actionCell === null || actionCell === void 0 ? void 0 : actionCell.id) === cell.id ? `1px solid ${theme2.palette.grey[500]}` : void 0, outlineOffset: "-1px", overflow: "hidden", p: density === "compact" ? columnDefType === "display" ? "0 0.5rem" : "0.5rem" : density === "comfortable" ? columnDefType === "display" ? "0.5rem 0.75rem" : "1rem" : columnDefType === "display" ? "1rem 1.25rem" : "1.5rem", textOverflow: columnDefType !== "display" ? "ellipsis" : void 0, whiteSpace: row.getIsPinned() || density === "compact" ? "nowrap" : "normal" }, getCommonMRTCellStyles({
    column,
    table,
    tableCellProps,
    theme: theme2
  })), draggingBorders), children: (_b = tableCellProps.children) !== null && _b !== void 0 ? _b : (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [cell.getIsPlaceholder() ? (_d = (_c = columnDef.PlaceholderCell) === null || _c === void 0 ? void 0 : _c.call(columnDef, { cell, column, row, table })) !== null && _d !== void 0 ? _d : null : showSkeletons !== false && (isLoading || showSkeletons) ? (0, import_jsx_runtime24.jsx)(Skeleton_default, Object.assign({ animation: "wave", height: 20, width: skeletonWidth }, skeletonProps)) : columnDefType === "display" && (["mrt-row-expand", "mrt-row-numbers", "mrt-row-select"].includes(column.id) || !row.getIsGrouped()) ? (_e = columnDef.Cell) === null || _e === void 0 ? void 0 : _e.call(columnDef, {
    cell,
    column,
    renderedCellValue: cell.renderValue(),
    row,
    rowRef,
    staticColumnIndex,
    staticRowIndex,
    table
  }) : isCreating || isEditing ? (0, import_jsx_runtime24.jsx)(MRT_EditCellTextField, { cell, table }) : showClickToCopyButton && columnDef.enableClickToCopy !== false ? (0, import_jsx_runtime24.jsx)(MRT_CopyButton, { cell, table, children: (0, import_jsx_runtime24.jsx)(MRT_TableBodyCellValue, Object.assign({}, cellValueProps)) }) : (0, import_jsx_runtime24.jsx)(MRT_TableBodyCellValue, Object.assign({}, cellValueProps)), cell.getIsGrouped() && !columnDef.GroupedCell && (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [" (", (_f = row.subRows) === null || _f === void 0 ? void 0 : _f.length, ")"] })] }) }));
};
var Memo_MRT_TableBodyCell = (0, import_react.memo)(MRT_TableBodyCell, (prev, next) => next.cell === prev.cell);
var MRT_TableDetailPanel = (_a) => {
  var { parentRowRef, row, rowVirtualizer, staticRowIndex, table, virtualRow } = _a, rest = __rest(_a, ["parentRowRef", "row", "rowVirtualizer", "staticRowIndex", "table", "virtualRow"]);
  const { getState, getVisibleLeafColumns, options: { enableRowVirtualization, layoutMode, mrtTheme: { baseBackgroundColor }, muiDetailPanelProps, muiTableBodyRowProps, renderDetailPanel } } = table;
  const { isLoading } = getState();
  const tableRowProps = parseFromValuesOrFunc(muiTableBodyRowProps, {
    isDetailPanel: true,
    row,
    staticRowIndex,
    table
  });
  const tableCellProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiDetailPanelProps, {
    row,
    table
  })), rest);
  const DetailPanel = !isLoading && (renderDetailPanel === null || renderDetailPanel === void 0 ? void 0 : renderDetailPanel({ row, table }));
  return (0, import_jsx_runtime24.jsx)(TableRow_default, Object.assign({ className: "Mui-TableBodyCell-DetailPanel", "data-index": renderDetailPanel ? staticRowIndex * 2 + 1 : staticRowIndex, ref: (node) => {
    var _a2;
    if (node) {
      (_a2 = rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement) === null || _a2 === void 0 ? void 0 : _a2.call(rowVirtualizer, node);
    }
  } }, tableRowProps, { sx: (theme) => {
    var _a2, _b;
    return Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, position: virtualRow ? "absolute" : void 0, top: virtualRow ? `${(_b = (_a2 = parentRowRef.current) === null || _a2 === void 0 ? void 0 : _a2.getBoundingClientRect()) === null || _b === void 0 ? void 0 : _b.height}px` : void 0, transform: virtualRow ? `translateY(${virtualRow === null || virtualRow === void 0 ? void 0 : virtualRow.start}px)` : void 0, width: "100%" }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme));
  }, children: (0, import_jsx_runtime24.jsx)(TableCell_default, Object.assign({ className: "Mui-TableBodyCell-DetailPanel", colSpan: getVisibleLeafColumns().length }, tableCellProps, { sx: (theme) => Object.assign({ backgroundColor: virtualRow ? baseBackgroundColor : void 0, borderBottom: !row.getIsExpanded() ? "none" : void 0, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, py: !!DetailPanel && row.getIsExpanded() ? "1rem" : 0, transition: !enableRowVirtualization ? "all 150ms ease-in-out" : void 0, width: `100%` }, parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme)), children: enableRowVirtualization ? row.getIsExpanded() && DetailPanel : (0, import_jsx_runtime24.jsx)(Collapse_default, { in: row.getIsExpanded(), mountOnEnter: true, unmountOnExit: true, children: DetailPanel }) })) }));
};
var MRT_TableBodyRow = (_a) => {
  var _b, _c, _d, _f;
  var { columnVirtualizer, numRows, pinnedRowIds, row, rowVirtualizer, staticRowIndex, table, virtualRow } = _a, rest = __rest(_a, ["columnVirtualizer", "numRows", "pinnedRowIds", "row", "rowVirtualizer", "staticRowIndex", "table", "virtualRow"]);
  const theme = useTheme();
  const { getState, options: { enableRowOrdering, enableRowPinning, enableStickyFooter, enableStickyHeader, layoutMode, memoMode, mrtTheme: { baseBackgroundColor, pinnedRowBackgroundColor, selectedRowBackgroundColor }, muiTableBodyRowProps, renderDetailPanel, rowPinningDisplayMode }, refs: { tableFooterRef, tableHeadRef }, setHoveredRow } = table;
  const { density, draggingColumn, draggingRow, editingCell, editingRow, hoveredRow, isFullScreen, rowPinning } = getState();
  const visibleCells = row.getVisibleCells();
  const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
  const isRowSelected2 = getIsRowSelected({ row, table });
  const isRowPinned = enableRowPinning && row.getIsPinned();
  const isDraggingRow = (draggingRow === null || draggingRow === void 0 ? void 0 : draggingRow.id) === row.id;
  const isHoveredRow = (hoveredRow === null || hoveredRow === void 0 ? void 0 : hoveredRow.id) === row.id;
  const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyRowProps, {
    row,
    staticRowIndex,
    table
  })), rest);
  const [bottomPinnedIndex, topPinnedIndex] = (0, import_react.useMemo)(() => {
    if (!enableRowPinning || !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) || !pinnedRowIds || !row.getIsPinned())
      return [];
    return [
      [...pinnedRowIds].reverse().indexOf(row.id),
      pinnedRowIds.indexOf(row.id)
    ];
  }, [pinnedRowIds, rowPinning]);
  const tableHeadHeight = (enableStickyHeader || isFullScreen) && ((_b = tableHeadRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight) || 0;
  const tableFooterHeight = enableStickyFooter && ((_c = tableFooterRef.current) === null || _c === void 0 ? void 0 : _c.clientHeight) || 0;
  const sx = parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme);
  const defaultRowHeight = density === "compact" ? 37 : density === "comfortable" ? 53 : 69;
  const customRowHeight = (
    // @ts-ignore
    parseInt((_f = (_d = tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style) === null || _d === void 0 ? void 0 : _d.height) !== null && _f !== void 0 ? _f : sx === null || sx === void 0 ? void 0 : sx.height, 10) || void 0
  );
  const rowHeight = customRowHeight || defaultRowHeight;
  const handleDragEnter = (_e) => {
    if (enableRowOrdering && draggingRow) {
      setHoveredRow(row);
    }
  };
  const rowRef = (0, import_react.useRef)(null);
  const cellHighlightColor = isRowSelected2 ? selectedRowBackgroundColor : isRowPinned ? pinnedRowBackgroundColor : void 0;
  const cellHighlightColorHover = (tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.hover) !== false ? isRowSelected2 ? cellHighlightColor : theme.palette.mode === "dark" ? `${lighten(baseBackgroundColor, 0.3)}` : `${darken(baseBackgroundColor, 0.3)}` : void 0;
  return (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsxs)(TableRow_default, Object.assign({ "data-index": renderDetailPanel ? staticRowIndex * 2 : staticRowIndex, "data-pinned": !!isRowPinned || void 0, "data-selected": isRowSelected2 || void 0, onDragEnter: handleDragEnter, ref: (node) => {
    if (node) {
      rowRef.current = node;
      rowVirtualizer === null || rowVirtualizer === void 0 ? void 0 : rowVirtualizer.measureElement(node);
    }
  }, selected: isRowSelected2 }, tableRowProps, { style: Object.assign({ transform: virtualRow ? `translateY(${virtualRow.start}px)` : void 0 }, tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.style), sx: (theme2) => Object.assign({ "&:hover td:after": cellHighlightColorHover ? Object.assign({ backgroundColor: alpha(cellHighlightColorHover, 0.3) }, commonCellBeforeAfterStyles) : void 0, backgroundColor: `${baseBackgroundColor} !important`, bottom: !virtualRow && bottomPinnedIndex !== void 0 && isRowPinned ? `${bottomPinnedIndex * rowHeight + (enableStickyFooter ? tableFooterHeight - 1 : 0)}px` : void 0, boxSizing: "border-box", display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, opacity: isRowPinned ? 0.97 : isDraggingRow || isHoveredRow ? 0.5 : 1, position: virtualRow ? "absolute" : (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) && isRowPinned ? "sticky" : "relative", td: Object.assign({}, getCommonPinnedCellStyles({ table, theme: theme2 })), "td:after": cellHighlightColor ? Object.assign({ backgroundColor: cellHighlightColor }, commonCellBeforeAfterStyles) : void 0, top: virtualRow ? 0 : topPinnedIndex !== void 0 && isRowPinned ? `${topPinnedIndex * rowHeight + (enableStickyHeader || isFullScreen ? tableHeadHeight - 1 : 0)}px` : void 0, transition: virtualRow ? "none" : "all 150ms ease-in-out", width: "100%", zIndex: (rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) && isRowPinned ? 2 : 0 }, sx), children: [virtualPaddingLeft ? (0, import_jsx_runtime24.jsx)("td", { style: { display: "flex", width: virtualPaddingLeft } }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : visibleCells).map((cellOrVirtualCell, staticColumnIndex) => {
    let cell = cellOrVirtualCell;
    if (columnVirtualizer) {
      staticColumnIndex = cellOrVirtualCell.index;
      cell = visibleCells[staticColumnIndex];
    }
    const props = {
      cell,
      numRows,
      rowRef,
      staticColumnIndex,
      staticRowIndex,
      table
    };
    return cell ? memoMode === "cells" && cell.column.columnDef.columnDefType === "data" && !draggingColumn && !draggingRow && (editingCell === null || editingCell === void 0 ? void 0 : editingCell.id) !== cell.id && (editingRow === null || editingRow === void 0 ? void 0 : editingRow.id) !== row.id ? (0, import_jsx_runtime24.jsx)(Memo_MRT_TableBodyCell, Object.assign({}, props), cell.id) : (0, import_jsx_runtime24.jsx)(MRT_TableBodyCell, Object.assign({}, props), cell.id) : null;
  }), virtualPaddingRight ? (0, import_jsx_runtime24.jsx)("td", { style: { display: "flex", width: virtualPaddingRight } }) : null] })), renderDetailPanel && !row.getIsGrouped() && (0, import_jsx_runtime24.jsx)(MRT_TableDetailPanel, { parentRowRef: rowRef, row, rowVirtualizer, staticRowIndex, table, virtualRow })] });
};
var Memo_MRT_TableBodyRow = (0, import_react.memo)(MRT_TableBodyRow, (prev, next) => prev.row === next.row && prev.staticRowIndex === next.staticRowIndex);
var MRT_TableBody = (_a) => {
  var _b, _c, _d, _e, _f, _g;
  var { columnVirtualizer, table } = _a, rest = __rest(_a, ["columnVirtualizer", "table"]);
  const { getBottomRows, getIsSomeRowsPinned, getRowModel, getState, getTopRows, options: { enableStickyFooter, enableStickyHeader, layoutMode, localization, memoMode, muiTableBodyProps, renderDetailPanel, renderEmptyRowsFallback, rowPinningDisplayMode }, refs: { tableFooterRef, tableHeadRef, tablePaperRef } } = table;
  const { columnFilters, globalFilter, isFullScreen, rowPinning } = getState();
  const tableBodyProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableBodyProps, { table })), rest);
  const tableHeadHeight = (enableStickyHeader || isFullScreen) && ((_b = tableHeadRef.current) === null || _b === void 0 ? void 0 : _b.clientHeight) || 0;
  const tableFooterHeight = enableStickyFooter && ((_c = tableFooterRef.current) === null || _c === void 0 ? void 0 : _c.clientHeight) || 0;
  const pinnedRowIds = (0, import_react.useMemo)(() => {
    var _a2, _b2;
    if (!((_a2 = rowPinning.bottom) === null || _a2 === void 0 ? void 0 : _a2.length) && !((_b2 = rowPinning.top) === null || _b2 === void 0 ? void 0 : _b2.length))
      return [];
    return getRowModel().rows.filter((row) => row.getIsPinned()).map((r) => r.id);
  }, [rowPinning, getRowModel().rows]);
  const rows = useMRT_Rows(table);
  const rowVirtualizer = useMRT_RowVirtualizer(table, rows);
  const { virtualRows } = rowVirtualizer !== null && rowVirtualizer !== void 0 ? rowVirtualizer : {};
  const commonRowProps = {
    columnVirtualizer,
    numRows: rows.length,
    table
  };
  return (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [!(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) && getIsSomeRowsPinned("top") && (0, import_jsx_runtime24.jsx)(TableBody_default, Object.assign({}, tableBodyProps, { sx: (theme) => Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, position: "sticky", top: tableHeadHeight - 1, zIndex: 1 }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme)), children: getTopRows().map((row, staticRowIndex) => {
    const props = Object.assign(Object.assign({}, commonRowProps), {
      row,
      staticRowIndex
    });
    return memoMode === "rows" ? (0, import_jsx_runtime24.jsx)(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id) : (0, import_jsx_runtime24.jsx)(MRT_TableBodyRow, Object.assign({}, props), row.id);
  }) })), (0, import_jsx_runtime24.jsx)(TableBody_default, Object.assign({}, tableBodyProps, { sx: (theme) => Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, height: rowVirtualizer ? `${rowVirtualizer.getTotalSize()}px` : void 0, minHeight: !rows.length ? "100px" : void 0, position: "relative" }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme)), children: (_d = tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.children) !== null && _d !== void 0 ? _d : !rows.length ? (0, import_jsx_runtime24.jsx)("tr", { style: {
    display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0
  }, children: (0, import_jsx_runtime24.jsx)("td", { colSpan: table.getVisibleLeafColumns().length, style: {
    display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0
  }, children: (_e = renderEmptyRowsFallback === null || renderEmptyRowsFallback === void 0 ? void 0 : renderEmptyRowsFallback({ table })) !== null && _e !== void 0 ? _e : (0, import_jsx_runtime24.jsx)(Typography_default, { sx: {
    color: "text.secondary",
    fontStyle: "italic",
    maxWidth: `min(100vw, ${(_g = (_f = tablePaperRef.current) === null || _f === void 0 ? void 0 : _f.clientWidth) !== null && _g !== void 0 ? _g : 360}px)`,
    py: "2rem",
    textAlign: "center",
    width: "100%"
  }, children: globalFilter || columnFilters.length ? localization.noResultsFound : localization.noRecordsToDisplay }) }) }) : (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, { children: (virtualRows !== null && virtualRows !== void 0 ? virtualRows : rows).map((rowOrVirtualRow, staticRowIndex) => {
    let row = rowOrVirtualRow;
    if (rowVirtualizer) {
      if (renderDetailPanel) {
        if (rowOrVirtualRow.index % 2 === 1) {
          return null;
        } else {
          staticRowIndex = rowOrVirtualRow.index / 2;
        }
      } else {
        staticRowIndex = rowOrVirtualRow.index;
      }
      row = rows[staticRowIndex];
    }
    const props = Object.assign(Object.assign({}, commonRowProps), {
      pinnedRowIds,
      row,
      rowVirtualizer,
      staticRowIndex,
      virtualRow: rowVirtualizer ? rowOrVirtualRow : void 0
    });
    const key = `${row.id}-${row.index}`;
    return memoMode === "rows" ? (0, import_jsx_runtime24.jsx)(Memo_MRT_TableBodyRow, Object.assign({}, props), key) : (0, import_jsx_runtime24.jsx)(MRT_TableBodyRow, Object.assign({}, props), key);
  }) }) })), !(rowPinningDisplayMode === null || rowPinningDisplayMode === void 0 ? void 0 : rowPinningDisplayMode.includes("sticky")) && getIsSomeRowsPinned("bottom") && (0, import_jsx_runtime24.jsx)(TableBody_default, Object.assign({}, tableBodyProps, { sx: (theme) => Object.assign({ bottom: tableFooterHeight - 1, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, position: "sticky", zIndex: 1 }, parseFromValuesOrFunc(tableBodyProps === null || tableBodyProps === void 0 ? void 0 : tableBodyProps.sx, theme)), children: getBottomRows().map((row, staticRowIndex) => {
    const props = Object.assign(Object.assign({}, commonRowProps), {
      row,
      staticRowIndex
    });
    return memoMode === "rows" ? (0, import_jsx_runtime24.jsx)(Memo_MRT_TableBodyRow, Object.assign({}, props), row.id) : (0, import_jsx_runtime24.jsx)(MRT_TableBodyRow, Object.assign({}, props), row.id);
  }) }))] });
};
var Memo_MRT_TableBody = (0, import_react.memo)(MRT_TableBody, (prev, next) => prev.table.options.data === next.table.options.data);
var MRT_TableFooterCell = (_a) => {
  var _b, _c, _d;
  var { footer, staticColumnIndex, table } = _a, rest = __rest(_a, ["footer", "staticColumnIndex", "table"]);
  const theme = useTheme();
  const { getState, options: { enableColumnPinning, muiTableFooterCellProps } } = table;
  const { density } = getState();
  const { column } = footer;
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const isColumnPinned = enableColumnPinning && columnDef.columnDefType !== "group" && column.getIsPinned();
  const args = { column, table };
  const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterCellProps, args)), parseFromValuesOrFunc(columnDef.muiTableFooterCellProps, args)), rest);
  return (0, import_jsx_runtime24.jsx)(TableCell_default, Object.assign({ align: columnDefType === "group" ? "center" : theme.direction === "rtl" ? "right" : "left", colSpan: footer.colSpan, "data-index": staticColumnIndex, "data-pinned": !!isColumnPinned || void 0, variant: "footer" }, tableCellProps, { sx: (theme2) => Object.assign(Object.assign({ fontWeight: "bold", p: density === "compact" ? "0.5rem" : density === "comfortable" ? "1rem" : "1.5rem", verticalAlign: "top" }, getCommonMRTCellStyles({
    column,
    header: footer,
    table,
    tableCellProps,
    theme: theme2
  })), parseFromValuesOrFunc(tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.sx, theme2)), children: (_b = tableCellProps.children) !== null && _b !== void 0 ? _b : footer.isPlaceholder ? null : (_d = (_c = parseFromValuesOrFunc(columnDef.Footer, {
    column,
    footer,
    table
  })) !== null && _c !== void 0 ? _c : columnDef.footer) !== null && _d !== void 0 ? _d : null }));
};
var MRT_TableFooterRow = (_a) => {
  var _b;
  var { columnVirtualizer, footerGroup, table } = _a, rest = __rest(_a, ["columnVirtualizer", "footerGroup", "table"]);
  const { options: { layoutMode, mrtTheme: { baseBackgroundColor }, muiTableFooterRowProps } } = table;
  const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
  if (!((_b = footerGroup.headers) === null || _b === void 0 ? void 0 : _b.some((header) => typeof header.column.columnDef.footer === "string" && !!header.column.columnDef.footer || header.column.columnDef.Footer))) {
    return null;
  }
  const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterRowProps, {
    footerGroup,
    table
  })), rest);
  return (0, import_jsx_runtime24.jsxs)(TableRow_default, Object.assign({}, tableRowProps, { sx: (theme) => Object.assign({ backgroundColor: baseBackgroundColor, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, position: "relative", width: "100%" }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme)), children: [virtualPaddingLeft ? (0, import_jsx_runtime24.jsx)("th", { style: { display: "flex", width: virtualPaddingLeft } }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : footerGroup.headers).map((footerOrVirtualFooter, staticColumnIndex) => {
    let footer = footerOrVirtualFooter;
    if (columnVirtualizer) {
      staticColumnIndex = footerOrVirtualFooter.index;
      footer = footerGroup.headers[staticColumnIndex];
    }
    return footer ? (0, import_jsx_runtime24.jsx)(MRT_TableFooterCell, { footer, staticColumnIndex, table }, footer.id) : null;
  }), virtualPaddingRight ? (0, import_jsx_runtime24.jsx)("th", { style: { display: "flex", width: virtualPaddingRight } }) : null] }));
};
var MRT_TableFooter = (_a) => {
  var { columnVirtualizer, table } = _a, rest = __rest(_a, ["columnVirtualizer", "table"]);
  const { getFooterGroups, getState, options: { enableStickyFooter, layoutMode, muiTableFooterProps }, refs: { tableFooterRef } } = table;
  const { isFullScreen } = getState();
  const tableFooterProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableFooterProps, {
    table
  })), rest);
  const stickFooter = (isFullScreen || enableStickyFooter) && enableStickyFooter !== false;
  return (0, import_jsx_runtime24.jsx)(TableFooter_default, Object.assign({}, tableFooterProps, { ref: (ref) => {
    tableFooterRef.current = ref;
    if (tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.ref) {
      tableFooterProps.ref.current = ref;
    }
  }, sx: (theme) => Object.assign({ bottom: stickFooter ? 0 : void 0, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, opacity: stickFooter ? 0.97 : void 0, outline: stickFooter ? theme.palette.mode === "light" ? `1px solid ${theme.palette.grey[300]}` : `1px solid ${theme.palette.grey[700]}` : void 0, position: stickFooter ? "sticky" : "relative", zIndex: stickFooter ? 1 : void 0 }, parseFromValuesOrFunc(tableFooterProps === null || tableFooterProps === void 0 ? void 0 : tableFooterProps.sx, theme)), children: getFooterGroups().map((footerGroup) => (0, import_jsx_runtime24.jsx)(MRT_TableFooterRow, { columnVirtualizer, footerGroup, table }, footerGroup.id)) }));
};
var mrtFilterOptions = (localization) => [
  {
    divider: false,
    label: localization.filterFuzzy,
    option: "fuzzy",
    symbol: "â‰ˆ"
  },
  {
    divider: false,
    label: localization.filterContains,
    option: "contains",
    symbol: "*"
  },
  {
    divider: false,
    label: localization.filterStartsWith,
    option: "startsWith",
    symbol: "a"
  },
  {
    divider: true,
    label: localization.filterEndsWith,
    option: "endsWith",
    symbol: "z"
  },
  {
    divider: false,
    label: localization.filterEquals,
    option: "equals",
    symbol: "="
  },
  {
    divider: true,
    label: localization.filterNotEquals,
    option: "notEquals",
    symbol: "â‰ "
  },
  {
    divider: false,
    label: localization.filterBetween,
    option: "between",
    symbol: "â‡¿"
  },
  {
    divider: true,
    label: localization.filterBetweenInclusive,
    option: "betweenInclusive",
    symbol: "â¬Œ"
  },
  {
    divider: false,
    label: localization.filterGreaterThan,
    option: "greaterThan",
    symbol: ">"
  },
  {
    divider: false,
    label: localization.filterGreaterThanOrEqualTo,
    option: "greaterThanOrEqualTo",
    symbol: "â‰¥"
  },
  {
    divider: false,
    label: localization.filterLessThan,
    option: "lessThan",
    symbol: "<"
  },
  {
    divider: true,
    label: localization.filterLessThanOrEqualTo,
    option: "lessThanOrEqualTo",
    symbol: "â‰¤"
  },
  {
    divider: false,
    label: localization.filterEmpty,
    option: "empty",
    symbol: "âˆ…"
  },
  {
    divider: false,
    label: localization.filterNotEmpty,
    option: "notEmpty",
    symbol: "!âˆ…"
  }
];
var rangeModes = ["between", "betweenInclusive", "inNumberRange"];
var emptyModes = ["empty", "notEmpty"];
var arrModes = ["arrIncludesSome", "arrIncludesAll", "arrIncludes"];
var rangeVariants = ["range-slider", "date-range", "datetime-range", "range"];
var MRT_FilterOptionMenu = (_a) => {
  var _b, _c, _d, _e;
  var { anchorEl, header, onSelect, setAnchorEl, setFilterValue, table } = _a, rest = __rest(_a, ["anchorEl", "header", "onSelect", "setAnchorEl", "setFilterValue", "table"]);
  const { getState, options: { columnFilterModeOptions, globalFilterModeOptions, localization, mrtTheme: { menuBackgroundColor }, renderColumnFilterModeMenuItems, renderGlobalFilterModeMenuItems }, setColumnFilterFns, setGlobalFilterFn } = table;
  const { density, globalFilterFn } = getState();
  const { column } = header !== null && header !== void 0 ? header : {};
  const { columnDef } = column !== null && column !== void 0 ? column : {};
  const currentFilterValue = column === null || column === void 0 ? void 0 : column.getFilterValue();
  let allowedColumnFilterOptions = (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _b !== void 0 ? _b : columnFilterModeOptions;
  if (rangeVariants.includes(columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant)) {
    allowedColumnFilterOptions = [
      ...rangeModes,
      ...allowedColumnFilterOptions !== null && allowedColumnFilterOptions !== void 0 ? allowedColumnFilterOptions : []
    ].filter((option) => rangeModes.includes(option));
  }
  const internalFilterOptions = (0, import_react.useMemo)(() => mrtFilterOptions(localization).filter((filterOption2) => columnDef ? allowedColumnFilterOptions === void 0 || (allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.includes(filterOption2.option)) : (!globalFilterModeOptions || globalFilterModeOptions.includes(filterOption2.option)) && ["contains", "fuzzy", "startsWith"].includes(filterOption2.option)), []);
  const handleSelectFilterMode = (option) => {
    var _a2, _b2;
    const prevFilterMode = (_a2 = columnDef === null || columnDef === void 0 ? void 0 : columnDef._filterFn) !== null && _a2 !== void 0 ? _a2 : "";
    if (!header || !column) {
      setGlobalFilterFn(option);
    } else if (option !== prevFilterMode) {
      setColumnFilterFns((prev) => Object.assign(Object.assign({}, prev), { [header.id]: option }));
      if (emptyModes.includes(option)) {
        if (currentFilterValue !== " " && !emptyModes.includes(prevFilterMode)) {
          column.setFilterValue(" ");
        } else if (currentFilterValue) {
          column.setFilterValue(currentFilterValue);
        }
      } else if ((columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === "multi-select" || arrModes.includes(option)) {
        if (currentFilterValue instanceof String || (currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.length)) {
          column.setFilterValue([]);
          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue([]);
        } else if (currentFilterValue) {
          column.setFilterValue(currentFilterValue);
        }
      } else if (((_b2 = columnDef === null || columnDef === void 0 ? void 0 : columnDef.filterVariant) === null || _b2 === void 0 ? void 0 : _b2.includes("range")) || rangeModes.includes(option)) {
        if (!Array.isArray(currentFilterValue) || !(currentFilterValue === null || currentFilterValue === void 0 ? void 0 : currentFilterValue.every((v) => v === "")) && !rangeModes.includes(prevFilterMode)) {
          column.setFilterValue(["", ""]);
          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue("");
        } else {
          column.setFilterValue(currentFilterValue);
        }
      } else {
        if (Array.isArray(currentFilterValue)) {
          column.setFilterValue("");
          setFilterValue === null || setFilterValue === void 0 ? void 0 : setFilterValue("");
        } else if (currentFilterValue === " " && emptyModes.includes(prevFilterMode)) {
          column.setFilterValue(void 0);
        } else {
          column.setFilterValue(currentFilterValue);
        }
      }
    }
    setAnchorEl(null);
    onSelect === null || onSelect === void 0 ? void 0 : onSelect();
  };
  const filterOption = !!header && columnDef ? columnDef._filterFn : globalFilterFn;
  return (0, import_jsx_runtime24.jsx)(Menu_default, Object.assign({ MenuListProps: {
    dense: density === "compact",
    sx: {
      backgroundColor: menuBackgroundColor
    }
  }, anchorEl, anchorOrigin: { horizontal: "right", vertical: "center" }, disableScrollLock: true, onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: (_e = header && column && columnDef ? (_d = (_c = columnDef.renderColumnFilterModeMenuItems) === null || _c === void 0 ? void 0 : _c.call(columnDef, {
    column,
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  })) !== null && _d !== void 0 ? _d : renderColumnFilterModeMenuItems === null || renderColumnFilterModeMenuItems === void 0 ? void 0 : renderColumnFilterModeMenuItems({
    column,
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  }) : renderGlobalFilterModeMenuItems === null || renderGlobalFilterModeMenuItems === void 0 ? void 0 : renderGlobalFilterModeMenuItems({
    internalFilterOptions,
    onSelectFilterMode: handleSelectFilterMode,
    table
  })) !== null && _e !== void 0 ? _e : internalFilterOptions.map(({ divider, label, option, symbol }, index) => (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { divider, icon: symbol, label, onClick: () => handleSelectFilterMode(option), selected: option === filterOption, table, value: option }, index)) }));
};
var MRT_ColumnActionMenu = (_a) => {
  var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  var { anchorEl, header, setAnchorEl, table } = _a, rest = __rest(_a, ["anchorEl", "header", "setAnchorEl", "table"]);
  const { getAllLeafColumns, getState, options: { columnFilterDisplayMode, columnFilterModeOptions, enableColumnFilterModes, enableColumnFilters, enableColumnPinning, enableColumnResizing, enableGrouping, enableHiding, enableSorting, enableSortingRemoval, icons: { ClearAllIcon: ClearAllIcon2, DynamicFeedIcon: DynamicFeedIcon2, FilterListIcon: FilterListIcon2, FilterListOffIcon: FilterListOffIcon2, PushPinIcon: PushPinIcon2, RestartAltIcon: RestartAltIcon2, SortIcon: SortIcon2, ViewColumnIcon: ViewColumnIcon2, VisibilityOffIcon: VisibilityOffIcon2 }, localization, mrtTheme: { menuBackgroundColor }, renderColumnActionsMenuItems }, refs: { filterInputRefs }, setColumnFilterFns, setColumnOrder, setColumnSizingInfo, setShowColumnFilters } = table;
  const { column } = header;
  const { columnDef } = column;
  const { columnSizing, columnVisibility, density, showColumnFilters } = getState();
  const columnFilterValue = column.getFilterValue();
  const [filterMenuAnchorEl, setFilterMenuAnchorEl] = (0, import_react.useState)(null);
  const handleClearSort = () => {
    column.clearSorting();
    setAnchorEl(null);
  };
  const handleSortAsc = () => {
    column.toggleSorting(false);
    setAnchorEl(null);
  };
  const handleSortDesc = () => {
    column.toggleSorting(true);
    setAnchorEl(null);
  };
  const handleResetColumnSize = () => {
    setColumnSizingInfo((old) => Object.assign(Object.assign({}, old), { isResizingColumn: false }));
    column.resetSize();
    setAnchorEl(null);
  };
  const handleHideColumn = () => {
    column.toggleVisibility(false);
    setAnchorEl(null);
  };
  const handlePinColumn = (pinDirection) => {
    column.pin(pinDirection);
    setAnchorEl(null);
  };
  const handleGroupByColumn = () => {
    column.toggleGrouping();
    setColumnOrder((old) => ["mrt-row-expand", ...old]);
    setAnchorEl(null);
  };
  const handleClearFilter = () => {
    column.setFilterValue(void 0);
    setAnchorEl(null);
    if (["empty", "notEmpty"].includes(columnDef._filterFn)) {
      setColumnFilterFns((prev) => {
        var _a2;
        return Object.assign(Object.assign({}, prev), { [header.id]: (_a2 = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a2 !== void 0 ? _a2 : "fuzzy" });
      });
    }
  };
  const handleFilterByColumn = () => {
    setShowColumnFilters(true);
    queueMicrotask(() => {
      var _a2;
      return (_a2 = filterInputRefs.current[`${column.id}-0`]) === null || _a2 === void 0 ? void 0 : _a2.focus();
    });
    setAnchorEl(null);
  };
  const handleShowAllColumns = () => {
    getAllLeafColumns().filter((col) => col.columnDef.enableHiding !== false).forEach((col) => col.toggleVisibility(true));
    setAnchorEl(null);
  };
  const handleOpenFilterModeMenu = (event) => {
    event.stopPropagation();
    setFilterMenuAnchorEl(event.currentTarget);
  };
  const isSelectFilter = !!columnDef.filterSelectOptions;
  const allowedColumnFilterOptions = (_b = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _b !== void 0 ? _b : columnFilterModeOptions;
  const showFilterModeSubMenu = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false && !isSelectFilter && (allowedColumnFilterOptions === void 0 || !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));
  const internalColumnMenuItems = [
    ...enableSorting && column.getCanSort() ? [
      enableSortingRemoval !== false && (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { icon: (0, import_jsx_runtime24.jsx)(ClearAllIcon2, {}), label: localization.clearSort, onClick: handleClearSort, table }, 0),
      (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { disabled: column.getIsSorted() === "asc", icon: (0, import_jsx_runtime24.jsx)(SortIcon2, { style: { transform: "rotate(180deg) scaleX(-1)" } }), label: (_c = localization.sortByColumnAsc) === null || _c === void 0 ? void 0 : _c.replace("{column}", String(columnDef.header)), onClick: handleSortAsc, table }, 1),
      (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { disabled: column.getIsSorted() === "desc", divider: enableColumnFilters || enableGrouping || enableHiding, icon: (0, import_jsx_runtime24.jsx)(SortIcon2, {}), label: (_d = localization.sortByColumnDesc) === null || _d === void 0 ? void 0 : _d.replace("{column}", String(columnDef.header)), onClick: handleSortDesc, table }, 2)
    ] : [],
    ...enableColumnFilters && column.getCanFilter() ? [
      (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { disabled: !columnFilterValue || Array.isArray(columnFilterValue) && !columnFilterValue.filter((value) => value).length, icon: (0, import_jsx_runtime24.jsx)(FilterListOffIcon2, {}), label: localization.clearFilter, onClick: handleClearFilter, table }, 3),
      columnFilterDisplayMode === "subheader" && (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { disabled: showColumnFilters && !enableColumnFilterModes, divider: enableGrouping || enableHiding, icon: (0, import_jsx_runtime24.jsx)(FilterListIcon2, {}), label: (_e = localization.filterByColumn) === null || _e === void 0 ? void 0 : _e.replace("{column}", String(columnDef.header)), onClick: showColumnFilters ? handleOpenFilterModeMenu : handleFilterByColumn, onOpenSubMenu: showFilterModeSubMenu ? handleOpenFilterModeMenu : void 0, table }, 4),
      showFilterModeSubMenu && (0, import_jsx_runtime24.jsx)(MRT_FilterOptionMenu, { anchorEl: filterMenuAnchorEl, header, onSelect: handleFilterByColumn, setAnchorEl: setFilterMenuAnchorEl, table }, 5)
    ].filter(Boolean) : [],
    ...enableGrouping && column.getCanGroup() ? [
      (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { divider: enableColumnPinning, icon: (0, import_jsx_runtime24.jsx)(DynamicFeedIcon2, {}), label: (_f = localization[column.getIsGrouped() ? "ungroupByColumn" : "groupByColumn"]) === null || _f === void 0 ? void 0 : _f.replace("{column}", String(columnDef.header)), onClick: handleGroupByColumn, table }, 6)
    ] : [],
    ...enableColumnPinning && column.getCanPin() ? [
      (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { disabled: column.getIsPinned() === "left" || !column.getCanPin(), icon: (0, import_jsx_runtime24.jsx)(PushPinIcon2, { style: { transform: "rotate(90deg)" } }), label: localization.pinToLeft, onClick: () => handlePinColumn("left"), table }, 7),
      (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { disabled: column.getIsPinned() === "right" || !column.getCanPin(), icon: (0, import_jsx_runtime24.jsx)(PushPinIcon2, { style: { transform: "rotate(-90deg)" } }), label: localization.pinToRight, onClick: () => handlePinColumn("right"), table }, 8),
      (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { disabled: !column.getIsPinned(), divider: enableHiding, icon: (0, import_jsx_runtime24.jsx)(PushPinIcon2, {}), label: localization.unpin, onClick: () => handlePinColumn(false), table }, 9)
    ] : [],
    ...enableColumnResizing && column.getCanResize() ? [
      (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { disabled: !columnSizing[column.id], icon: (0, import_jsx_runtime24.jsx)(RestartAltIcon2, {}), label: localization.resetColumnSize, onClick: handleResetColumnSize, table }, 10)
    ] : [],
    ...enableHiding ? [
      (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { disabled: !column.getCanHide(), icon: (0, import_jsx_runtime24.jsx)(VisibilityOffIcon2, {}), label: (_g = localization.hideColumn) === null || _g === void 0 ? void 0 : _g.replace("{column}", String(columnDef.header)), onClick: handleHideColumn, table }, 11),
      (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { disabled: !Object.values(columnVisibility).filter((visible) => !visible).length, icon: (0, import_jsx_runtime24.jsx)(ViewColumnIcon2, {}), label: (_h = localization.showAllColumns) === null || _h === void 0 ? void 0 : _h.replace("{column}", String(columnDef.header)), onClick: handleShowAllColumns, table }, 12)
    ] : []
  ].filter(Boolean);
  return (0, import_jsx_runtime24.jsx)(Menu_default, Object.assign({ MenuListProps: {
    dense: density === "compact",
    sx: {
      backgroundColor: menuBackgroundColor
    }
  }, anchorEl, disableScrollLock: true, onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: (_l = (_k = (_j = columnDef.renderColumnActionsMenuItems) === null || _j === void 0 ? void 0 : _j.call(columnDef, {
    closeMenu: () => setAnchorEl(null),
    column,
    internalColumnMenuItems,
    table
  })) !== null && _k !== void 0 ? _k : renderColumnActionsMenuItems === null || renderColumnActionsMenuItems === void 0 ? void 0 : renderColumnActionsMenuItems({
    closeMenu: () => setAnchorEl(null),
    column,
    internalColumnMenuItems,
    table
  })) !== null && _l !== void 0 ? _l : internalColumnMenuItems }));
};
var MRT_TableHeadCellColumnActionsButton = (_a) => {
  var _b, _c;
  var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
  const { options: { icons: { MoreVertIcon: MoreVertIcon2 }, localization, muiColumnActionsButtonProps } } = table;
  const { column } = header;
  const { columnDef } = column;
  const [anchorEl, setAnchorEl] = (0, import_react.useState)(null);
  const handleClick = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setAnchorEl(event.currentTarget);
  };
  const iconButtonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiColumnActionsButtonProps, {
    column,
    table
  })), parseFromValuesOrFunc(columnDef.muiColumnActionsButtonProps, {
    column,
    table
  })), rest);
  return (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, getCommonTooltipProps("top"), { title: (_b = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.title) !== null && _b !== void 0 ? _b : localization.columnActions, children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": localization.columnActions, onClick: handleClick, size: "small" }, iconButtonProps, { sx: (theme) => Object.assign({ "&:hover": {
    opacity: 1
  }, height: "2rem", m: "-8px -4px", opacity: 0.3, transition: "all 150ms", width: "2rem" }, parseFromValuesOrFunc(iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.sx, theme)), title: void 0, children: (_c = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.children) !== null && _c !== void 0 ? _c : (0, import_jsx_runtime24.jsx)(MoreVertIcon2, { style: { transform: "scale(0.9)" } }) })) })), anchorEl && (0, import_jsx_runtime24.jsx)(MRT_ColumnActionMenu, { anchorEl, header, setAnchorEl, table })] });
};
var MRT_FilterCheckbox = (_a) => {
  var _b, _c, _d;
  var { column, table } = _a, rest = __rest(_a, ["column", "table"]);
  const { getState, options: { localization, muiFilterCheckboxProps } } = table;
  const { density } = getState();
  const { columnDef } = column;
  const checkboxProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterCheckboxProps, {
    column,
    table
  })), parseFromValuesOrFunc(columnDef.muiFilterCheckboxProps, {
    column,
    table
  })), rest);
  const filterLabel = (_b = localization.filterByColumn) === null || _b === void 0 ? void 0 : _b.replace("{column}", columnDef.header);
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, getCommonTooltipProps(), { title: (_c = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.title) !== null && _c !== void 0 ? _c : filterLabel, children: (0, import_jsx_runtime24.jsx)(FormControlLabel_default, { control: (0, import_jsx_runtime24.jsx)(Checkbox_default, Object.assign({ checked: column.getFilterValue() === "true", color: column.getFilterValue() === void 0 ? "default" : "primary", indeterminate: column.getFilterValue() === void 0, size: density === "compact" ? "small" : "medium" }, checkboxProps, { onChange: (e, checked) => {
    var _a2;
    column.setFilterValue(column.getFilterValue() === void 0 ? "true" : column.getFilterValue() === "true" ? "false" : void 0);
    (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(checkboxProps, e, checked);
  }, onClick: (e) => {
    var _a2;
    e.stopPropagation();
    (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(checkboxProps, e);
  }, sx: (theme) => Object.assign({ height: "2.5rem", width: "2.5rem" }, parseFromValuesOrFunc(checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.sx, theme)) })), disableTypography: true, label: (_d = checkboxProps.title) !== null && _d !== void 0 ? _d : filterLabel, sx: { color: "text.secondary", fontWeight: "normal", mt: "-4px" }, title: void 0 }) }));
};
var MRT_FilterTextField = (_a) => {
  var _b, _c, _d, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
  var { header, rangeFilterIndex, table } = _a, rest = __rest(_a, ["header", "rangeFilterIndex", "table"]);
  const { options: { columnFilterModeOptions, enableColumnFilterModes, icons: { CloseIcon: CloseIcon2, FilterListIcon: FilterListIcon2 }, localization, manualFiltering, muiFilterAutocompleteProps, muiFilterDatePickerProps, muiFilterDateTimePickerProps, muiFilterTextFieldProps, muiFilterTimePickerProps }, refs: { filterInputRefs }, setColumnFilterFns } = table;
  const { column } = header;
  const { columnDef } = column;
  const { filterVariant } = columnDef;
  const textFieldProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterTextFieldProps, { column, table })), parseFromValuesOrFunc(columnDef.muiFilterTextFieldProps, {
    column,
    table
  })), rest);
  const autocompleteProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterAutocompleteProps, { column, table })), parseFromValuesOrFunc(columnDef.muiFilterAutocompleteProps, {
    column,
    table
  }));
  const datePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterDatePickerProps, { column, table })), parseFromValuesOrFunc(columnDef.muiFilterDatePickerProps, {
    column,
    table
  }));
  const dateTimePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterDateTimePickerProps, { column, table })), parseFromValuesOrFunc(columnDef.muiFilterDateTimePickerProps, {
    column,
    table
  }));
  const timePickerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterTimePickerProps, { column, table })), parseFromValuesOrFunc(columnDef.muiFilterTimePickerProps, {
    column,
    table
  }));
  const isDateFilter = (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith("date")) || (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith("time"));
  const isAutocompleteFilter = filterVariant === "autocomplete";
  const isRangeFilter = (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.includes("range")) || rangeFilterIndex !== void 0;
  const isSelectFilter = filterVariant === "select";
  const isMultiSelectFilter = filterVariant === "multi-select";
  const isTextboxFilter = ["autocomplete", "text"].includes(filterVariant) || !isSelectFilter && !isMultiSelectFilter;
  const currentFilterOption = columnDef._filterFn;
  const filterChipLabel = ["empty", "notEmpty"].includes(currentFilterOption) ? (
    //@ts-ignore
    localization[`filter${((_c = (_b = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt) === null || _b === void 0 ? void 0 : _b.call(currentFilterOption, 0)) === null || _c === void 0 ? void 0 : _c.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ) : "";
  const filterPlaceholder = !isRangeFilter ? (_d = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.placeholder) !== null && _d !== void 0 ? _d : (_f = localization.filterByColumn) === null || _f === void 0 ? void 0 : _f.replace("{column}", String(columnDef.header)) : rangeFilterIndex === 0 ? localization.min : rangeFilterIndex === 1 ? localization.max : "";
  const allowedColumnFilterOptions = (_g = columnDef === null || columnDef === void 0 ? void 0 : columnDef.columnFilterModeOptions) !== null && _g !== void 0 ? _g : columnFilterModeOptions;
  const showChangeModeButton = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false && !rangeFilterIndex && (allowedColumnFilterOptions === void 0 || !!(allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions.length));
  const facetedUniqueValues = column.getFacetedUniqueValues();
  const [anchorEl, setAnchorEl] = (0, import_react.useState)(null);
  const [filterValue, setFilterValue] = (0, import_react.useState)(() => {
    var _a2, _b2;
    return isMultiSelectFilter ? column.getFilterValue() || [] : isRangeFilter ? ((_a2 = column.getFilterValue()) === null || _a2 === void 0 ? void 0 : _a2[rangeFilterIndex]) || "" : (_b2 = column.getFilterValue()) !== null && _b2 !== void 0 ? _b2 : "";
  });
  const [autocompleteValue, setAutocompleteValue] = (0, import_react.useState)(isAutocompleteFilter ? filterValue : null);
  const handleChangeDebounced = (0, import_react.useCallback)(debounce_default((newValue) => {
    if (isRangeFilter) {
      column.setFilterValue((old) => {
        const newFilterValues = old !== null && old !== void 0 ? old : ["", ""];
        newFilterValues[rangeFilterIndex] = newValue !== null && newValue !== void 0 ? newValue : void 0;
        return newFilterValues;
      });
    } else {
      column.setFilterValue(newValue !== null && newValue !== void 0 ? newValue : void 0);
    }
  }, isTextboxFilter ? manualFiltering ? 400 : 200 : 1), []);
  const handleChange = (newValue) => {
    setFilterValue(newValue !== null && newValue !== void 0 ? newValue : "");
    handleChangeDebounced(newValue);
  };
  const handleTextFieldChange = (event) => {
    var _a2;
    const newValue = textFieldProps.type === "date" ? event.target.valueAsDate : textFieldProps.type === "number" ? event.target.valueAsNumber : event.target.value;
    handleChange(newValue);
    (_a2 = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(textFieldProps, event);
  };
  const handleAutocompleteChange = (newValue) => {
    setAutocompleteValue(newValue);
    handleChange(getValueAndLabel(newValue).value);
  };
  const handleClear = () => {
    if (isMultiSelectFilter) {
      setFilterValue([]);
      column.setFilterValue([]);
    } else if (isRangeFilter) {
      setFilterValue("");
      column.setFilterValue((old) => {
        const newFilterValues = Array.isArray(old) && old || ["", ""];
        newFilterValues[rangeFilterIndex] = void 0;
        return newFilterValues;
      });
    } else {
      setFilterValue("");
      column.setFilterValue(void 0);
    }
  };
  const handleClearEmptyFilterChip = () => {
    setFilterValue("");
    column.setFilterValue(void 0);
    setColumnFilterFns((prev) => {
      var _a2;
      return Object.assign(Object.assign({}, prev), { [header.id]: (_a2 = allowedColumnFilterOptions === null || allowedColumnFilterOptions === void 0 ? void 0 : allowedColumnFilterOptions[0]) !== null && _a2 !== void 0 ? _a2 : "fuzzy" });
    });
  };
  const handleFilterMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const isMounted = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    if (isMounted.current) {
      const filterValue2 = column.getFilterValue();
      if (filterValue2 === void 0) {
        handleClear();
      } else if (isRangeFilter && rangeFilterIndex !== void 0) {
        setFilterValue(filterValue2[rangeFilterIndex]);
      } else {
        setFilterValue(filterValue2);
      }
    }
    isMounted.current = true;
  }, [column.getFilterValue()]);
  if (columnDef.Filter) {
    return (0, import_jsx_runtime24.jsx)(import_jsx_runtime24.Fragment, { children: (_h = columnDef.Filter) === null || _h === void 0 ? void 0 : _h.call(columnDef, { column, header, rangeFilterIndex, table }) });
  }
  const dropdownOptions = (0, import_react.useMemo)(() => {
    var _a2;
    return (_a2 = columnDef.filterSelectOptions) !== null && _a2 !== void 0 ? _a2 : (isSelectFilter || isMultiSelectFilter || isAutocompleteFilter) && facetedUniqueValues ? Array.from(facetedUniqueValues.keys()).filter((value) => value !== null && value !== void 0).sort((a, b) => a.localeCompare(b)) : void 0;
  }, [
    columnDef.filterSelectOptions,
    facetedUniqueValues,
    isMultiSelectFilter,
    isSelectFilter
  ]);
  const endAdornment = !isAutocompleteFilter && !isDateFilter && !filterChipLabel ? (0, import_jsx_runtime24.jsx)(InputAdornment_default, { position: "end", sx: { mr: isSelectFilter || isMultiSelectFilter ? "20px" : void 0 }, children: (0, import_jsx_runtime24.jsx)(Tooltip_default, { placement: "right", title: (_j = localization.clearFilter) !== null && _j !== void 0 ? _j : "", children: (0, import_jsx_runtime24.jsx)("span", { children: (0, import_jsx_runtime24.jsx)(IconButton_default, { "aria-label": localization.clearFilter, disabled: !((_k = filterValue === null || filterValue === void 0 ? void 0 : filterValue.toString()) === null || _k === void 0 ? void 0 : _k.length), onClick: handleClear, size: "small", sx: {
    height: "2rem",
    transform: "scale(0.9)",
    width: "2rem"
  }, children: (0, import_jsx_runtime24.jsx)(CloseIcon2, {}) }) }) }) }) : null;
  const startAdornment = showChangeModeButton ? (0, import_jsx_runtime24.jsxs)(InputAdornment_default, { position: "start", children: [(0, import_jsx_runtime24.jsx)(Tooltip_default, { title: localization.changeFilterMode, children: (0, import_jsx_runtime24.jsx)("span", { children: (0, import_jsx_runtime24.jsx)(IconButton_default, { "aria-label": localization.changeFilterMode, onClick: handleFilterMenuOpen, size: "small", sx: { height: "1.75rem", width: "1.75rem" }, children: (0, import_jsx_runtime24.jsx)(FilterListIcon2, {}) }) }) }), filterChipLabel && (0, import_jsx_runtime24.jsx)(Chip_default, { label: filterChipLabel, onDelete: handleClearEmptyFilterChip })] }) : null;
  const commonTextFieldProps = Object.assign(Object.assign({ FormHelperTextProps: {
    sx: {
      fontSize: "0.75rem",
      lineHeight: "0.8rem",
      whiteSpace: "nowrap"
    }
  }, InputProps: endAdornment ? { endAdornment, startAdornment } : { startAdornment }, fullWidth: true, helperText: showChangeModeButton ? (0, import_jsx_runtime24.jsx)("label", { children: localization.filterMode.replace(
    "{filterType}",
    // @ts-ignore
    localization[`filter${((_l = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _l === void 0 ? void 0 : _l.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ) }) : null, inputProps: {
    "aria-label": filterPlaceholder,
    autoComplete: "new-password",
    // disable autocomplete and autofill
    disabled: !!filterChipLabel,
    sx: {
      textOverflow: "ellipsis",
      width: filterChipLabel ? 0 : void 0
    },
    title: filterPlaceholder
  }, inputRef: (inputRef) => {
    filterInputRefs.current[`${column.id}-${rangeFilterIndex !== null && rangeFilterIndex !== void 0 ? rangeFilterIndex : 0}`] = inputRef;
    if (textFieldProps.inputRef) {
      textFieldProps.inputRef = inputRef;
    }
  }, margin: "none", placeholder: filterChipLabel || isSelectFilter || isMultiSelectFilter ? void 0 : filterPlaceholder, variant: "standard" }, textFieldProps), { sx: (theme) => Object.assign({ minWidth: isDateFilter ? "160px" : enableColumnFilterModes && rangeFilterIndex === 0 ? "110px" : isRangeFilter ? "100px" : !filterChipLabel ? "120px" : "auto", mx: "-2px", p: 0, width: "calc(100% + 4px)" }, parseFromValuesOrFunc(textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.sx, theme)) });
  const commonDatePickerProps = {
    onChange: (newDate) => {
      handleChange(newDate);
    },
    value: filterValue || null
  };
  return (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith("time")) ? (0, import_jsx_runtime24.jsx)(TimePicker, Object.assign({}, commonDatePickerProps, timePickerProps, { slotProps: {
    field: Object.assign({ clearable: true, onClear: () => handleClear() }, (_m = timePickerProps === null || timePickerProps === void 0 ? void 0 : timePickerProps.slotProps) === null || _m === void 0 ? void 0 : _m.field),
    textField: Object.assign(Object.assign({}, commonTextFieldProps), (_o = timePickerProps === null || timePickerProps === void 0 ? void 0 : timePickerProps.slotProps) === null || _o === void 0 ? void 0 : _o.textField)
  } })) : (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith("datetime")) ? (0, import_jsx_runtime24.jsx)(DateTimePicker, Object.assign({}, commonDatePickerProps, dateTimePickerProps, { slotProps: {
    field: Object.assign({ clearable: true, onClear: () => handleClear() }, (_p = dateTimePickerProps === null || dateTimePickerProps === void 0 ? void 0 : dateTimePickerProps.slotProps) === null || _p === void 0 ? void 0 : _p.field),
    textField: Object.assign(Object.assign({}, commonTextFieldProps), (_q = dateTimePickerProps === null || dateTimePickerProps === void 0 ? void 0 : dateTimePickerProps.slotProps) === null || _q === void 0 ? void 0 : _q.textField)
  } })) : (filterVariant === null || filterVariant === void 0 ? void 0 : filterVariant.startsWith("date")) ? (0, import_jsx_runtime24.jsx)(DatePicker, Object.assign({}, commonDatePickerProps, datePickerProps, { slotProps: {
    field: Object.assign({ clearable: true, onClear: () => handleClear() }, (_r = datePickerProps === null || datePickerProps === void 0 ? void 0 : datePickerProps.slotProps) === null || _r === void 0 ? void 0 : _r.field),
    textField: Object.assign(Object.assign({}, commonTextFieldProps), (_s = datePickerProps === null || datePickerProps === void 0 ? void 0 : datePickerProps.slotProps) === null || _s === void 0 ? void 0 : _s.textField)
  } })) : isAutocompleteFilter ? (0, import_jsx_runtime24.jsx)(Autocomplete_default, Object.assign({ freeSolo: true, getOptionLabel: (option) => getValueAndLabel(option).label, onChange: (_e, newValue) => handleAutocompleteChange(newValue), options: (_t = dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.map((option) => getValueAndLabel(option))) !== null && _t !== void 0 ? _t : [] }, autocompleteProps, { renderInput: (builtinTextFieldProps) => {
    var _a2;
    return (0, import_jsx_runtime24.jsx)(TextField_default, Object.assign({}, builtinTextFieldProps, commonTextFieldProps, { InputProps: Object.assign(Object.assign({}, builtinTextFieldProps.InputProps), { startAdornment: (_a2 = commonTextFieldProps === null || commonTextFieldProps === void 0 ? void 0 : commonTextFieldProps.InputProps) === null || _a2 === void 0 ? void 0 : _a2.startAdornment }), inputProps: Object.assign(Object.assign({}, builtinTextFieldProps.inputProps), commonTextFieldProps === null || commonTextFieldProps === void 0 ? void 0 : commonTextFieldProps.inputProps), onChange: handleTextFieldChange, onClick: (e) => e.stopPropagation() }));
  }, value: autocompleteValue })) : (0, import_jsx_runtime24.jsx)(TextField_default, Object.assign({ select: isSelectFilter || isMultiSelectFilter }, commonTextFieldProps, { SelectProps: Object.assign({ MenuProps: { disableScrollLock: true }, displayEmpty: true, multiple: isMultiSelectFilter, renderValue: isMultiSelectFilter ? (selected) => !(selected === null || selected === void 0 ? void 0 : selected.length) ? (0, import_jsx_runtime24.jsx)(Box_default, { sx: { opacity: 0.5 }, children: filterPlaceholder }) : (0, import_jsx_runtime24.jsx)(Box_default, { sx: { display: "flex", flexWrap: "wrap", gap: "2px" }, children: selected === null || selected === void 0 ? void 0 : selected.map((value) => {
    const selectedValue = dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.find((option) => getValueAndLabel(option).value === value);
    return (0, import_jsx_runtime24.jsx)(Chip_default, { label: getValueAndLabel(selectedValue).label }, value);
  }) }) : void 0 }, commonTextFieldProps.SelectProps), onChange: handleTextFieldChange, onClick: (e) => e.stopPropagation(), value: filterValue !== null && filterValue !== void 0 ? filterValue : "", children: (isSelectFilter || isMultiSelectFilter) && [
    (0, import_jsx_runtime24.jsx)(MenuItem_default, { disabled: true, divider: true, hidden: true, value: "", children: (0, import_jsx_runtime24.jsx)(Box_default, { sx: { opacity: 0.5 }, children: filterPlaceholder }) }, "p"),
    ...[
      (_u = textFieldProps.children) !== null && _u !== void 0 ? _u : dropdownOptions === null || dropdownOptions === void 0 ? void 0 : dropdownOptions.map((option, index) => {
        var _a2;
        const { label, value } = getValueAndLabel(option);
        return (0, import_jsx_runtime24.jsxs)(MenuItem_default, { sx: {
          alignItems: "center",
          display: "flex",
          gap: "0.5rem",
          m: 0
        }, value, children: [isMultiSelectFilter && (0, import_jsx_runtime24.jsx)(Checkbox_default, { checked: ((_a2 = column.getFilterValue()) !== null && _a2 !== void 0 ? _a2 : []).includes(value), sx: { mr: "0.5rem" } }), label, " ", !columnDef.filterSelectOptions && `(${facetedUniqueValues.get(value)})`] }, `${index}-${value}`);
      })
    ]
  ] })), (0, import_jsx_runtime24.jsx)(MRT_FilterOptionMenu, { anchorEl, header, setAnchorEl, setFilterValue, table })] });
};
var MRT_FilterRangeFields = (_a) => {
  var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
  return (0, import_jsx_runtime24.jsxs)(Box_default, Object.assign({}, rest, { sx: (theme) => Object.assign({ display: "grid", gap: "1rem", gridTemplateColumns: "1fr 1fr" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: [(0, import_jsx_runtime24.jsx)(MRT_FilterTextField, { header, rangeFilterIndex: 0, table }), (0, import_jsx_runtime24.jsx)(MRT_FilterTextField, { header, rangeFilterIndex: 1, table })] }));
};
var MRT_FilterRangeSlider = (_a) => {
  var _b, _c;
  var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
  const { options: { enableColumnFilterModes, localization, muiFilterSliderProps }, refs: { filterInputRefs } } = table;
  const { column } = header;
  const { columnDef } = column;
  const currentFilterOption = columnDef._filterFn;
  const showChangeModeButton = enableColumnFilterModes && columnDef.enableColumnFilterModes !== false;
  const sliderProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiFilterSliderProps, { column, table })), parseFromValuesOrFunc(columnDef.muiFilterSliderProps, { column, table })), rest);
  let [min2, max2] = sliderProps.min !== void 0 && sliderProps.max !== void 0 ? [sliderProps.min, sliderProps.max] : (_b = column.getFacetedMinMaxValues()) !== null && _b !== void 0 ? _b : [0, 1];
  if (Array.isArray(min2))
    min2 = min2[0];
  if (Array.isArray(max2))
    max2 = max2[0];
  if (min2 === null)
    min2 = 0;
  if (max2 === null)
    max2 = 1;
  const [filterValues, setFilterValues] = (0, import_react.useState)([min2, max2]);
  const columnFilterValue = column.getFilterValue();
  const isMounted = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    if (isMounted.current) {
      if (columnFilterValue === void 0) {
        setFilterValues([min2, max2]);
      } else if (Array.isArray(columnFilterValue)) {
        setFilterValues(columnFilterValue);
      }
    }
    isMounted.current = true;
  }, [columnFilterValue, min2, max2]);
  return (0, import_jsx_runtime24.jsxs)(Stack_default, { children: [(0, import_jsx_runtime24.jsx)(Slider_default, Object.assign({ disableSwap: true, max: max2, min: min2, onChange: (_event, values) => {
    setFilterValues(values);
  }, onChangeCommitted: (_event, value) => {
    if (Array.isArray(value)) {
      if (value[0] <= min2 && value[1] >= max2) {
        column.setFilterValue(void 0);
      } else {
        column.setFilterValue(value);
      }
    }
  }, value: filterValues, valueLabelDisplay: "auto" }, sliderProps, { slotProps: {
    input: {
      ref: (node) => {
        var _a2, _b2;
        if (node) {
          filterInputRefs.current[`${column.id}-0`] = node;
          if ((_b2 = (_a2 = sliderProps === null || sliderProps === void 0 ? void 0 : sliderProps.slotProps) === null || _a2 === void 0 ? void 0 : _a2.input) === null || _b2 === void 0 ? void 0 : _b2.ref) {
            sliderProps.slotProps.input.ref = node;
          }
        }
      }
    }
  }, sx: (theme) => Object.assign({ m: "auto", minWidth: `${column.getSize() - 50}px`, mt: !showChangeModeButton ? "10px" : "6px", px: "4px", width: "calc(100% - 8px)" }, parseFromValuesOrFunc(sliderProps === null || sliderProps === void 0 ? void 0 : sliderProps.sx, theme)) })), showChangeModeButton ? (0, import_jsx_runtime24.jsx)(FormHelperText_default, { sx: {
    fontSize: "0.75rem",
    lineHeight: "0.8rem",
    m: "-3px -6px",
    whiteSpace: "nowrap"
  }, children: localization.filterMode.replace(
    "{filterType}",
    // @ts-ignore
    localization[`filter${((_c = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _c === void 0 ? void 0 : _c.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ) }) : null] });
};
var MRT_TableHeadCellFilterContainer = (_a) => {
  var _b;
  var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
  const { getState, options: { columnFilterDisplayMode } } = table;
  const { showColumnFilters } = getState();
  const { column } = header;
  const { columnDef } = column;
  return (0, import_jsx_runtime24.jsx)(Collapse_default, Object.assign({ in: showColumnFilters || columnFilterDisplayMode === "popover", mountOnEnter: true, unmountOnExit: true }, rest, { children: columnDef.filterVariant === "checkbox" ? (0, import_jsx_runtime24.jsx)(MRT_FilterCheckbox, { column, table }) : columnDef.filterVariant === "range-slider" ? (0, import_jsx_runtime24.jsx)(MRT_FilterRangeSlider, { header, table }) : ((_b = columnDef.filterVariant) === null || _b === void 0 ? void 0 : _b.includes("range")) || ["between", "betweenInclusive", "inNumberRange"].includes(columnDef._filterFn) ? (0, import_jsx_runtime24.jsx)(MRT_FilterRangeFields, { header, table }) : (0, import_jsx_runtime24.jsx)(MRT_FilterTextField, { header, table }) }));
};
var MRT_TableHeadCellFilterLabel = (_a) => {
  var _b, _c, _d;
  var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
  const { options: { columnFilterDisplayMode, icons: { FilterAltIcon: FilterAltIcon2 }, localization }, refs: { filterInputRefs }, setShowColumnFilters } = table;
  const { column } = header;
  const { columnDef } = column;
  const filterValue = column.getFilterValue();
  const [anchorEl, setAnchorEl] = (0, import_react.useState)(null);
  const isFilterActive = Array.isArray(filterValue) && filterValue.some(Boolean) || !!filterValue && !Array.isArray(filterValue);
  const isRangeFilter = ((_b = columnDef.filterVariant) === null || _b === void 0 ? void 0 : _b.includes("range")) || ["between", "betweenInclusive", "inNumberRange"].includes(columnDef._filterFn);
  const currentFilterOption = columnDef._filterFn;
  const filterTooltip = columnFilterDisplayMode === "popover" && !isFilterActive ? (_c = localization.filterByColumn) === null || _c === void 0 ? void 0 : _c.replace("{column}", String(columnDef.header)) : localization.filteringByColumn.replace("{column}", String(columnDef.header)).replace("{filterType}", currentFilterOption ? (
    // @ts-ignore
    localization[`filter${((_d = currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.charAt(0)) === null || _d === void 0 ? void 0 : _d.toUpperCase()) + (currentFilterOption === null || currentFilterOption === void 0 ? void 0 : currentFilterOption.slice(1))}`]
  ) : "").replace("{filterValue}", `"${Array.isArray(filterValue) ? filterValue.join(`" ${isRangeFilter ? localization.and : localization.or} "`) : filterValue}"`).replace('" "', "");
  return (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(Grow_default, { in: columnFilterDisplayMode === "popover" || !!filterValue && !isRangeFilter || isRangeFilter && // @ts-ignore
  (!!(filterValue === null || filterValue === void 0 ? void 0 : filterValue[0]) || !!(filterValue === null || filterValue === void 0 ? void 0 : filterValue[1])), unmountOnExit: true, children: (0, import_jsx_runtime24.jsx)(Box_default, { component: "span", sx: { flex: "0 0" }, children: (0, import_jsx_runtime24.jsx)(Tooltip_default, { placement: "top", title: filterTooltip, children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ disableRipple: true, onClick: (event) => {
    if (columnFilterDisplayMode === "popover") {
      setAnchorEl(event.currentTarget);
    } else {
      setShowColumnFilters(true);
    }
    queueMicrotask(() => {
      var _a2, _b2, _c2, _d2;
      (_b2 = (_a2 = filterInputRefs.current[`${column.id}-0`]) === null || _a2 === void 0 ? void 0 : _a2.focus) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      (_d2 = (_c2 = filterInputRefs.current[`${column.id}-0`]) === null || _c2 === void 0 ? void 0 : _c2.select) === null || _d2 === void 0 ? void 0 : _d2.call(_c2);
    });
    event.stopPropagation();
  }, size: "small" }, rest, { sx: (theme) => Object.assign({ height: "16px", ml: "4px", opacity: isFilterActive ? 1 : 0.3, p: "8px", transform: "scale(0.75)", transition: "all 150ms ease-in-out", width: "16px" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: (0, import_jsx_runtime24.jsx)(FilterAltIcon2, {}) })) }) }) }), (0, import_jsx_runtime24.jsx)(Popover_default, { anchorEl, anchorOrigin: {
    horizontal: "center",
    vertical: "top"
  }, disableScrollLock: true, onClick: (event) => event.stopPropagation(), onClose: (event) => {
    event.stopPropagation();
    setAnchorEl(null);
  }, onKeyDown: (event) => event.key === "Enter" && setAnchorEl(null), open: !!anchorEl, slotProps: { paper: { sx: { overflow: "visible" } } }, transformOrigin: {
    horizontal: "center",
    vertical: "bottom"
  }, children: (0, import_jsx_runtime24.jsx)(Box_default, { sx: { p: "1rem" }, children: (0, import_jsx_runtime24.jsx)(MRT_TableHeadCellFilterContainer, { header, table }) }) })] });
};
var MRT_TableHeadCellGrabHandle = (_a) => {
  var { column, table, tableHeadCellRef } = _a, rest = __rest(_a, ["column", "table", "tableHeadCellRef"]);
  const { getState, options: { enableColumnOrdering, muiColumnDragHandleProps }, setColumnOrder, setDraggingColumn, setHoveredColumn } = table;
  const { columnDef } = column;
  const { columnOrder, draggingColumn, hoveredColumn } = getState();
  const iconButtonProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiColumnDragHandleProps, { column, table })), parseFromValuesOrFunc(columnDef.muiColumnDragHandleProps, {
    column,
    table
  })), rest);
  const handleDragStart = (event) => {
    var _a2;
    (_a2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragStart) === null || _a2 === void 0 ? void 0 : _a2.call(iconButtonProps, event);
    setDraggingColumn(column);
    try {
      event.dataTransfer.setDragImage(tableHeadCellRef.current, 0, 0);
    } catch (e) {
      console.error(e);
    }
  };
  const handleDragEnd = (event) => {
    var _a2;
    (_a2 = iconButtonProps === null || iconButtonProps === void 0 ? void 0 : iconButtonProps.onDragEnd) === null || _a2 === void 0 ? void 0 : _a2.call(iconButtonProps, event);
    if ((hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      column.toggleGrouping();
    } else if (enableColumnOrdering && hoveredColumn && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) !== (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id)) {
      setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
    }
    setDraggingColumn(null);
    setHoveredColumn(null);
  };
  return (0, import_jsx_runtime24.jsx)(MRT_GrabHandleButton, Object.assign({}, iconButtonProps, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table }));
};
var MRT_TableHeadCellResizeHandle = (_a) => {
  var _b;
  var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
  const { getState, options: { columnResizeDirection, columnResizeMode }, setColumnSizingInfo } = table;
  const { density } = getState();
  const { column } = header;
  const handler = header.getResizeHandler();
  const mx = density === "compact" ? "-8px" : density === "comfortable" ? "-16px" : "-24px";
  const lr = column.columnDef.columnDefType === "display" ? "4px" : "0";
  return (0, import_jsx_runtime24.jsx)(Box_default, { className: "Mui-TableHeadCell-ResizeHandle-Wrapper", onDoubleClick: () => {
    setColumnSizingInfo((old) => Object.assign(Object.assign({}, old), { isResizingColumn: false }));
    column.resetSize();
  }, onMouseDown: handler, onTouchStart: handler, style: {
    transform: column.getIsResizing() && columnResizeMode === "onEnd" ? `translateX(${(columnResizeDirection === "rtl" ? -1 : 1) * ((_b = getState().columnSizingInfo.deltaOffset) !== null && _b !== void 0 ? _b : 0)}px)` : void 0
  }, sx: (theme) => ({
    "&:active > hr": {
      backgroundColor: theme.palette.info.main,
      opacity: header.subHeaders.length || columnResizeMode === "onEnd" ? 1 : 0
    },
    cursor: "col-resize",
    left: columnResizeDirection === "rtl" ? lr : void 0,
    ml: columnResizeDirection === "rtl" ? mx : void 0,
    mr: columnResizeDirection === "ltr" ? mx : void 0,
    position: "absolute",
    px: "4px",
    right: columnResizeDirection === "ltr" ? lr : void 0
  }), children: (0, import_jsx_runtime24.jsx)(Divider_default, { className: "Mui-TableHeadCell-ResizeHandle-Divider", flexItem: true, orientation: "vertical", sx: (theme) => Object.assign({ borderRadius: "2px", borderWidth: "2px", height: "24px", touchAction: "none", transform: "translateX(4px)", transition: column.getIsResizing() ? void 0 : "all 150ms ease-in-out", userSelect: "none", zIndex: 4 }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)) }) });
};
var MRT_TableHeadCellSortLabel = (_a) => {
  var { header, table } = _a, rest = __rest(_a, ["header", "table"]);
  const { getState, options: { icons: { ArrowDownwardIcon: ArrowDownwardIcon2, SyncAltIcon: SyncAltIcon2 }, localization } } = table;
  const { column } = header;
  const { columnDef } = column;
  const { isLoading, showSkeletons, sorting } = getState();
  const isSorted = !!column.getIsSorted();
  const sortTooltip = isLoading || showSkeletons ? "" : column.getIsSorted() ? column.getIsSorted() === "desc" ? localization.sortedByColumnDesc.replace("{column}", columnDef.header) : localization.sortedByColumnAsc.replace("{column}", columnDef.header) : column.getNextSortingOrder() === "desc" ? localization.sortByColumnDesc.replace("{column}", columnDef.header) : localization.sortByColumnAsc.replace("{column}", columnDef.header);
  const direction = isSorted ? column.getIsSorted() : void 0;
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, { placement: "top", title: sortTooltip, children: (0, import_jsx_runtime24.jsx)(Badge_default, { badgeContent: sorting.length > 1 ? column.getSortIndex() + 1 : 0, overlap: "circular", children: (0, import_jsx_runtime24.jsx)(TableSortLabel_default, Object.assign({ IconComponent: !isSorted ? (props) => (0, import_jsx_runtime24.jsx)(SyncAltIcon2, Object.assign({}, props, { direction, style: {
    transform: "rotate(-90deg) scaleX(0.9) translateX(-1px)"
  } })) : ArrowDownwardIcon2, active: true, "aria-label": sortTooltip, direction, onClick: (e) => {
    var _a2;
    e.stopPropagation();
    (_a2 = header.column.getToggleSortingHandler()) === null || _a2 === void 0 ? void 0 : _a2(e);
  } }, rest, { sx: (theme) => Object.assign({ ".MuiTableSortLabel-icon": {
    color: `${theme.palette.mode === "dark" ? theme.palette.text.primary : theme.palette.text.secondary} !important`
  }, flex: "0 0", opacity: isSorted ? 1 : 0.3, transition: "all 150ms ease-in-out", width: "3ch" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)) })) }) });
};
var MRT_TableHeadCell = (_a) => {
  var _b, _c, _d, _f, _g, _h;
  var { columnVirtualizer, header, staticColumnIndex, table } = _a, rest = __rest(_a, ["columnVirtualizer", "header", "staticColumnIndex", "table"]);
  const theme = useTheme();
  const { getState, options: { columnFilterDisplayMode, columnResizeDirection, columnResizeMode, enableColumnActions, enableColumnDragging, enableColumnOrdering, enableColumnPinning, enableGrouping, enableMultiSort, layoutMode, mrtTheme: { draggingBorderColor }, muiTableHeadCellProps }, refs: { tableHeadCellRefs }, setHoveredColumn } = table;
  const { columnSizingInfo, density, draggingColumn, grouping, hoveredColumn, showColumnFilters } = getState();
  const { column } = header;
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const tableCellProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadCellProps, { column, table })), parseFromValuesOrFunc(columnDef.muiTableHeadCellProps, {
    column,
    table
  })), rest);
  const isColumnPinned = enableColumnPinning && columnDef.columnDefType !== "group" && column.getIsPinned();
  const showColumnActions = (enableColumnActions || columnDef.enableColumnActions) && columnDef.enableColumnActions !== false;
  const showDragHandle = enableColumnDragging !== false && columnDef.enableColumnDragging !== false && (enableColumnDragging || enableColumnOrdering && columnDef.enableColumnOrdering !== false || enableGrouping && columnDef.enableGrouping !== false && !grouping.includes(column.id));
  const headerPL = (0, import_react.useMemo)(() => {
    let pl = 0;
    if (column.getCanSort())
      pl += 1;
    if (showColumnActions)
      pl += 1.75;
    if (showDragHandle)
      pl += 1.5;
    return pl;
  }, [showColumnActions, showDragHandle]);
  const draggingBorders = (0, import_react.useMemo)(() => {
    const showResizeBorder = columnSizingInfo.isResizingColumn === column.id && columnResizeMode === "onChange" && !header.subHeaders.length;
    const borderStyle = showResizeBorder ? `2px solid ${draggingBorderColor} !important` : (draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.id) === column.id ? `1px dashed ${theme.palette.grey[500]}` : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id ? `2px dashed ${draggingBorderColor}` : void 0;
    if (showResizeBorder) {
      return columnResizeDirection === "ltr" ? { borderRight: borderStyle } : { borderLeft: borderStyle };
    }
    const draggingBorders2 = borderStyle ? {
      borderLeft: borderStyle,
      borderRight: borderStyle,
      borderTop: borderStyle
    } : void 0;
    return draggingBorders2;
  }, [draggingColumn, hoveredColumn, columnSizingInfo.isResizingColumn]);
  const handleDragEnter = (_e) => {
    if (enableGrouping && (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone") {
      setHoveredColumn(null);
    }
    if (enableColumnOrdering && draggingColumn && columnDefType !== "group") {
      setHoveredColumn(columnDef.enableColumnOrdering !== false ? column : null);
    }
  };
  const HeaderElement = (_b = parseFromValuesOrFunc(columnDef.Header, {
    column,
    header,
    table
  })) !== null && _b !== void 0 ? _b : columnDef.header;
  return (0, import_jsx_runtime24.jsxs)(TableCell_default, Object.assign({ align: columnDefType === "group" ? "center" : theme.direction === "rtl" ? "right" : "left", colSpan: header.colSpan, "data-index": staticColumnIndex, "data-pinned": !!isColumnPinned || void 0, onDragEnter: handleDragEnter, ref: (node) => {
    var _a2;
    if (node) {
      tableHeadCellRefs.current[column.id] = node;
      if (columnDefType !== "group") {
        (_a2 = columnVirtualizer === null || columnVirtualizer === void 0 ? void 0 : columnVirtualizer.measureElement) === null || _a2 === void 0 ? void 0 : _a2.call(columnVirtualizer, node);
      }
    }
  } }, tableCellProps, { sx: (theme2) => Object.assign(Object.assign({ "& :hover": {
    ".MuiButtonBase-root": {
      opacity: 1
    }
  }, flexDirection: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "column" : void 0, fontWeight: "bold", overflow: "visible", p: density === "compact" ? "0.5rem" : density === "comfortable" ? columnDefType === "display" ? "0.75rem" : "1rem" : columnDefType === "display" ? "1rem 1.25rem" : "1.5rem", pb: columnDefType === "display" ? 0 : showColumnFilters || density === "compact" ? "0.4rem" : "0.6rem", pt: columnDefType === "group" || density === "compact" ? "0.25rem" : density === "comfortable" ? ".75rem" : "1.25rem", userSelect: enableMultiSort && column.getCanSort() ? "none" : void 0, verticalAlign: "top" }, getCommonMRTCellStyles({
    column,
    header,
    table,
    tableCellProps,
    theme: theme2
  })), draggingBorders), children: [header.isPlaceholder ? null : (_c = tableCellProps.children) !== null && _c !== void 0 ? _c : (0, import_jsx_runtime24.jsxs)(Box_default, { className: "Mui-TableHeadCell-Content", sx: {
    alignItems: "center",
    display: "flex",
    flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "right" ? "row-reverse" : "row",
    justifyContent: columnDefType === "group" || (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "center" ? "center" : column.getCanResize() ? "space-between" : "flex-start",
    position: "relative",
    width: "100%"
  }, children: [(0, import_jsx_runtime24.jsxs)(Box_default, { className: "Mui-TableHeadCell-Content-Labels", onClick: column.getToggleSortingHandler(), sx: {
    alignItems: "center",
    cursor: column.getCanSort() && columnDefType !== "group" ? "pointer" : void 0,
    display: "flex",
    flexDirection: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "right" ? "row-reverse" : "row",
    overflow: columnDefType === "data" ? "hidden" : void 0,
    pl: (tableCellProps === null || tableCellProps === void 0 ? void 0 : tableCellProps.align) === "center" ? `${headerPL}rem` : void 0
  }, children: [(0, import_jsx_runtime24.jsx)(Box_default, { className: "Mui-TableHeadCell-Content-Wrapper", sx: {
    "&:hover": {
      textOverflow: "clip"
    },
    minWidth: `${Math.min((_f = (_d = columnDef.header) === null || _d === void 0 ? void 0 : _d.length) !== null && _f !== void 0 ? _f : 0, 4)}ch`,
    overflow: columnDefType === "data" ? "hidden" : void 0,
    textOverflow: "ellipsis",
    whiteSpace: ((_h = (_g = columnDef.header) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 0) < 20 ? "nowrap" : "normal"
  }, children: HeaderElement }), column.getCanFilter() && (0, import_jsx_runtime24.jsx)(MRT_TableHeadCellFilterLabel, { header, table }), column.getCanSort() && (0, import_jsx_runtime24.jsx)(MRT_TableHeadCellSortLabel, { header, table })] }), columnDefType !== "group" && (0, import_jsx_runtime24.jsxs)(Box_default, { className: "Mui-TableHeadCell-Content-Actions", sx: {
    whiteSpace: "nowrap"
  }, children: [showDragHandle && (0, import_jsx_runtime24.jsx)(MRT_TableHeadCellGrabHandle, { column, table, tableHeadCellRef: {
    current: tableHeadCellRefs.current[column.id]
  } }), showColumnActions && (0, import_jsx_runtime24.jsx)(MRT_TableHeadCellColumnActionsButton, { header, table })] }), column.getCanResize() && (0, import_jsx_runtime24.jsx)(MRT_TableHeadCellResizeHandle, { header, table })] }), columnFilterDisplayMode === "subheader" && column.getCanFilter() && (0, import_jsx_runtime24.jsx)(MRT_TableHeadCellFilterContainer, { header, table })] }));
};
var MRT_TableHeadRow = (_a) => {
  var { columnVirtualizer, headerGroup, table } = _a, rest = __rest(_a, ["columnVirtualizer", "headerGroup", "table"]);
  const { options: { enableStickyHeader, layoutMode, mrtTheme: { baseBackgroundColor }, muiTableHeadRowProps } } = table;
  const { virtualColumns, virtualPaddingLeft, virtualPaddingRight } = columnVirtualizer !== null && columnVirtualizer !== void 0 ? columnVirtualizer : {};
  const tableRowProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadRowProps, {
    headerGroup,
    table
  })), rest);
  return (0, import_jsx_runtime24.jsxs)(TableRow_default, Object.assign({}, tableRowProps, { sx: (theme) => Object.assign({ backgroundColor: baseBackgroundColor, boxShadow: `4px 0 8px ${alpha(theme.palette.common.black, 0.1)}`, display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "flex" : void 0, position: enableStickyHeader && layoutMode === "semantic" ? "sticky" : "relative", top: 0 }, parseFromValuesOrFunc(tableRowProps === null || tableRowProps === void 0 ? void 0 : tableRowProps.sx, theme)), children: [virtualPaddingLeft ? (0, import_jsx_runtime24.jsx)("th", { style: { display: "flex", width: virtualPaddingLeft } }) : null, (virtualColumns !== null && virtualColumns !== void 0 ? virtualColumns : headerGroup.headers).map((headerOrVirtualHeader, staticColumnIndex) => {
    let header = headerOrVirtualHeader;
    if (columnVirtualizer) {
      staticColumnIndex = headerOrVirtualHeader.index;
      header = headerGroup.headers[staticColumnIndex];
    }
    return header ? (0, import_jsx_runtime24.jsx)(MRT_TableHeadCell, { columnVirtualizer, header, staticColumnIndex, table }, header.id) : null;
  }), virtualPaddingRight ? (0, import_jsx_runtime24.jsx)("th", { style: { display: "flex", width: virtualPaddingRight } }) : null] }));
};
var MRT_ToolbarAlertBanner = (_a) => {
  var _b, _c, _d;
  var { stackAlertBanner, table } = _a, rest = __rest(_a, ["stackAlertBanner", "table"]);
  const { getFilteredSelectedRowModel, getPrePaginationRowModel, getState, options: { enableRowSelection, enableSelectAll, localization, manualPagination, muiToolbarAlertBannerChipProps, muiToolbarAlertBannerProps, positionToolbarAlertBanner, renderToolbarAlertBannerContent, rowCount }, refs: { tablePaperRef } } = table;
  const { density, grouping, rowSelection, showAlertBanner } = getState();
  const alertProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiToolbarAlertBannerProps, {
    table
  })), rest);
  const chipProps = parseFromValuesOrFunc(muiToolbarAlertBannerChipProps, {
    table
  });
  const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().flatRows.length;
  const selectedRowCount = (0, import_react.useMemo)(() => manualPagination ? Object.values(rowSelection).filter(Boolean).length : getFilteredSelectedRowModel().rows.length, [rowSelection, totalRowCount, manualPagination]);
  const selectedAlert = selectedRowCount > 0 ? (0, import_jsx_runtime24.jsxs)(Stack_default, { alignItems: "center", direction: "row", gap: "16px", children: [(_c = (_b = localization.selectedCountOfRowCountRowsSelected) === null || _b === void 0 ? void 0 : _b.replace("{selectedCount}", selectedRowCount.toLocaleString())) === null || _c === void 0 ? void 0 : _c.replace("{rowCount}", totalRowCount.toString()), (0, import_jsx_runtime24.jsx)(Button_default, { onClick: (event) => getMRT_SelectAllHandler({ table })(event, false, true), size: "small", sx: { p: "2px" }, children: localization.clearSelection })] }) : null;
  const groupedAlert = grouping.length > 0 ? (0, import_jsx_runtime24.jsxs)("span", { children: [localization.groupedBy, " ", grouping.map((columnId, index) => (0, import_jsx_runtime24.jsxs)(import_react.Fragment, { children: [index > 0 ? localization.thenBy : "", (0, import_jsx_runtime24.jsx)(Chip_default, Object.assign({ label: table.getColumn(columnId).columnDef.header, onDelete: () => table.getColumn(columnId).toggleGrouping() }, chipProps))] }, `${index}-${columnId}`))] }) : null;
  return (0, import_jsx_runtime24.jsx)(Collapse_default, { in: showAlertBanner || !!selectedAlert || !!groupedAlert, timeout: stackAlertBanner ? 200 : 0, children: (0, import_jsx_runtime24.jsx)(Alert_default, Object.assign({ color: "info", icon: false }, alertProps, { sx: (theme) => {
    var _a2, _b2;
    return Object.assign({ "& .MuiAlert-message": {
      maxWidth: `calc(${(_b2 = (_a2 = tablePaperRef.current) === null || _a2 === void 0 ? void 0 : _a2.clientWidth) !== null && _b2 !== void 0 ? _b2 : 360}px - 1rem)`,
      width: "100%"
    }, borderRadius: 0, fontSize: "1rem", left: 0, mb: stackAlertBanner ? 0 : positionToolbarAlertBanner === "bottom" ? "-1rem" : void 0, p: 0, position: "relative", right: 0, top: 0, width: "100%", zIndex: 2 }, parseFromValuesOrFunc(alertProps === null || alertProps === void 0 ? void 0 : alertProps.sx, theme));
  }, children: (_d = renderToolbarAlertBannerContent === null || renderToolbarAlertBannerContent === void 0 ? void 0 : renderToolbarAlertBannerContent({
    groupedAlert,
    selectedAlert,
    table
  })) !== null && _d !== void 0 ? _d : (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(alertProps === null || alertProps === void 0 ? void 0 : alertProps.title) && (0, import_jsx_runtime24.jsx)(AlertTitle_default, { children: alertProps.title }), (0, import_jsx_runtime24.jsxs)(Stack_default, { sx: {
    p: positionToolbarAlertBanner !== "head-overlay" ? "0.5rem 1rem" : density === "spacious" ? "0.75rem 1.25rem" : density === "comfortable" ? "0.5rem 0.75rem" : "0.25rem 0.5rem"
  }, children: [alertProps === null || alertProps === void 0 ? void 0 : alertProps.children, (alertProps === null || alertProps === void 0 ? void 0 : alertProps.children) && (selectedAlert || groupedAlert) && (0, import_jsx_runtime24.jsx)("br", {}), (0, import_jsx_runtime24.jsxs)(Box_default, { sx: { display: "flex" }, children: [enableRowSelection && enableSelectAll && positionToolbarAlertBanner === "head-overlay" && (0, import_jsx_runtime24.jsx)(MRT_SelectCheckbox, { table }), " ", selectedAlert] }), selectedAlert && groupedAlert && (0, import_jsx_runtime24.jsx)("br", {}), groupedAlert] })] }) })) });
};
var MRT_TableHead = (_a) => {
  var { columnVirtualizer, table } = _a, rest = __rest(_a, ["columnVirtualizer", "table"]);
  const { getHeaderGroups, getSelectedRowModel, getState, options: { enableStickyHeader, layoutMode, muiTableHeadProps, positionToolbarAlertBanner }, refs: { tableHeadRef } } = table;
  const { isFullScreen, showAlertBanner } = getState();
  const tableHeadProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableHeadProps, { table })), rest);
  const stickyHeader = enableStickyHeader || isFullScreen;
  return (0, import_jsx_runtime24.jsx)(TableHead_default, Object.assign({}, tableHeadProps, { ref: (ref) => {
    tableHeadRef.current = ref;
    if (tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.ref) {
      tableHeadProps.ref.current = ref;
    }
  }, sx: (theme) => Object.assign({ display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, opacity: 0.97, position: stickyHeader ? "sticky" : "relative", top: stickyHeader && (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? 0 : void 0, zIndex: stickyHeader ? 2 : void 0 }, parseFromValuesOrFunc(tableHeadProps === null || tableHeadProps === void 0 ? void 0 : tableHeadProps.sx, theme)), children: positionToolbarAlertBanner === "head-overlay" && (showAlertBanner || getSelectedRowModel().rows.length > 0) ? (0, import_jsx_runtime24.jsx)("tr", { style: {
    display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0
  }, children: (0, import_jsx_runtime24.jsx)("th", { colSpan: table.getVisibleLeafColumns().length, style: {
    display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0,
    padding: 0
  }, children: (0, import_jsx_runtime24.jsx)(MRT_ToolbarAlertBanner, { table }) }) }) : getHeaderGroups().map((headerGroup) => (0, import_jsx_runtime24.jsx)(MRT_TableHeadRow, { columnVirtualizer, headerGroup, table }, headerGroup.id)) }));
};
var MRT_Table = (_a) => {
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getFlatHeaders, getState, options: { columns, enableStickyHeader, enableTableFooter, enableTableHead, layoutMode, memoMode, muiTableProps, renderCaption } } = table;
  const { columnSizing, columnSizingInfo, columnVisibility, isFullScreen } = getState();
  const tableProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableProps, { table })), rest);
  const Caption = parseFromValuesOrFunc(renderCaption, { table });
  const columnSizeVars = (0, import_react.useMemo)(() => {
    const headers = getFlatHeaders();
    const colSizes = {};
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i];
      const colSize = header.getSize();
      colSizes[`--header-${parseCSSVarId(header.id)}-size`] = colSize;
      colSizes[`--col-${parseCSSVarId(header.column.id)}-size`] = colSize;
    }
    return colSizes;
  }, [columns, columnSizing, columnSizingInfo, columnVisibility]);
  const columnVirtualizer = useMRT_ColumnVirtualizer(table);
  const commonTableGroupProps = {
    columnVirtualizer,
    table
  };
  return (0, import_jsx_runtime24.jsxs)(Table_default, Object.assign({ stickyHeader: enableStickyHeader || isFullScreen }, tableProps, { style: Object.assign(Object.assign({}, columnSizeVars), tableProps === null || tableProps === void 0 ? void 0 : tableProps.style), sx: (theme) => Object.assign({ borderCollapse: "separate", display: (layoutMode === null || layoutMode === void 0 ? void 0 : layoutMode.startsWith("grid")) ? "grid" : void 0, position: "relative" }, parseFromValuesOrFunc(tableProps === null || tableProps === void 0 ? void 0 : tableProps.sx, theme)), children: [!!Caption && (0, import_jsx_runtime24.jsx)("caption", { children: Caption }), enableTableHead && (0, import_jsx_runtime24.jsx)(MRT_TableHead, Object.assign({}, commonTableGroupProps)), memoMode === "table-body" || columnSizingInfo.isResizingColumn ? (0, import_jsx_runtime24.jsx)(Memo_MRT_TableBody, Object.assign({}, commonTableGroupProps)) : (0, import_jsx_runtime24.jsx)(MRT_TableBody, Object.assign({}, commonTableGroupProps)), enableTableFooter && (0, import_jsx_runtime24.jsx)(MRT_TableFooter, Object.assign({}, commonTableGroupProps))] }));
};
var MRT_TableLoadingOverlay = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { options: { localization, mrtTheme: { baseBackgroundColor }, muiCircularProgressProps } } = table;
  const circularProgressProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiCircularProgressProps, { table })), rest);
  return (0, import_jsx_runtime24.jsx)(Box_default, { sx: {
    alignItems: "center",
    backgroundColor: alpha(baseBackgroundColor, 0.5),
    bottom: 0,
    display: "flex",
    justifyContent: "center",
    left: 0,
    maxHeight: "100vh",
    position: "absolute",
    right: 0,
    top: 0,
    width: "100%",
    zIndex: 3
  }, children: (_b = circularProgressProps === null || circularProgressProps === void 0 ? void 0 : circularProgressProps.Component) !== null && _b !== void 0 ? _b : (0, import_jsx_runtime24.jsx)(CircularProgress_default, Object.assign({ "aria-label": localization.noRecordsToDisplay, id: "mrt-progress" }, circularProgressProps)) });
};
var MRT_CellActionMenu = (_a) => {
  var _b, _c;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { editDisplayMode, enableClickToCopy, enableEditing, icons: { ContentCopy: ContentCopy2, EditIcon: EditIcon2 }, localization, mrtTheme: { menuBackgroundColor }, renderCellActionMenuItems }, refs: { actionCellRef } } = table;
  const { actionCell, density } = getState();
  const cell = actionCell;
  const { row } = cell;
  const { column } = cell;
  const { columnDef } = column;
  const handleClose = (event) => {
    event === null || event === void 0 ? void 0 : event.stopPropagation();
    table.setActionCell(null);
    actionCellRef.current = null;
  };
  const internalMenuItems = [
    (parseFromValuesOrFunc(enableClickToCopy, cell) === "context-menu" || parseFromValuesOrFunc(columnDef.enableClickToCopy, cell) === "context-menu") && (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { icon: (0, import_jsx_runtime24.jsx)(ContentCopy2, {}), label: localization.copy, onClick: (event) => {
      event.stopPropagation();
      navigator.clipboard.writeText(cell.getValue());
      handleClose();
    }, table }, "mrt-copy"),
    parseFromValuesOrFunc(enableEditing, row) && editDisplayMode === "cell" && (0, import_jsx_runtime24.jsx)(MRT_ActionMenuItem, { icon: (0, import_jsx_runtime24.jsx)(EditIcon2, {}), label: localization.edit, onClick: () => {
      openEditingCell({ cell, table });
      handleClose();
    }, table }, "mrt-edit")
  ].filter(Boolean);
  const renderActionProps = {
    cell,
    closeMenu: handleClose,
    column,
    internalMenuItems,
    row,
    table
  };
  const menuItems = (_c = (_b = columnDef.renderCellActionMenuItems) === null || _b === void 0 ? void 0 : _b.call(columnDef, renderActionProps)) !== null && _c !== void 0 ? _c : renderCellActionMenuItems === null || renderCellActionMenuItems === void 0 ? void 0 : renderCellActionMenuItems(renderActionProps);
  return (!!(menuItems === null || menuItems === void 0 ? void 0 : menuItems.length) || !!(internalMenuItems === null || internalMenuItems === void 0 ? void 0 : internalMenuItems.length)) && (0, import_jsx_runtime24.jsx)(Menu_default, Object.assign({ MenuListProps: {
    dense: density === "compact",
    sx: {
      backgroundColor: menuBackgroundColor
    }
  }, anchorEl: actionCellRef.current, disableScrollLock: true, onClick: (event) => event.stopPropagation(), onClose: handleClose, open: !!cell, transformOrigin: { horizontal: -100, vertical: 8 } }, rest, { children: menuItems !== null && menuItems !== void 0 ? menuItems : internalMenuItems }));
};
var MRT_EditRowModal = (_a) => {
  var _b;
  var { open, table } = _a, rest = __rest(_a, ["open", "table"]);
  const { getState, options: { localization, muiCreateRowModalProps, muiEditRowDialogProps, onCreatingRowCancel, onEditingRowCancel, renderCreateRowDialogContent, renderEditRowDialogContent }, setCreatingRow, setEditingRow } = table;
  const { creatingRow, editingRow } = getState();
  const row = creatingRow !== null && creatingRow !== void 0 ? creatingRow : editingRow;
  const dialogProps = Object.assign(Object.assign(Object.assign({}, parseFromValuesOrFunc(muiEditRowDialogProps, { row, table })), creatingRow && parseFromValuesOrFunc(muiCreateRowModalProps, { row, table })), rest);
  const internalEditComponents = row.getAllCells().filter((cell) => cell.column.columnDef.columnDefType === "data").map((cell) => (0, import_jsx_runtime24.jsx)(MRT_EditCellTextField, { cell, table }, cell.id));
  return (0, import_jsx_runtime24.jsx)(Dialog_default, Object.assign({ fullWidth: true, maxWidth: "xs", onClose: (event, reason) => {
    var _a2;
    if (creatingRow) {
      onCreatingRowCancel === null || onCreatingRowCancel === void 0 ? void 0 : onCreatingRowCancel({ row, table });
      setCreatingRow(null);
    } else {
      onEditingRowCancel === null || onEditingRowCancel === void 0 ? void 0 : onEditingRowCancel({ row, table });
      setEditingRow(null);
    }
    row._valuesCache = {};
    (_a2 = dialogProps.onClose) === null || _a2 === void 0 ? void 0 : _a2.call(dialogProps, event, reason);
  }, open }, dialogProps, { children: (_b = creatingRow && (renderCreateRowDialogContent === null || renderCreateRowDialogContent === void 0 ? void 0 : renderCreateRowDialogContent({
    internalEditComponents,
    row,
    table
  })) || (renderEditRowDialogContent === null || renderEditRowDialogContent === void 0 ? void 0 : renderEditRowDialogContent({
    internalEditComponents,
    row,
    table
  }))) !== null && _b !== void 0 ? _b : (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(DialogTitle_default, { sx: { textAlign: "center" }, children: localization.edit }), (0, import_jsx_runtime24.jsx)(DialogContent_default, { children: (0, import_jsx_runtime24.jsx)("form", { onSubmit: (e) => e.preventDefault(), children: (0, import_jsx_runtime24.jsx)(Stack_default, { sx: {
    gap: "32px",
    paddingTop: "16px",
    width: "100%"
  }, children: internalEditComponents }) }) }), (0, import_jsx_runtime24.jsx)(DialogActions_default, { sx: { p: "1.25rem" }, children: (0, import_jsx_runtime24.jsx)(MRT_EditActionButtons, { row, table, variant: "text" }) })] }) }));
};
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
var MRT_TableContainer = (_a) => {
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { createDisplayMode, editDisplayMode, enableCellActions, enableStickyHeader, muiTableContainerProps }, refs: { bottomToolbarRef, tableContainerRef, topToolbarRef } } = table;
  const { actionCell, creatingRow, editingRow, isFullScreen, isLoading, showLoadingOverlay } = getState();
  const loading = showLoadingOverlay !== false && (isLoading || showLoadingOverlay);
  const [totalToolbarHeight, setTotalToolbarHeight] = (0, import_react.useState)(0);
  const tableContainerProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTableContainerProps, {
    table
  })), rest);
  useIsomorphicLayoutEffect2(() => {
    var _a2, _b, _c, _d;
    const topToolbarHeight = typeof document !== "undefined" ? (_b = (_a2 = topToolbarRef.current) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight) !== null && _b !== void 0 ? _b : 0 : 0;
    const bottomToolbarHeight = typeof document !== "undefined" ? (_d = (_c = bottomToolbarRef === null || bottomToolbarRef === void 0 ? void 0 : bottomToolbarRef.current) === null || _c === void 0 ? void 0 : _c.offsetHeight) !== null && _d !== void 0 ? _d : 0 : 0;
    setTotalToolbarHeight(topToolbarHeight + bottomToolbarHeight);
  });
  const createModalOpen = createDisplayMode === "modal" && creatingRow;
  const editModalOpen = editDisplayMode === "modal" && editingRow;
  return (0, import_jsx_runtime24.jsxs)(TableContainer_default, Object.assign({ "aria-busy": loading, "aria-describedby": loading ? "mrt-progress" : void 0 }, tableContainerProps, { ref: (node) => {
    if (node) {
      tableContainerRef.current = node;
      if (tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.ref) {
        tableContainerProps.ref.current = node;
      }
    }
  }, style: Object.assign({ maxHeight: isFullScreen ? `calc(100vh - ${totalToolbarHeight}px)` : void 0 }, tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.style), sx: (theme) => Object.assign({ maxHeight: enableStickyHeader ? `clamp(350px, calc(100vh - ${totalToolbarHeight}px), 9999px)` : void 0, maxWidth: "100%", overflow: "auto", position: "relative" }, parseFromValuesOrFunc(tableContainerProps === null || tableContainerProps === void 0 ? void 0 : tableContainerProps.sx, theme)), children: [loading ? (0, import_jsx_runtime24.jsx)(MRT_TableLoadingOverlay, { table }) : null, (0, import_jsx_runtime24.jsx)(MRT_Table, { table }), (createModalOpen || editModalOpen) && (0, import_jsx_runtime24.jsx)(MRT_EditRowModal, { open: true, table }), enableCellActions && actionCell && (0, import_jsx_runtime24.jsx)(MRT_CellActionMenu, { table })] }));
};
var MRT_LinearProgressBar = (_a) => {
  var { isTopToolbar, table } = _a, rest = __rest(_a, ["isTopToolbar", "table"]);
  const { getState, options: { muiLinearProgressProps } } = table;
  const { isSaving, showProgressBars } = getState();
  const linearProgressProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiLinearProgressProps, {
    isTopToolbar,
    table
  })), rest);
  return (0, import_jsx_runtime24.jsx)(Collapse_default, { in: showProgressBars !== false && (showProgressBars || isSaving), mountOnEnter: true, sx: {
    bottom: isTopToolbar ? 0 : void 0,
    position: "absolute",
    top: !isTopToolbar ? 0 : void 0,
    width: "100%"
  }, unmountOnExit: true, children: (0, import_jsx_runtime24.jsx)(LinearProgress_default, Object.assign({ "aria-busy": "true", "aria-label": "Loading", sx: { position: "relative" } }, linearProgressProps)) });
};
var defaultRowsPerPage = [5, 10, 15, 20, 25, 30, 50, 100];
var MRT_TablePagination = (_a) => {
  var { position = "bottom", table } = _a, rest = __rest(_a, ["position", "table"]);
  const theme = useTheme();
  const isMobile = useMediaQuery("(max-width: 720px)");
  const { getPrePaginationRowModel, getState, options: { enableToolbarInternalActions, icons: { ChevronLeftIcon: ChevronLeftIcon2, ChevronRightIcon: ChevronRightIcon2, FirstPageIcon: FirstPageIcon2, LastPageIcon: LastPageIcon2 }, localization, muiPaginationProps, paginationDisplayMode, rowCount }, setPageIndex, setPageSize } = table;
  const { pagination: { pageIndex = 0, pageSize = 10 }, showGlobalFilter } = getState();
  const paginationProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiPaginationProps, {
    table
  })), rest);
  const totalRowCount = rowCount !== null && rowCount !== void 0 ? rowCount : getPrePaginationRowModel().rows.length;
  const numberOfPages = Math.ceil(totalRowCount / pageSize);
  const showFirstLastPageButtons = numberOfPages > 2;
  const firstRowIndex = pageIndex * pageSize;
  const lastRowIndex = Math.min(pageIndex * pageSize + pageSize, totalRowCount);
  const _b = paginationProps !== null && paginationProps !== void 0 ? paginationProps : {}, { SelectProps = {}, disabled = false, rowsPerPageOptions = defaultRowsPerPage, showFirstButton = showFirstLastPageButtons, showLastButton = showFirstLastPageButtons, showRowsPerPage = true } = _b, restPaginationProps = __rest(_b, ["SelectProps", "disabled", "rowsPerPageOptions", "showFirstButton", "showLastButton", "showRowsPerPage"]);
  const disableBack = pageIndex <= 0 || disabled;
  const disableNext = lastRowIndex >= totalRowCount || disabled;
  if (isMobile && (SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.native) !== false) {
    SelectProps.native = true;
  }
  const tooltipProps = getCommonTooltipProps();
  return (0, import_jsx_runtime24.jsxs)(Box_default, { className: "MuiTablePagination-root", sx: {
    alignItems: "center",
    display: "flex",
    flexWrap: "wrap",
    gap: "8px",
    justifyContent: { md: "space-between", sm: "center" },
    justifySelf: "flex-end",
    mt: position === "top" && enableToolbarInternalActions && !showGlobalFilter ? "3rem" : void 0,
    position: "relative",
    px: "8px",
    py: "12px",
    zIndex: 2
  }, children: [showRowsPerPage && (0, import_jsx_runtime24.jsxs)(Box_default, { sx: { alignItems: "center", display: "flex", gap: "8px" }, children: [(0, import_jsx_runtime24.jsx)(InputLabel_default, { htmlFor: "mrt-rows-per-page", sx: { mb: 0 }, children: localization.rowsPerPage }), (0, import_jsx_runtime24.jsx)(Select_default, Object.assign({ MenuProps: { disableScrollLock: true }, disableUnderline: true, disabled, inputProps: {
    "aria-label": localization.rowsPerPage,
    id: "mrt-rows-per-page"
  }, label: localization.rowsPerPage, onChange: (event) => setPageSize(+event.target.value), sx: { mb: 0 }, value: pageSize, variant: "standard" }, SelectProps, { children: rowsPerPageOptions.map((option) => {
    var _a2;
    const value = typeof option !== "number" ? option.value : option;
    const label = typeof option !== "number" ? option.label : `${option}`;
    return (_a2 = SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.children) !== null && _a2 !== void 0 ? _a2 : (SelectProps === null || SelectProps === void 0 ? void 0 : SelectProps.native) ? (0, import_jsx_runtime24.jsx)("option", { value, children: label }, value) : (0, import_jsx_runtime24.jsx)(MenuItem_default, { sx: { m: 0 }, value, children: label }, value);
  }) }))] }), paginationDisplayMode === "pages" ? (0, import_jsx_runtime24.jsx)(Pagination_default, Object.assign({ count: numberOfPages, disabled, onChange: (_e, newPageIndex) => setPageIndex(newPageIndex - 1), page: pageIndex + 1, renderItem: (item) => (0, import_jsx_runtime24.jsx)(PaginationItem_default, Object.assign({ slots: {
    first: FirstPageIcon2,
    last: LastPageIcon2,
    next: ChevronRightIcon2,
    previous: ChevronLeftIcon2
  } }, item)), showFirstButton, showLastButton }, restPaginationProps)) : paginationDisplayMode === "default" ? (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(Typography_default, { align: "center", component: "span", sx: { m: "0 4px", minWidth: "8ch" }, variant: "body2", children: `${lastRowIndex === 0 ? 0 : (firstRowIndex + 1).toLocaleString()}-${lastRowIndex.toLocaleString()} ${localization.of} ${totalRowCount.toLocaleString()}` }), (0, import_jsx_runtime24.jsxs)(Box_default, { gap: "xs", children: [showFirstButton && (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, tooltipProps, { title: localization.goToFirstPage, children: (0, import_jsx_runtime24.jsx)("span", { children: (0, import_jsx_runtime24.jsx)(IconButton_default, { "aria-label": localization.goToFirstPage, disabled: disableBack, onClick: () => setPageIndex(0), size: "small", children: (0, import_jsx_runtime24.jsx)(FirstPageIcon2, Object.assign({}, flipIconStyles(theme))) }) }) })), (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, tooltipProps, { title: localization.goToPreviousPage, children: (0, import_jsx_runtime24.jsx)("span", { children: (0, import_jsx_runtime24.jsx)(IconButton_default, { "aria-label": localization.goToPreviousPage, disabled: disableBack, onClick: () => setPageIndex(pageIndex - 1), size: "small", children: (0, import_jsx_runtime24.jsx)(ChevronLeftIcon2, Object.assign({}, flipIconStyles(theme))) }) }) })), (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, tooltipProps, { title: localization.goToNextPage, children: (0, import_jsx_runtime24.jsx)("span", { children: (0, import_jsx_runtime24.jsx)(IconButton_default, { "aria-label": localization.goToNextPage, disabled: disableNext, onClick: () => setPageIndex(pageIndex + 1), size: "small", children: (0, import_jsx_runtime24.jsx)(ChevronRightIcon2, Object.assign({}, flipIconStyles(theme))) }) }) })), showLastButton && (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, tooltipProps, { title: localization.goToLastPage, children: (0, import_jsx_runtime24.jsx)("span", { children: (0, import_jsx_runtime24.jsx)(IconButton_default, { "aria-label": localization.goToLastPage, disabled: disableNext, onClick: () => setPageIndex(numberOfPages - 1), size: "small", children: (0, import_jsx_runtime24.jsx)(LastPageIcon2, Object.assign({}, flipIconStyles(theme))) }) }) }))] })] }) : null] });
};
var MRT_ToolbarDropZone = (_a) => {
  var _b, _c;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { enableGrouping, localization }, setHoveredColumn, setShowToolbarDropZone } = table;
  const { draggingColumn, grouping, hoveredColumn, showToolbarDropZone } = getState();
  const handleDragEnter = (_event) => {
    setHoveredColumn({ id: "drop-zone" });
  };
  (0, import_react.useEffect)(() => {
    var _a2;
    if (((_a2 = table.options.state) === null || _a2 === void 0 ? void 0 : _a2.showToolbarDropZone) !== void 0) {
      setShowToolbarDropZone(!!enableGrouping && !!draggingColumn && draggingColumn.columnDef.enableGrouping !== false && !grouping.includes(draggingColumn.id));
    }
  }, [enableGrouping, draggingColumn, grouping]);
  return (0, import_jsx_runtime24.jsx)(Fade_default, { in: showToolbarDropZone, children: (0, import_jsx_runtime24.jsx)(Box_default, Object.assign({ className: "Mui-ToolbarDropZone", onDragEnter: handleDragEnter }, rest, { sx: (theme) => Object.assign({ alignItems: "center", backdropFilter: "blur(4px)", backgroundColor: alpha(theme.palette.info.main, (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === "drop-zone" ? 0.2 : 0.1), border: `dashed ${theme.palette.info.main} 2px`, boxSizing: "border-box", display: "flex", height: "100%", justifyContent: "center", position: "absolute", width: "100%", zIndex: 4 }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: (0, import_jsx_runtime24.jsx)(Typography_default, { fontStyle: "italic", children: localization.dropToGroupBy.replace("{column}", (_c = (_b = draggingColumn === null || draggingColumn === void 0 ? void 0 : draggingColumn.columnDef) === null || _b === void 0 ? void 0 : _b.header) !== null && _c !== void 0 ? _c : "") }) })) });
};
var MRT_BottomToolbar = (_a) => {
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { enablePagination, muiBottomToolbarProps, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderBottomToolbarCustomActions }, refs: { bottomToolbarRef } } = table;
  const { isFullScreen } = getState();
  const isMobile = useMediaQuery("(max-width:720px)");
  const toolbarProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiBottomToolbarProps, { table })), rest);
  const stackAlertBanner = isMobile || !!renderBottomToolbarCustomActions;
  return (0, import_jsx_runtime24.jsxs)(Box_default, Object.assign({}, toolbarProps, { ref: (node) => {
    if (node) {
      bottomToolbarRef.current = node;
      if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
        toolbarProps.ref.current = node;
      }
    }
  }, sx: (theme) => Object.assign(Object.assign(Object.assign({}, getCommonToolbarStyles({ table, theme })), { bottom: isFullScreen ? "0" : void 0, boxShadow: `0 1px 2px -1px ${alpha(theme.palette.grey[700], 0.5)} inset`, left: 0, position: isFullScreen ? "fixed" : "relative", right: 0 }), parseFromValuesOrFunc(toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx, theme)), children: [(0, import_jsx_runtime24.jsx)(MRT_LinearProgressBar, { isTopToolbar: false, table }), positionToolbarAlertBanner === "bottom" && (0, import_jsx_runtime24.jsx)(MRT_ToolbarAlertBanner, { stackAlertBanner, table }), ["both", "bottom"].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : "") && (0, import_jsx_runtime24.jsx)(MRT_ToolbarDropZone, { table }), (0, import_jsx_runtime24.jsxs)(Box_default, { sx: {
    alignItems: "center",
    boxSizing: "border-box",
    display: "flex",
    justifyContent: "space-between",
    p: "0.5rem",
    width: "100%"
  }, children: [renderBottomToolbarCustomActions ? renderBottomToolbarCustomActions({ table }) : (0, import_jsx_runtime24.jsx)("span", {}), (0, import_jsx_runtime24.jsx)(Box_default, { sx: {
    display: "flex",
    justifyContent: "flex-end",
    position: stackAlertBanner ? "relative" : "absolute",
    right: 0,
    top: 0
  }, children: enablePagination && ["both", "bottom"].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : "") && (0, import_jsx_runtime24.jsx)(MRT_TablePagination, { position: "bottom", table }) })] })] }));
};
var MRT_ColumnPinningButtons = (_a) => {
  var { column, table } = _a, rest = __rest(_a, ["column", "table"]);
  const { options: { icons: { PushPinIcon: PushPinIcon2 }, localization } } = table;
  const handlePinColumn = (pinDirection) => {
    column.pin(pinDirection);
  };
  return (0, import_jsx_runtime24.jsx)(Box_default, Object.assign({}, rest, { sx: (theme) => Object.assign({ minWidth: "70px", textAlign: "center" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: column.getIsPinned() ? (0, import_jsx_runtime24.jsx)(Tooltip_default, { title: localization.unpin, children: (0, import_jsx_runtime24.jsx)(IconButton_default, { onClick: () => handlePinColumn(false), size: "small", children: (0, import_jsx_runtime24.jsx)(PushPinIcon2, {}) }) }) : (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(Tooltip_default, { title: localization.pinToLeft, children: (0, import_jsx_runtime24.jsx)(IconButton_default, { onClick: () => handlePinColumn("left"), size: "small", children: (0, import_jsx_runtime24.jsx)(PushPinIcon2, { style: {
    transform: "rotate(90deg)"
  } }) }) }), (0, import_jsx_runtime24.jsx)(Tooltip_default, { title: localization.pinToRight, children: (0, import_jsx_runtime24.jsx)(IconButton_default, { onClick: () => handlePinColumn("right"), size: "small", children: (0, import_jsx_runtime24.jsx)(PushPinIcon2, { style: {
    transform: "rotate(-90deg)"
  } }) }) })] }) }));
};
var MRT_ShowHideColumnsMenuItems = (_a) => {
  var _b;
  var { allColumns, column, hoveredColumn, isNestedColumns, setHoveredColumn, table } = _a, rest = __rest(_a, ["allColumns", "column", "hoveredColumn", "isNestedColumns", "setHoveredColumn", "table"]);
  const { getState, options: { enableColumnOrdering, enableColumnPinning, enableHiding, localization, mrtTheme: { draggingBorderColor } }, setColumnOrder } = table;
  const { columnOrder } = getState();
  const { columnDef } = column;
  const { columnDefType } = columnDef;
  const switchChecked = columnDefType !== "group" && column.getIsVisible() || columnDefType === "group" && column.getLeafColumns().some((col) => col.getIsVisible());
  const handleToggleColumnHidden = (column2) => {
    var _a2, _b2;
    if (columnDefType === "group") {
      (_b2 = (_a2 = column2 === null || column2 === void 0 ? void 0 : column2.columns) === null || _a2 === void 0 ? void 0 : _a2.forEach) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, (childColumn) => {
        childColumn.toggleVisibility(!switchChecked);
      });
    } else {
      column2.toggleVisibility();
    }
  };
  const menuItemRef = (0, import_react.useRef)(null);
  const [isDragging, setIsDragging] = (0, import_react.useState)(false);
  const handleDragStart = (e) => {
    setIsDragging(true);
    try {
      e.dataTransfer.setDragImage(menuItemRef.current, 0, 0);
    } catch (e2) {
      console.error(e2);
    }
  };
  const handleDragEnd = (_e) => {
    setIsDragging(false);
    setHoveredColumn(null);
    if (hoveredColumn) {
      setColumnOrder(reorderColumn(column, hoveredColumn, columnOrder));
    }
  };
  const handleDragEnter = (_e) => {
    if (!isDragging && columnDef.enableColumnOrdering !== false) {
      setHoveredColumn(column);
    }
  };
  if (!columnDef.header || columnDef.visibleInShowHideMenu === false) {
    return null;
  }
  return (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(MenuItem_default, Object.assign({ disableRipple: true, onDragEnter: handleDragEnter, ref: menuItemRef }, rest, { sx: (theme) => Object.assign({ alignItems: "center", justifyContent: "flex-start", my: 0, opacity: isDragging ? 0.5 : 1, outline: isDragging ? `2px dashed ${theme.palette.grey[500]}` : (hoveredColumn === null || hoveredColumn === void 0 ? void 0 : hoveredColumn.id) === column.id ? `2px dashed ${draggingBorderColor}` : "none", outlineOffset: "-2px", pl: `${(column.depth + 0.5) * 2}rem`, py: "6px" }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: (0, import_jsx_runtime24.jsxs)(Box_default, { sx: {
    display: "flex",
    flexWrap: "nowrap",
    gap: "8px"
  }, children: [columnDefType !== "group" && enableColumnOrdering && !isNestedColumns && (columnDef.enableColumnOrdering !== false ? (0, import_jsx_runtime24.jsx)(MRT_GrabHandleButton, { onDragEnd: handleDragEnd, onDragStart: handleDragStart, table }) : (0, import_jsx_runtime24.jsx)(Box_default, { sx: { width: "28px" } })), enableColumnPinning && (column.getCanPin() ? (0, import_jsx_runtime24.jsx)(MRT_ColumnPinningButtons, { column, table }) : (0, import_jsx_runtime24.jsx)(Box_default, { sx: { width: "70px" } })), enableHiding ? (0, import_jsx_runtime24.jsx)(FormControlLabel_default, { checked: switchChecked, componentsProps: {
    typography: {
      sx: {
        mb: 0,
        opacity: columnDefType !== "display" ? 1 : 0.5
      }
    }
  }, control: (0, import_jsx_runtime24.jsx)(Tooltip_default, Object.assign({}, getCommonTooltipProps(), { title: localization.toggleVisibility, children: (0, import_jsx_runtime24.jsx)(Switch_default, {}) })), disabled: !column.getCanHide(), label: columnDef.header, onChange: () => handleToggleColumnHidden(column) }) : (0, import_jsx_runtime24.jsx)(Typography_default, { sx: { alignSelf: "center" }, children: columnDef.header })] }) })), (_b = column.columns) === null || _b === void 0 ? void 0 : _b.map((c, i) => (0, import_jsx_runtime24.jsx)(MRT_ShowHideColumnsMenuItems, { allColumns, column: c, hoveredColumn, isNestedColumns, setHoveredColumn, table }, `${i}-${c.id}`))] });
};
var MRT_ShowHideColumnsMenu = (_a) => {
  var { anchorEl, setAnchorEl, table } = _a, rest = __rest(_a, ["anchorEl", "setAnchorEl", "table"]);
  const { getAllColumns, getAllLeafColumns, getCenterLeafColumns, getIsAllColumnsVisible, getIsSomeColumnsPinned, getIsSomeColumnsVisible, getLeftLeafColumns, getRightLeafColumns, getState, options: { enableColumnOrdering, enableColumnPinning, enableHiding, localization, mrtTheme: { menuBackgroundColor } } } = table;
  const { columnOrder, columnPinning, density } = getState();
  const handleToggleAllColumns = (value) => {
    getAllLeafColumns().filter((col) => col.columnDef.enableHiding !== false).forEach((col) => col.toggleVisibility(value));
  };
  const allColumns = (0, import_react.useMemo)(() => {
    const columns = getAllColumns();
    if (columnOrder.length > 0 && !columns.some((col) => col.columnDef.columnDefType === "group")) {
      return [
        ...getLeftLeafColumns(),
        ...Array.from(new Set(columnOrder)).map((colId) => getCenterLeafColumns().find((col) => (col === null || col === void 0 ? void 0 : col.id) === colId)),
        ...getRightLeafColumns()
      ].filter(Boolean);
    }
    return columns;
  }, [
    columnOrder,
    columnPinning,
    getAllColumns(),
    getCenterLeafColumns(),
    getLeftLeafColumns(),
    getRightLeafColumns()
  ]);
  const isNestedColumns = allColumns.some((col) => col.columnDef.columnDefType === "group");
  const [hoveredColumn, setHoveredColumn] = (0, import_react.useState)(null);
  return (0, import_jsx_runtime24.jsxs)(Menu_default, Object.assign({ MenuListProps: {
    dense: density === "compact",
    sx: {
      backgroundColor: menuBackgroundColor
    }
  }, anchorEl, disableScrollLock: true, onClose: () => setAnchorEl(null), open: !!anchorEl }, rest, { children: [(0, import_jsx_runtime24.jsxs)(Box_default, { sx: {
    display: "flex",
    justifyContent: "space-between",
    p: "0.5rem",
    pt: 0
  }, children: [enableHiding && (0, import_jsx_runtime24.jsx)(Button_default, { disabled: !getIsSomeColumnsVisible(), onClick: () => handleToggleAllColumns(false), children: localization.hideAll }), enableColumnOrdering && (0, import_jsx_runtime24.jsx)(Button_default, { onClick: () => table.setColumnOrder(getDefaultColumnOrderIds(table.options, true)), children: localization.resetOrder }), enableColumnPinning && (0, import_jsx_runtime24.jsx)(Button_default, { disabled: !getIsSomeColumnsPinned(), onClick: () => table.resetColumnPinning(true), children: localization.unpinAll }), enableHiding && (0, import_jsx_runtime24.jsx)(Button_default, { disabled: getIsAllColumnsVisible(), onClick: () => handleToggleAllColumns(true), children: localization.showAll })] }), (0, import_jsx_runtime24.jsx)(Divider_default, {}), allColumns.map((column, index) => (0, import_jsx_runtime24.jsx)(MRT_ShowHideColumnsMenuItems, { allColumns, column, hoveredColumn, isNestedColumns, setHoveredColumn, table }, `${index}-${column.id}`))] }));
};
var MRT_ShowHideColumnsButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { options: { icons: { ViewColumnIcon: ViewColumnIcon2 }, localization } } = table;
  const [anchorEl, setAnchorEl] = (0, import_react.useState)(null);
  const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };
  return (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [(0, import_jsx_runtime24.jsx)(Tooltip_default, { title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideColumns, children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": localization.showHideColumns, onClick: handleClick }, rest, { title: void 0, children: (0, import_jsx_runtime24.jsx)(ViewColumnIcon2, {}) })) }), anchorEl && (0, import_jsx_runtime24.jsx)(MRT_ShowHideColumnsMenu, { anchorEl, setAnchorEl, table })] });
};
var MRT_ToggleDensePaddingButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { DensityLargeIcon: DensityLargeIcon2, DensityMediumIcon: DensityMediumIcon2, DensitySmallIcon: DensitySmallIcon2 }, localization }, setDensity } = table;
  const { density } = getState();
  const handleToggleDensePadding = () => {
    const nextDensity = density === "comfortable" ? "compact" : density === "compact" ? "spacious" : "comfortable";
    setDensity(nextDensity);
  };
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, { title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleDensity, children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": localization.toggleDensity, onClick: handleToggleDensePadding }, rest, { title: void 0, children: density === "compact" ? (0, import_jsx_runtime24.jsx)(DensitySmallIcon2, {}) : density === "comfortable" ? (0, import_jsx_runtime24.jsx)(DensityMediumIcon2, {}) : (0, import_jsx_runtime24.jsx)(DensityLargeIcon2, {}) })) });
};
var MRT_ToggleFiltersButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { FilterListIcon: FilterListIcon2, FilterListOffIcon: FilterListOffIcon2 }, localization }, setShowColumnFilters } = table;
  const { showColumnFilters } = getState();
  const handleToggleShowFilters = () => {
    setShowColumnFilters(!showColumnFilters);
  };
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, { title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideFilters, children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": localization.showHideFilters, onClick: handleToggleShowFilters }, rest, { title: void 0, children: showColumnFilters ? (0, import_jsx_runtime24.jsx)(FilterListOffIcon2, {}) : (0, import_jsx_runtime24.jsx)(FilterListIcon2, {}) })) });
};
var MRT_ToggleFullScreenButton = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { FullscreenExitIcon: FullscreenExitIcon2, FullscreenIcon: FullscreenIcon2 }, localization }, setIsFullScreen } = table;
  const { isFullScreen } = getState();
  const [tooltipOpened, setTooltipOpened] = (0, import_react.useState)(false);
  const handleToggleFullScreen = () => {
    setTooltipOpened(false);
    setIsFullScreen(!isFullScreen);
  };
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, { open: tooltipOpened, title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.toggleFullScreen, children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": localization.toggleFullScreen, onClick: handleToggleFullScreen, onMouseEnter: () => setTooltipOpened(true), onMouseLeave: () => setTooltipOpened(false) }, rest, { title: void 0, children: isFullScreen ? (0, import_jsx_runtime24.jsx)(FullscreenExitIcon2, {}) : (0, import_jsx_runtime24.jsx)(FullscreenIcon2, {}) })) });
};
var MRT_ToggleGlobalFilterButton = (_a) => {
  var _b, _c;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { icons: { SearchIcon: SearchIcon2, SearchOffIcon: SearchOffIcon2 }, localization }, refs: { searchInputRef }, setShowGlobalFilter } = table;
  const { globalFilter, showGlobalFilter } = getState();
  const handleToggleSearch = () => {
    setShowGlobalFilter(!showGlobalFilter);
    queueMicrotask(() => {
      var _a2;
      return (_a2 = searchInputRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    });
  };
  return (0, import_jsx_runtime24.jsx)(Tooltip_default, { title: (_b = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _b !== void 0 ? _b : localization.showHideSearch, children: (0, import_jsx_runtime24.jsx)(IconButton_default, Object.assign({ "aria-label": (_c = rest === null || rest === void 0 ? void 0 : rest.title) !== null && _c !== void 0 ? _c : localization.showHideSearch, disabled: !!globalFilter, onClick: handleToggleSearch }, rest, { title: void 0, children: showGlobalFilter ? (0, import_jsx_runtime24.jsx)(SearchOffIcon2, {}) : (0, import_jsx_runtime24.jsx)(SearchIcon2, {}) })) });
};
var MRT_ToolbarInternalButtons = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { options: { columnFilterDisplayMode, enableColumnFilters, enableColumnOrdering, enableColumnPinning, enableDensityToggle, enableFilters, enableFullScreenToggle, enableGlobalFilter, enableHiding, initialState, renderToolbarInternalActions } } = table;
  return (0, import_jsx_runtime24.jsx)(Box_default, Object.assign({}, rest, { sx: (theme) => Object.assign({ alignItems: "center", display: "flex", zIndex: 3 }, parseFromValuesOrFunc(rest === null || rest === void 0 ? void 0 : rest.sx, theme)), children: (_b = renderToolbarInternalActions === null || renderToolbarInternalActions === void 0 ? void 0 : renderToolbarInternalActions({
    table
  })) !== null && _b !== void 0 ? _b : (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [enableFilters && enableGlobalFilter && !(initialState === null || initialState === void 0 ? void 0 : initialState.showGlobalFilter) && (0, import_jsx_runtime24.jsx)(MRT_ToggleGlobalFilterButton, { table }), enableFilters && enableColumnFilters && columnFilterDisplayMode !== "popover" && (0, import_jsx_runtime24.jsx)(MRT_ToggleFiltersButton, { table }), (enableHiding || enableColumnOrdering || enableColumnPinning) && (0, import_jsx_runtime24.jsx)(MRT_ShowHideColumnsButton, { table }), enableDensityToggle && (0, import_jsx_runtime24.jsx)(MRT_ToggleDensePaddingButton, { table }), enableFullScreenToggle && (0, import_jsx_runtime24.jsx)(MRT_ToggleFullScreenButton, { table })] }) }));
};
var MRT_GlobalFilterTextField = (_a) => {
  var _b;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { enableGlobalFilterModes, icons: { CloseIcon: CloseIcon2, SearchIcon: SearchIcon2 }, localization, manualFiltering, muiSearchTextFieldProps }, refs: { searchInputRef }, setGlobalFilter } = table;
  const { globalFilter, showGlobalFilter } = getState();
  const textFieldProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiSearchTextFieldProps, {
    table
  })), rest);
  const isMounted = (0, import_react.useRef)(false);
  const [anchorEl, setAnchorEl] = (0, import_react.useState)(null);
  const [searchValue, setSearchValue] = (0, import_react.useState)(globalFilter !== null && globalFilter !== void 0 ? globalFilter : "");
  const handleChangeDebounced = (0, import_react.useCallback)(debounce_default((event) => {
    var _a2;
    setGlobalFilter((_a2 = event.target.value) !== null && _a2 !== void 0 ? _a2 : void 0);
  }, manualFiltering ? 500 : 250), []);
  const handleChange = (event) => {
    setSearchValue(event.target.value);
    handleChangeDebounced(event);
  };
  const handleGlobalFilterMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const handleClear = () => {
    setSearchValue("");
    setGlobalFilter(void 0);
  };
  (0, import_react.useEffect)(() => {
    if (isMounted.current) {
      if (globalFilter === void 0) {
        handleClear();
      } else {
        setSearchValue(globalFilter);
      }
    }
    isMounted.current = true;
  }, [globalFilter]);
  return (0, import_jsx_runtime24.jsxs)(Collapse_default, { in: showGlobalFilter, mountOnEnter: true, orientation: "horizontal", unmountOnExit: true, children: [(0, import_jsx_runtime24.jsx)(TextField_default, Object.assign({ inputProps: Object.assign({ autoComplete: "new-password" }, textFieldProps.inputProps), onChange: handleChange, placeholder: localization.search, size: "small", value: searchValue !== null && searchValue !== void 0 ? searchValue : "", variant: "outlined" }, textFieldProps, { InputProps: Object.assign(Object.assign({ endAdornment: (0, import_jsx_runtime24.jsx)(InputAdornment_default, { position: "end", children: (0, import_jsx_runtime24.jsx)(Tooltip_default, { title: (_b = localization.clearSearch) !== null && _b !== void 0 ? _b : "", children: (0, import_jsx_runtime24.jsx)("span", { children: (0, import_jsx_runtime24.jsx)(IconButton_default, { "aria-label": localization.clearSearch, disabled: !(searchValue === null || searchValue === void 0 ? void 0 : searchValue.length), onClick: handleClear, size: "small", children: (0, import_jsx_runtime24.jsx)(CloseIcon2, {}) }) }) }) }), startAdornment: enableGlobalFilterModes ? (0, import_jsx_runtime24.jsx)(InputAdornment_default, { position: "start", children: (0, import_jsx_runtime24.jsx)(Tooltip_default, { title: localization.changeSearchMode, children: (0, import_jsx_runtime24.jsx)(IconButton_default, { "aria-label": localization.changeSearchMode, onClick: handleGlobalFilterMenuOpen, size: "small", sx: { height: "1.75rem", width: "1.75rem" }, children: (0, import_jsx_runtime24.jsx)(SearchIcon2, {}) }) }) }) : (0, import_jsx_runtime24.jsx)(SearchIcon2, { style: { marginRight: "4px" } }) }, textFieldProps.InputProps), { sx: (theme) => {
    var _a2;
    return Object.assign({ mb: 0 }, parseFromValuesOrFunc((_a2 = textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.InputProps) === null || _a2 === void 0 ? void 0 : _a2.sx, theme));
  } }), inputRef: (inputRef) => {
    searchInputRef.current = inputRef;
    if (textFieldProps === null || textFieldProps === void 0 ? void 0 : textFieldProps.inputRef) {
      textFieldProps.inputRef = inputRef;
    }
  } })), (0, import_jsx_runtime24.jsx)(MRT_FilterOptionMenu, { anchorEl, onSelect: handleClear, setAnchorEl, table })] });
};
var MRT_TopToolbar = ({ table }) => {
  var _a;
  const { getState, options: { enableGlobalFilter, enablePagination, enableToolbarInternalActions, muiTopToolbarProps, positionGlobalFilter, positionPagination, positionToolbarAlertBanner, positionToolbarDropZone, renderTopToolbarCustomActions }, refs: { topToolbarRef } } = table;
  const { isFullScreen, showGlobalFilter } = getState();
  const isMobile = useMediaQuery("(max-width:720px)");
  const isTablet = useMediaQuery("(max-width:1024px)");
  const toolbarProps = parseFromValuesOrFunc(muiTopToolbarProps, { table });
  const stackAlertBanner = isMobile || !!renderTopToolbarCustomActions || showGlobalFilter && isTablet;
  const globalFilterProps = {
    sx: !isTablet ? {
      zIndex: 2
    } : void 0,
    table
  };
  return (0, import_jsx_runtime24.jsxs)(Box_default, Object.assign({}, toolbarProps, { ref: (ref) => {
    topToolbarRef.current = ref;
    if (toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.ref) {
      toolbarProps.ref.current = ref;
    }
  }, sx: (theme) => Object.assign(Object.assign(Object.assign({}, getCommonToolbarStyles({ table, theme })), { position: isFullScreen ? "sticky" : "relative", top: isFullScreen ? "0" : void 0 }), parseFromValuesOrFunc(toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.sx, theme)), children: [positionToolbarAlertBanner === "top" && (0, import_jsx_runtime24.jsx)(MRT_ToolbarAlertBanner, { stackAlertBanner, table }), ["both", "top"].includes(positionToolbarDropZone !== null && positionToolbarDropZone !== void 0 ? positionToolbarDropZone : "") && (0, import_jsx_runtime24.jsx)(MRT_ToolbarDropZone, { table }), (0, import_jsx_runtime24.jsxs)(Box_default, { sx: {
    alignItems: "flex-start",
    boxSizing: "border-box",
    display: "flex",
    gap: "0.5rem",
    justifyContent: "space-between",
    p: "0.5rem",
    position: stackAlertBanner ? "relative" : "absolute",
    right: 0,
    top: 0,
    width: "100%"
  }, children: [enableGlobalFilter && positionGlobalFilter === "left" && (0, import_jsx_runtime24.jsx)(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps)), (_a = renderTopToolbarCustomActions === null || renderTopToolbarCustomActions === void 0 ? void 0 : renderTopToolbarCustomActions({ table })) !== null && _a !== void 0 ? _a : (0, import_jsx_runtime24.jsx)("span", {}), enableToolbarInternalActions ? (0, import_jsx_runtime24.jsxs)(Box_default, { sx: {
    alignItems: "center",
    display: "flex",
    flexWrap: "wrap-reverse",
    gap: "0.5rem",
    justifyContent: "flex-end"
  }, children: [enableGlobalFilter && positionGlobalFilter === "right" && (0, import_jsx_runtime24.jsx)(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps)), (0, import_jsx_runtime24.jsx)(MRT_ToolbarInternalButtons, { table })] }) : enableGlobalFilter && positionGlobalFilter === "right" && (0, import_jsx_runtime24.jsx)(MRT_GlobalFilterTextField, Object.assign({}, globalFilterProps))] }), enablePagination && ["both", "top"].includes(positionPagination !== null && positionPagination !== void 0 ? positionPagination : "") && (0, import_jsx_runtime24.jsx)(MRT_TablePagination, { position: "top", table }), (0, import_jsx_runtime24.jsx)(MRT_LinearProgressBar, { isTopToolbar: true, table })] }));
};
var MRT_TablePaper = (_a) => {
  var _b, _c;
  var { table } = _a, rest = __rest(_a, ["table"]);
  const { getState, options: { enableBottomToolbar, enableTopToolbar, mrtTheme: { baseBackgroundColor }, muiTablePaperProps, renderBottomToolbar, renderTopToolbar }, refs: { tablePaperRef } } = table;
  const { isFullScreen } = getState();
  const paperProps = Object.assign(Object.assign({}, parseFromValuesOrFunc(muiTablePaperProps, { table })), rest);
  return (0, import_jsx_runtime24.jsxs)(Paper_default, Object.assign({ elevation: 2 }, paperProps, { ref: (ref) => {
    tablePaperRef.current = ref;
    if (paperProps === null || paperProps === void 0 ? void 0 : paperProps.ref) {
      paperProps.ref.current = ref;
    }
  }, style: Object.assign(Object.assign({}, isFullScreen ? {
    bottom: 0,
    height: "100vh",
    left: 0,
    margin: 0,
    maxHeight: "100vh",
    maxWidth: "100vw",
    padding: 0,
    position: "fixed",
    right: 0,
    top: 0,
    width: "100vw",
    zIndex: 999
  } : {}), paperProps === null || paperProps === void 0 ? void 0 : paperProps.style), sx: (theme) => Object.assign({ backgroundColor: baseBackgroundColor, backgroundImage: "unset", overflow: "hidden", transition: "all 100ms ease-in-out" }, parseFromValuesOrFunc(paperProps === null || paperProps === void 0 ? void 0 : paperProps.sx, theme)), children: [enableTopToolbar && ((_b = parseFromValuesOrFunc(renderTopToolbar, { table })) !== null && _b !== void 0 ? _b : (0, import_jsx_runtime24.jsx)(MRT_TopToolbar, { table })), (0, import_jsx_runtime24.jsx)(MRT_TableContainer, { table }), enableBottomToolbar && ((_c = parseFromValuesOrFunc(renderBottomToolbar, { table })) !== null && _c !== void 0 ? _c : (0, import_jsx_runtime24.jsx)(MRT_BottomToolbar, { table }))] }));
};
var isTableInstanceProp = (props) => props.table !== void 0;
var MaterialReactTable = (props) => {
  let table;
  if (isTableInstanceProp(props)) {
    table = props.table;
  } else {
    table = useMaterialReactTable(props);
  }
  return (0, import_jsx_runtime24.jsx)(MRT_TablePaper, { table });
};
export {
  MRT_ActionMenuItem,
  MRT_AggregationFns,
  MRT_BottomToolbar,
  MRT_ColumnActionMenu,
  MRT_ColumnPinningButtons,
  MRT_CopyButton,
  MRT_DefaultColumn,
  MRT_DefaultDisplayColumn,
  MRT_EditActionButtons,
  MRT_EditCellTextField,
  MRT_EditRowModal,
  MRT_ExpandAllButton,
  MRT_ExpandButton,
  MRT_FilterCheckbox,
  MRT_FilterFns,
  MRT_FilterOptionMenu,
  MRT_FilterRangeFields,
  MRT_FilterRangeSlider,
  MRT_FilterTextField,
  MRT_GlobalFilterTextField,
  MRT_GrabHandleButton,
  MRT_LinearProgressBar,
  MRT_RowActionMenu,
  MRT_RowPinButton,
  MRT_SelectCheckbox,
  MRT_ShowHideColumnsButton,
  MRT_ShowHideColumnsMenu,
  MRT_ShowHideColumnsMenuItems,
  MRT_SortingFns,
  MRT_Table,
  MRT_TableBody,
  MRT_TableBodyCell,
  MRT_TableBodyCellValue,
  MRT_TableBodyRow,
  MRT_TableBodyRowGrabHandle,
  MRT_TableBodyRowPinButton,
  MRT_TableContainer,
  MRT_TableDetailPanel,
  MRT_TableFooter,
  MRT_TableFooterCell,
  MRT_TableFooterRow,
  MRT_TableHead,
  MRT_TableHeadCell,
  MRT_TableHeadCellColumnActionsButton,
  MRT_TableHeadCellFilterContainer,
  MRT_TableHeadCellFilterLabel,
  MRT_TableHeadCellGrabHandle,
  MRT_TableHeadCellResizeHandle,
  MRT_TableHeadCellSortLabel,
  MRT_TableHeadRow,
  MRT_TableLoadingOverlay,
  MRT_TablePagination,
  MRT_TablePaper,
  MRT_ToggleDensePaddingButton,
  MRT_ToggleFiltersButton,
  MRT_ToggleFullScreenButton,
  MRT_ToggleGlobalFilterButton,
  MRT_ToggleRowActionMenuButton,
  MRT_ToolbarAlertBanner,
  MRT_ToolbarDropZone,
  MRT_ToolbarInternalButtons,
  MRT_TopToolbar,
  MaterialReactTable,
  Memo_MRT_TableBody,
  Memo_MRT_TableBodyCell,
  Memo_MRT_TableBodyRow,
  createMRTColumnHelper,
  createRow2 as createRow,
  defaultDisplayColumnProps,
  flexRender2 as flexRender,
  getAllLeafColumnDefs,
  getCanRankRows,
  getColumnId,
  getDefaultColumnFilterFn,
  getDefaultColumnOrderIds,
  getIsRankingRows,
  getIsRowSelected,
  getLeadingDisplayColumnIds,
  getMRT_RowSelectionHandler,
  getMRT_Rows,
  getMRT_SelectAllHandler,
  getTrailingDisplayColumnIds,
  isCellEditable,
  mrtFilterOptions,
  openEditingCell,
  prepareColumns,
  rankGlobalFuzzy,
  reorderColumn,
  showRowActionsColumn,
  showRowDragColumn,
  showRowExpandColumn,
  showRowNumbersColumn,
  showRowPinningColumn,
  showRowSelectionColumn,
  showRowSpacerColumn,
  useMRT_ColumnVirtualizer,
  useMRT_Effects,
  useMRT_RowVirtualizer,
  useMRT_Rows,
  useMRT_TableInstance,
  useMRT_TableOptions,
  useMaterialReactTable
};
/*! Bundled license information:

@tanstack/table-core/build/lib/index.mjs:
  (**
     * table-core
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     *)

@tanstack/react-table/build/lib/index.mjs:
  (**
     * react-table
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     *)

@tanstack/match-sorter-utils/build/lib/index.mjs:
  (**
     * match-sorter-utils
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     *)
  (**
   * @name match-sorter
   * @license MIT license.
   * @copyright (c) 2099 Kent C. Dodds
   * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)
   *)

@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs:
  (**
   * react-virtual
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs:
  (**
   * virtual-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/virtual-core/build/lib/utils.mjs:
  (**
   * virtual-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/virtual-core/build/lib/index.mjs:
  (**
   * virtual-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/react-virtual/build/lib/index.mjs:
  (**
   * react-virtual
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=material-react-table.js.map
